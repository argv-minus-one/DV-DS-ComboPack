// Note that this does *not* protect from melee attacks.
class PowerShielded : Powerup
{
	Class<PowerShielded_Shield> ShieldActorClass;
	property ShieldActorClass: ShieldActorClass;
	
	double ShieldActorSizeAdd;
	property ShieldActorSizeAdd: ShieldActorSizeAdd;
	
	default
	{
		PowerShielded.ShieldActorClass "PowerShielded_Shield";
		PowerShielded.ShieldActorSizeAdd .1;
	}
	
	PowerShielded_Shield ShieldActor;
	
	override void Tick()
	{
		Super.Tick();
		
		if (Owner && ShieldActor)
		{
			// On an owned inventory item, Tick is called immediately after its owner moves. Hence, we update the shield's position from here, *not* from the Tick method of the shield itself.
			ShieldActor.master = Owner;
			ShieldActor.ShieldThink(ShieldActorSizeAdd);
		}
	}
	
	override void InitEffect()
	{
		Super.InitEffect();
		
		if (Owner)
		{
			if (!ShieldActor)
			{
				ShieldActor = PowerShielded_Shield(Spawn(ShieldActorClass, Owner.Pos));
				ShieldActor.master = Owner;
				
				if (dvdsdebug_powershielded_showstatus) Console.Printf(
					"%s raising shield of type %s on owner %s.",
					GetClassName(),
					ShieldActor.GetClassName(),
					Owner.GetClassName()
				);
			}
			
			// Prevent the owner from being hit by radius damage. Let the shield take it.
			Owner.bNoRadiusDmg = true;
		}
	}
	
	override void EndEffect()
	{
		Super.EndEffect();
		
		if (ShieldActor)
		{
			// I'd use the ?: operator for this, but the engine claims the operands have incompatible types! Odd.
			String ownerName;
			if (Owner)
				ownerName = Owner.GetClassName();
			else
				ownerName = "<none>";
			
			if (dvdsdebug_powershielded_showstatus) Console.Printf(
				"%s lowering shield of type %s on owner %s.",
				GetClassName(),
				ShieldActor.GetClassName(),
				ownerName
			);
			ShieldActor.Destroy();
			ShieldActor = null;
		}
		
		if (Owner)
			Owner.bNoRadiusDmg = GetDefaultByType(Owner.GetClass()).bNoRadiusDmg;
	}
}

class PowerShielded_Shield : Actor
{
	default
	{
		Health 1;
		+SHOOTABLE;
		+DONTRIP;
		+NOTIMEFREEZE;
		+NOBLOOD;
		+NOBLOODDECALS;
		+NOGRAVITY;
		+NOTRIGGER;
		+NOTELEPORT;
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name damageType, int flags = 0, double angle = 0)
	{
		// By default, don't take damage. Subclasses may override this to pass some damage through to the owner.
		return 0;
	}
	
	void ShieldThink(double sizeAdd)
	{
		if (!master)
		{
			Console.Printf("\cr%s.ShieldThink called, but this actor has no owner!", GetClassName());
			Destroy();
			return;
		}
		
		A_SetSize(master.Radius + sizeAdd, master.Height + sizeAdd);
		A_Warp(
			AAPTR_MASTER,
			zofs: -(Height - master.Height) * .5,
			flags: WARPF_NOCHECKPOSITION | WARPF_BOB | WARPF_COPYVELOCITY | WARPF_COPYPITCH | WARPF_INTERPOLATE
		);
	}
	
	override void Tick()
	{
		Super.Tick();
		
		if (!master || master.bDestroyed)
		{
			if (dvdsdebug_powershielded_showstatus) Console.Printf(
				"%s no longer has an owner. Deleting.",
				GetClassName()
			);
			Destroy();
		}
	}
	
	states
	{
		Spawn:
			TNT1 A -1;
			stop;
	}
}
