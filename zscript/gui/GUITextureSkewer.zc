/**
 * Draws a texture, one row at a time. This allows the texture to be cleanly skewed, even in the software renderer.
 *
 * The main use-case for this widget is drawing the slanted meters in the HUD of the Aetherius mod.
 */
class GUITextureSkewer : GUIWidget {
	TextureID Texture;
	
	/**
	 * How far to skew the fill area, in pixels. Negative skew moves the top leftward; positive skew moves the top rightward.
	 */
	double Skew;
	
	/**
	 * Preferred size of this GUITextureSkewer on its long axis. This is reported through the PreferredWidth or PreferredHeight methods.
	 *
	 * Note that not all of this area is necessarily drawn into. See the DrawFraction field for details.
	 */
	double PreferredLength;
	
	/*
	 * Controls how much of the length is actually drawn. This doesn't affect preferred size computations, but does affect drawing. Hence, this can be used to draw meters that go up and down, without triggering a layout pass.
	 *
	 * If the DrawFraction is between 0 and 1, the area drawn is aligned according to the Align.X field. (Align.Y has no effect, because this widget always draws the entire height of its drawing area.)
	 *
	 * The DrawFraction's value is clamped to 0 through 1 when drawing. Values below 0 or above 1 will be treated as 0 and 1, respectively. In case it would be convenient to sometimes set such out-of-bounds values for this field, it is safe to do so.
	 */
	double DrawFraction;
	
	override double PreferredWidth(double height = -1.) {
		return Insets.X() + PreferredLength;
	}
	
	override double PreferredHeight(double width = -1.) {
		return Insets.Y() + TextureHeight();
	}
	
	protected int TextureHeight() {
		if (Texture.IsValid())
			return TexMan.CheckRealHeight(Texture);
		else
			return 0;
	}
	
	protected double MaxSkew, FillHeight;
	protected Rectangle RowRect;
	
	override void Layout() {
		Super.Layout();
		
		let height = double(TextureHeight());
		
		GetContentArea(RowRect);
		FillHeight = RowRect.Size.Y;
		
		if (height > 0.)
			RowRect.Size.Y /= height;
		else
			RowRect.Size.Y = 0;
		
		MaxSkew = Skew * height;
		RowRect.Origin.X += max(0., MaxSkew); // Compensate for positive skew.
		RowRect.Size.X -= abs(MaxSkew); // Compensate for all skew.
	}
	
	override void Draw() {
		let height = TextureHeight();
		if (RowRect.Size.X <= 0. || RowRect.Size.Y <= 0. || height < 1 || DrawFraction <= 0.)
			return;
		
		Rectangle nextRowRect;
		nextRowRect.Copy(RowRect);
		
		if (DrawFraction < 1.) {
			let adjWidth = nextRowRect.Size.X * DrawFraction;
			switch (Align.X) {
				case XALIGN_LEFT:
					// nextRowRect.Origin.X is already at the left edge.
					break;
				
				case XALIGN_RIGHT:
					nextRowRect.Origin.X = nextRowRect.Origin.X + nextRowRect.Size.X - adjWidth;
					break;
				
				default:
					nextRowRect.Origin.X = nextRowRect.Origin.X + (nextRowRect.Size.X / 2.) - (adjWidth / 2.);
			}
			nextRowRect.Size.X = adjWidth;
		}
		
		for (let i = 0; i < height; i++) {
			Screen.DrawTexture(
				Texture,
				false,
				nextRowRect.Origin.X, RowRect.Origin.Y,
				DTA_DestWidthF, nextRowRect.Size.X,
				DTA_DestHeightF, FillHeight,
				DTA_ClipTop, int(nextRowRect.Origin.Y),
				DTA_ClipBottom, int(nextRowRect.Origin.Y + nextRowRect.Size.Y + .5)
			);
			
			nextRowRect.Origin.X -= Skew;
			nextRowRect.Origin.Y += rowRect.Size.Y;
		}
	}
}
