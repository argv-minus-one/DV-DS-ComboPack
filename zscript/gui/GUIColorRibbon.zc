/**
 * Draws a gradient (or other array of colors), in narrow strips of one color at a time, with Screen.Clear.
 *
 * Normally, one accomplishes this by drawing a 1Ã—n texture, stretched out over the draw area. GUIColorRibbon's approach has some pros and cons:
 * Pro: The draw area can be cleanly skewed, even in the software renderer.
 * Con: This requires n draw calls (where n = the number of colors), instead of just one.
 *
 * The main use-case for this widget is drawing the slanted meters in the HUD of the Aetherius mod.
 *
 * This widget treats its Insets field specially, in that the insets are *not* counted toward the widget's preferred size. Thus, the insets can be used to control how much of the widget's bounds are actually drawn into. This is used to draw the aforementioned slanted meters.
 *
 * Note that the Layout method still needs to be called whenever the insets are changed. In the meter use-case, this will likely happen on every frame.
 */
class GUIColorRibbon : GUIWidget {
	Array<Color> Colors;
	
	/**
	 * How far to skew the fill area, in pixels. Negative skew moves the top leftward; positive skew moves the top rightward.
	 */
	double Skew;
	
	/**
	 * Preferred size of this GUIColorRibbon on its long axis. This is reported through the PreferredWidth or PreferredHeight methods.
	 */
	// MAYBE: Note that not all of this area is necessarily drawn into. See the DrawFraction field for details.
	double PreferredLength;
	
	/*
	 * Controls how much of the length is actually drawn. This doesn't affect preferred size computations, but does affect drawing. Hence, this can be used to draw meters that go up and down, without triggering a layout pass.
	 *
	 * If the DrawFraction is between 0 and 1, the area drawn is aligned according to the Align.X field. (Align.Y has no effect, because this widget always draws the entire height of its drawing area.)
	 *
	 * The DrawFraction's value is clamped to 0 through 1 when drawing. Values below 0 or above 1 will be treated as 0 and 1, respectively. In case it would be convenient to sometimes set such out-of-bounds values for this field, it is safe to do so.
	 */
	double DrawFraction;
	
	override double PreferredWidth(double height = -1.) {
		return Insets.X() + PreferredLength;
	}
	
	override double PreferredHeight(double width = -1.) {
		return Insets.Y() + Colors.Size();
	}
	
	protected double MaxSkew;
	protected Rectangle RowRect;
	
	override void Layout() {
		Super.Layout();
		
		let nColors = Colors.Size();
		
		GetContentArea(RowRect);
		
		if (Colors.Size() > 0)
			RowRect.Size.Y /= Colors.Size();
		else
			RowRect.Size.Y = 0;
		
		MaxSkew = Skew * double(nColors);
		RowRect.Origin.X += max(0., MaxSkew); // Compensate for positive skew.
		RowRect.Size.X -= abs(MaxSkew); // Compensate for all skew.
	}
	
	override void Draw() {
		let nColors = Colors.Size();
		if (RowRect.Size.X <= 0. || RowRect.Size.Y <= 0. || nColors < 1 || DrawFraction <= 0.)
			return;
		
		Rectangle nextRowRect;
		nextRowRect.Copy(RowRect);
		
		if (DrawFraction < 1.) {
			let adjWidth = nextRowRect.Size.X * DrawFraction;
			switch (Align.X) {
				case XALIGN_LEFT:
					// nextRowRect.Origin.X is already at the left edge.
					break;
				
				case XALIGN_RIGHT:
					nextRowRect.Origin.X = nextRowRect.Origin.X + nextRowRect.Size.X - adjWidth;
					break;
				
				default:
					nextRowRect.Origin.X = nextRowRect.Origin.X + (nextRowRect.Size.X / 2.) - (adjWidth / 2.);
			}
			nextRowRect.Size.X = adjWidth;
		}
		
		for (let i = 0; i < nColors; i++) {
			Screen.Clear(nextRowRect.Left(), nextRowRect.Top(), nextRowRect.Right(), nextRowRect.Bottom(), Colors[i]);
			
			nextRowRect.Origin.X -= Skew;
			nextRowRect.Origin.Y += rowRect.Size.Y;
		}
	}
}
