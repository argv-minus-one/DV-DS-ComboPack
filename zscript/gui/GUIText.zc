/**
 * A widget that draws text.
 *
 * The Layout method must be called whenever the text, font, wrap, or other layout-relevant settings are changed. However, you can avoid a full-tree layout pass by calling Layout on this widget directly, if the text content is likely to fit into the already-allocated area.
 *
 * To help with the aforementioned optimization (and with layout of text widgets in general), the preferred size of this widget can be influenced using the PrefLineLength and PrefWidthDirect fields. See the documentation of PrefLineLength for details.
 */
class GUIText : GUIWidget {
	String Text;
	Font TextFont;
	int TextColor;
	bool TextWrap;
	double Alpha;
	protected BrokenLines Lines;
	protected Array<double> LineOriginsX, LineOriginsY;
	
	/**
	 * Baseline of the TextFont, in pixels from the top. If this field has a non-zero value, text layout will be adjusted.
	 */
	uint16 FontBaseline;
	
	/**
	 * The preferred line length for text positioning and wrapping, in characters. If this value is not zero or negative, the preferred width is PrefLineLength * 1ch, where 1ch is (like CSS) the width of the ‘0’ (digit zero) character in the font used by this widget.
	 *
	 * Alternatively, you can set the preferred pixel width for this widget, by writing it to the PrefWidthDirect field.
	 *
	 * If this and PrefWidthDirect are both zero or negative, the preferred width is the widths of all the characters in the text to draw. So, if PrefLineLength is not set, this widget will prefer drawing all of its text on one long line, even if TextWrap is true. You need to set one of these fields if you want wrapping.
	 *
	 * The other purpose of these fields is to allow a GUIText's text content to change rapidly, without incurring the cost of a full-tree layout pass. This is useful for rapidly-changing text, like health/ammo/armor counters. For example, if you need to draw an actor's current health in 3 digits, set this to 3.
	 *
	 * You do still have to call Layout() on this widget after *every* change to the text. Still, this is cheaper than a full-tree layout pass.
	 *
	 * As usual with preferred size, it's only a hint to layout code, not a hard demand. Layout code is free to adjust or ignore it. If this widget is laid out with a different width, and line wrapping is enabled, lines will be laid out appropriately for that width.
	 */
	int PrefLineLength;
	
	double PrefWidthDirect;
	
	/**
	 * If true, this widget will not request a full layout pass if it isn't large enough to show all of its text.
	 *
	 * If combined with setting Align.X to XALIGN_LEFT and TextWrap to false, most layout calculations are skipped, making layout considerably less expensive. Use this for a GUIText that doesn't affect any other widget's size, and moves around the screen frequently.
	 */
	bool IgnoreOverflow;
	
	Rectangle CurrentTextBounds;
	
	override void Init(GUIWidget parent) {
		Super.Init(parent);
		Alpha = 1;
	}
	
	override double PreferredWidth(double height = -1.) {
		double width;
		
		if (PrefWidthDirect > 0.)
			width = PrefWidthDirect;
		else if (PrefLineLength > 0)
			width = PrefLineLength * TextFont.GetCharWidth(48);
		else if (Text)
			width = TextFont.StringWidth(Text);
		
		return width + Insets.X();
	}
	
	override double PreferredHeight(double width = -1.) {
		let fontHeight = TextFont.GetHeight();
		double height;
		
		// I would like to cache the result of BreakLines, in case Layout is called with exactly the same width, but ZScript has no weak map structure with which to do so.
		if (TextWrap && Text) {
			if (width <= 0.)
				width = PreferredWidth(-1);
			height = TextFont.BreakLines(Text, int(width)).Count() * fontHeight;
		}
		else if (Text)
			height = fontHeight;
		
		return height - GetFontDescent() + Insets.Y();
	}
	
	override EResizeBias ResizeBias() {
		return TextWrap? RBIAS_HORIZONTAL : RBIAS_NONE;
	}
	
	int GetFontDescent() {
		return FontBaseline != 0? max(TextFont.GetHeight() - FontBaseline, 0) : 0;
	}
	
	private bool LastLayoutOverflowed;
	
	override void Layout() {
		Super.Layout();
		
		let lineHeight = TextFont.GetHeight();
		let descent = GetFontDescent();
		
		Rectangle ca;
		GetContentArea(ca);
		
		if (Text == "") {
			Lines = null;
			LineOriginsX.Clear();
			LineOriginsY.Clear();
		}
		else if (TextWrap) {
			Lines = TextFont.BreakLines(Text, int(ca.Size.X));
			let nLines = Lines.Count();
			LineOriginsX.Resize(nLines);
			LineOriginsY.Resize(nLines);
			
			Rectangle textBounds;
			textBounds.Size.Y = (nLines * lineHeight) - descent;
			for (let i = 0; i < nLines; i++)
				textBounds.Size.X = max(textBounds.Size.X, Lines.StringWidth(i));
			textBounds.PositionIn(ca, Align.X, Align.Y);
			
			CurrentTextBounds.Copy(textBounds);
			CurrentTextBounds.Size.Y += descent;
			
			for (let i = 0; i < nLines; i++) {
				let text = Lines.StringAt(i);
				Rectangle lineRect;
				lineRect.Size.X = Lines.StringWidth(i);
				lineRect.Size.Y = lineHeight;
				lineRect.PositionIn(textBounds, Align.X, YALIGN_TOP);
				LineOriginsX[i] = lineRect.Origin.X;
				LineOriginsY[i] = lineRect.Origin.Y;
				textBounds.Origin.Y += lineHeight;
				textBounds.Size.Y -= lineHeight;
			}
			
			// Pretend that the bounds are large enough to fit the font's descent.
			textBounds.Size.Y += descent;
			
			if (!IgnoreOverflow && textBounds.Size.Y < 0.) {
				if (LastLayoutOverflowed)
					Console.Printf(
						"\cr%s does not have enough room to draw its text. The available space is (%f,%f), but the text at this width is %d pixels high. Text will be drawn out of bounds!",
						ToString(),
						ca.Size.X, ca.Size.Y,
						nLines * lineHeight
					);
				else {
					LastLayoutOverflowed = true;
					RequestLayout();
					
					if (zsgui_debug_text_overflow)
					Console.Printf(
						"%s: Text overflow. The available space is (%f,%f), but the text at this width is %d pixels high. Requesting full layout pass.",
						ToString(),
						ca.Size.X, ca.Size.Y,
						nLines * lineHeight
					);
				}
			}
			else
				LastLayoutOverflowed = false;
			
			// Indicate to observers if we're using extra space, even if overflow is otherwise ignored.
			CurrentTextBounds.Size.Y -= max(textBounds.Size.Y, 0.);
		}
		else {
			Lines = null;
			LineOriginsX.Resize(1);
			LineOriginsY.Resize(1);
			
			Rectangle lineRect;
			lineRect.Size = (
				Align.X == XALIGN_LEFT && IgnoreOverflow? 1 : TextFont.StringWidth(Text),
				lineHeight - descent
			);
			lineRect.PositionIn(ca, Align.X, Align.Y);
			
			CurrentTextBounds.Copy(lineRect);
			CurrentTextBounds.Size.Y += descent;
			
			LineOriginsX[0] = lineRect.Origin.X;
			LineOriginsY[0] = lineRect.Origin.Y;
			
			if (!IgnoreOverflow && (lineRect.Size.X > ca.Size.X || lineRect.Size.Y > ca.Size.Y + descent)) {
				if (LastLayoutOverflowed)
					Console.Printf(
						"\cr%s does not have enough room to draw its text. Line wrapping is disabled, and the required unwrapped space is (%f,%f), but the available space is (%f,%f). Text will be drawn out of bounds!",
						ToString(),
						lineRect.Size.X, lineRect.Size.Y,
						ca.Size.X, ca.Size.Y
					);
				else {
					LastLayoutOverflowed = true;
					RequestLayout();
					
					if (zsgui_debug_text_overflow)
						Console.Printf(
							"%s: Text overflow. Line wrapping is disabled, and the required unwrapped space is (%f,%f), but the available space is (%f,%f). Requesting full layout pass.",
							ToString(),
							lineRect.Size.X, lineRect.Size.Y,
							ca.Size.X, ca.Size.Y
						);
				}
			}
		}
	}
	
	override void Draw() {
		Super.Draw();
		
		if (Alpha <= 0.)
			return;
		
		for (let line = 0, nLines = LineOriginsX.Size(); line < nLines; line++) {
			let lineText = Lines? Lines.StringAt(line) : Text;
			Screen.DrawText(
				TextFont, TextColor,
				LineOriginsX[line], LineOriginsY[line],
				lineText,
				DTA_Alpha, Alpha
			);
			
			if (zsgui_debug_show_box_textlines)
				Screen.DrawFrame(LineOriginsX[line], LineOriginsY[line], TextFont.StringWidth(lineText), TextFont.GetHeight());
		}
	}
	
	override String ToString() {
		let textBeginning = Text.Left(40);
		if (Text.Length() > textBeginning.Length())
			textBeginning = textBeginning.."...";
		
		return Super.ToString().." \""..textBeginning.."\"";
	}
	
	static int OneChWidth(Font font) {
		return font.GetCharWidth(48);
	}
}
