/**
 * A widget that draws text.
 *
 * It is possible to change the displayed text without the cost of a full layout pass. See the PrefLineLength field and LayoutText method for details.
 *
 * The engine does not support scaling text, so the Scale and EffScale is ignored (except for the Insets).
 */
class GUIText : GUIWidget {
	String Text;
	Font TextFont;
	int TextColor;
	bool TextWrap;
	protected BrokenLines Lines;
	protected Array<double> LineOriginsX, LineOriginsY;
	
	/**
	 * The preferred line length for text positioning and wrapping, in characters. If this value is not zero or negative, the preferred width is PrefLineLength * 1ch, where 1ch is (like CSS) the width of the ‘0’ (digit zero) character in the font used by this widget.
	 *
	 * Alternatively, you can set the exact preferred pixel width for this widget, by writing it to the PrefWidthDirect field.
	 *
	 * If this and PrefWidthDirect are both zero or negative, the preferred width is the widths of all the characters in the text to draw. So, if PrefLineLength is not set, this widget will prefer drawing all of its text on one long line, even if TextWrap is true. You need to set one of these fields if you want wrapping.
	 *
	 * The other purpose of these fields is to allow a GUIText's text content to change rapidly, without incurring the cost of a full layout pass. This is useful for rapidly-changing text, like health/ammo/armor counters. For example, if you need to draw an actor's current health in 3 digits, set this to 3.
	 *
	 * You do still have to call LayoutText() after *every* change to the text. It's a lot cheaper than recomputing layout for the entire widget tree, though!
	 *
	 * As usual with preferred size, it's only a hint to layout code, not a hard demand. Layout code is free to adjust or ignore it. If this widget is laid out with a different width, and line wrapping is enabled, lines will be laid out appropriately for that width.
	 */
	int PrefLineLength;
	
	double PrefWidthDirect;
	
	override double PreferredWidth(double height = -1.) {
		double width;
		
		/*
		if (!TextWrap)
			width = TextFont.StringWidth(Text);
		else if (height > 0.) {
			// Use ‘0’ (the digit zero) as the average character width. This is how the CSS ‘ch’ unit is defined, and we need to know the width of about 1ch right now.
			let charWidth = TextFont.GetCharWidth(48);
			
			// This is a *very* rough guesstimate of how wide the text widget needs to be for a given height. It is probably nowhere near actually correct. Still, if we're asked to do this, that's the best we can offer.
			width = (Text.Length() * charWidth) / (height / double(TextFont.GetHeight()));
		}
		else*/
		if (PrefWidthDirect > 0.)
			width = PrefWidthDirect;
		else if (PrefLineLength > 0)
			width = PrefLineLength * TextFont.GetCharWidth(48);
		else if (Text)
			width = TextFont.StringWidth(Text);
		
		return width + Insets.X(EffXScale());
	}
	
	override double PreferredHeight(double width = -1.) {
		double height;
		
		// I would like to cache the result of BreakLines, in case Layout is called with exactly the same width, but ZScript has no weak map structure with which to do so.
		if (TextWrap && Text) {
			if (width <= 0.)
				width = PreferredWidth(-1);
			height = TextFont.BreakLines(Text, int(width)).Count() * TextFont.GetHeight();
		}
		else if (Text)
			height = TextFont.GetHeight();
		
		return height + Insets.Y(EffYScale());
	}
	
	override EResizeBias ResizeBias() {
		return TextWrap? RBIAS_HORIZONTAL : RBIAS_NONE;
	}
	
	/**
	 * Recomputes text wrapping and positioning. This is called by the Layout method, but must also be called after any change to the text.
	 *
	 * If you change the font, this will probably not suffice, as the total space allotted to this widget will be incorrect as well. You'll need to rerun layout for the entire widget tree. Call RequestLayout to do that.
	 */
	void LayoutText() {
		if (Text == "") {
			Lines = null;
			LineOriginsX.Clear();
			LineOriginsY.Clear();
		}
		else if (TextWrap) {
			Lines = TextFont.BreakLines(Text, int(Bounds.Size.X));
			let nLines = Lines.Count();
			LineOriginsX.Resize(nLines);
			LineOriginsY.Resize(nLines);
			let lineHeight = TextFont.GetHeight();
			
			Rectangle textBounds;
			textBounds.Size.Y = nLines * lineHeight;
			for (let i = 0; i < nLines; i++)
				textBounds.Size.X = max(textBounds.Size.X, Lines.StringWidth(i));
			textBounds.PositionIn(Bounds, Align.X, Align.Y);
			
			for (let i = 0; i < nLines; i++) {
				let text = Lines.StringAt(i);
				Rectangle lineRect;
				lineRect.Size.X = Lines.StringWidth(i);
				lineRect.Size.Y = lineHeight;
				lineRect.PositionIn(textBounds, Align.X, YALIGN_TOP);
				LineOriginsX[i] = lineRect.Origin.X;
				LineOriginsY[i] = lineRect.Origin.Y;
				textBounds.Origin.Y += lineHeight;
				textBounds.Size.Y -= lineHeight;
			}
			
			if (textBounds.Size.Y < 0.)
				Console.Printf(
					"\cr%s does not have enough room to draw its text. The available space is (%f,%f), but the text at this width is %d pixels high. Text will be drawn out of bounds!",
					ToString(),
					Bounds.Size.X, Bounds.Size.Y,
					nLines * lineHeight
				);
		}
		else {
			Lines = null;
			LineOriginsX.Resize(1);
			LineOriginsY.Resize(1);
			
			Rectangle lineRect;
			lineRect.Size = (
				TextFont.StringWidth(Text),
				TextFont.GetHeight()
			);
			lineRect.PositionIn(Bounds, Align.X, Align.Y);
			
			LineOriginsX[0] = lineRect.Origin.X;
			LineOriginsY[0] = lineRect.Origin.Y;
			
			if (lineRect.Size.X > Bounds.Size.X || lineRect.Size.Y > Bounds.Size.Y)
				Console.Printf(
					"\cr%s does not have enough room to draw its text. Line wrapping is disabled (the PrefLineLength field is zero or negative), and the required unwrapped space is (%f,%f), but the available space is (%f,%f). Text will be drawn out of bounds!",
					ToString(),
					Bounds.Size.X, Bounds.Size.Y,
					lineRect.Size.X, lineRect.Size.Y
				);
		}
	}
	
	override void Layout(Rectangle area) {
		// Unlike GUIWidget::Layout, this version doesn't shrink the bounds to fit the preferred size. Instead, the lines of text are aligned individually inside the bounds, so we need the bounds to be preserved.
		Bounds.Copy(area);
		Insets.Apply(Bounds, EffScale());
		LayoutText();
		LayoutDone();
	}
	
	override void Draw() {
		Super.Draw();
		let alpha = EffAlpha();
		
		for (let line = 0, nLines = LineOriginsX.Size(); line < nLines; line++) {
			Screen.DrawText(
				TextFont, TextColor,
				LineOriginsX[line], LineOriginsY[line],
				Lines != null? Lines.StringAt(line) : Text,
				DTA_Alpha, alpha
			);
		}
	}
	
	override String ToString() {
		let textBeginning = Text.Left(40);
		if (Text.Length() > textBeginning.Length())
			textBeginning = textBeginning.."...";
		
		return Super.ToString().." \""..textBeginning.."\"";
	}
}
