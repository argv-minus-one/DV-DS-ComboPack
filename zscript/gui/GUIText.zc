/**
 * A widget that draws text.
 *
 * The Layout method must be called whenever the text, font, wrap, or other layout-relevant settings are changed. However, you can avoid a full-tree layout pass by calling Layout on this widget directly, if the text content is likely to fit into the already-allocated area.
 *
 * To help with the aforementioned optimization (and with layout of text widgets in general), the preferred size of this widget can be influenced using the PrefLineLength and PrefWidthDirect fields. See the documentation of PrefLineLength for details.
 */
class GUIText : GUIWidget {
	String Text;
	Font TextFont;
	int TextColor;
	bool TextWrap;
	protected BrokenLines Lines;
	protected Array<double> LineOriginsX, LineOriginsY;
	
	/**
	 * The preferred line length for text positioning and wrapping, in characters. If this value is not zero or negative, the preferred width is PrefLineLength * 1ch, where 1ch is (like CSS) the width of the ‘0’ (digit zero) character in the font used by this widget.
	 *
	 * Alternatively, you can set the preferred pixel width for this widget, by writing it to the PrefWidthDirect field.
	 *
	 * If this and PrefWidthDirect are both zero or negative, the preferred width is the widths of all the characters in the text to draw. So, if PrefLineLength is not set, this widget will prefer drawing all of its text on one long line, even if TextWrap is true. You need to set one of these fields if you want wrapping.
	 *
	 * The other purpose of these fields is to allow a GUIText's text content to change rapidly, without incurring the cost of a full-tree layout pass. This is useful for rapidly-changing text, like health/ammo/armor counters. For example, if you need to draw an actor's current health in 3 digits, set this to 3.
	 *
	 * You do still have to call Layout() on this widget after *every* change to the text. Still, this is cheaper than a full-tree layout pass.
	 *
	 * As usual with preferred size, it's only a hint to layout code, not a hard demand. Layout code is free to adjust or ignore it. If this widget is laid out with a different width, and line wrapping is enabled, lines will be laid out appropriately for that width.
	 */
	int PrefLineLength;
	
	double PrefWidthDirect;
	
	override double PreferredWidth(double height = -1.) {
		double width;
		
		if (PrefWidthDirect > 0.)
			width = PrefWidthDirect;
		else if (PrefLineLength > 0)
			width = PrefLineLength * TextFont.GetCharWidth(48);
		else if (Text)
			width = TextFont.StringWidth(Text);
		
		return width + Insets.X(Scale.X);
	}
	
	override double PreferredHeight(double width = -1.) {
		double height;
		
		// I would like to cache the result of BreakLines, in case Layout is called with exactly the same width, but ZScript has no weak map structure with which to do so.
		if (TextWrap && Text) {
			if (width <= 0.)
				width = PreferredWidth(-1);
			height = TextFont.BreakLines(Text, int(width)).Count() * TextFont.GetHeight();
		}
		else if (Text)
			height = TextFont.GetHeight();
		
		return height + Insets.Y(Scale.Y);
	}
	
	override EResizeBias ResizeBias() {
		return TextWrap? RBIAS_HORIZONTAL : RBIAS_NONE;
	}
	
	override void Layout() {
		Super.Layout();
		
		if (Text == "") {
			Lines = null;
			LineOriginsX.Clear();
			LineOriginsY.Clear();
		}
		else if (TextWrap) {
			Rectangle ca;
			ca.Size = DC.Bounds;
			
			Lines = TextFont.BreakLines(Text, int(ca.Size.X));
			let nLines = Lines.Count();
			LineOriginsX.Resize(nLines);
			LineOriginsY.Resize(nLines);
			let lineHeight = TextFont.GetHeight();
			
			Rectangle textBounds;
			textBounds.Size.Y = nLines * lineHeight;
			for (let i = 0; i < nLines; i++)
				textBounds.Size.X = max(textBounds.Size.X, Lines.StringWidth(i));
			textBounds.PositionIn(ca, Align.X, Align.Y);
			
			for (let i = 0; i < nLines; i++) {
				let text = Lines.StringAt(i);
				Rectangle lineRect;
				lineRect.Size.X = Lines.StringWidth(i);
				lineRect.Size.Y = lineHeight;
				lineRect.PositionIn(textBounds, Align.X, YALIGN_TOP);
				LineOriginsX[i] = lineRect.Origin.X;
				LineOriginsY[i] = lineRect.Origin.Y;
				textBounds.Origin.Y += lineHeight;
				textBounds.Size.Y -= lineHeight;
			}
			
			if (textBounds.Size.Y < 0.)
				Console.Printf(
					"\cr%s does not have enough room to draw its text. The available space is (%f,%f), but the text at this width is %d pixels high. Text will be drawn out of bounds!",
					ToString(),
					ca.Size.X, ca.Size.Y,
					nLines * lineHeight
				);
		}
		else {
			Rectangle ca;
			ca.Size = DC.Bounds;
			
			Lines = null;
			LineOriginsX.Resize(1);
			LineOriginsY.Resize(1);
			
			Rectangle lineRect;
			lineRect.Size = (
				TextFont.StringWidth(Text),
				TextFont.GetHeight()
			);
			lineRect.PositionIn(ca, Align.X, Align.Y);
			
			LineOriginsX[0] = lineRect.Origin.X;
			LineOriginsY[0] = lineRect.Origin.Y;
			
			if (lineRect.Size.X > ca.Size.X || lineRect.Size.Y > ca.Size.Y)
				Console.Printf(
					"\cr%s does not have enough room to draw its text. Line wrapping is disabled (the PrefLineLength field is zero or negative), and the required unwrapped space is (%f,%f), but the available space is (%f,%f). Text will be drawn out of bounds!",
					ToString(),
					ca.Size.X, ca.Size.Y,
					lineRect.Size.X, lineRect.Size.Y
				);
		}
	}
	
	override void Draw() {
		Super.Draw();
		
		DC.TextFont = TextFont;
		DC.TextColor = TextColor;
		
		for (let line = 0, nLines = LineOriginsX.Size(); line < nLines; line++) {
			DC.DrawText(
				(LineOriginsX[line], LineOriginsY[line]),
				Lines != null? Lines.StringAt(line) : Text
			);
		}
	}
	
	override String ToString() {
		let textBeginning = Text.Left(40);
		if (Text.Length() > textBeginning.Length())
			textBeginning = textBeginning.."...";
		
		return Super.ToString().." \""..textBeginning.."\"";
	}
}
