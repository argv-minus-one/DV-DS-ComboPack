/**
 * An all-in-one meter widget that uses GUIColorRibbon for fill, GUIText for labeling, and arbitrary widgets drawn under/over the fill part.
 */
class GUIRibbonMeter : GUIWidget {
	DynamicValueInterpolator ValueInterp, MaxValueInterp;
	int Value, MaxValue;
	GUIText LabelText, NumberText;
	GUIColorRibbon MainFill, OverFill;
	bool DrawValue, DrawMaxValue;
	GUIInsets FillInsets;
	GUIWidget DrawUnder, DrawOver;
	
	/** If LengthScale is set to a positive value, then the length of the meter is MaxValue * LengthScale + LengthAdd, and the LengthBase field is the maximum length instead. */
	double LengthScale;
	double LengthBase;
	double LengthAdd;
	
	override void Init(GUIWidget parent = null) {
		Super.Init(parent);
		
		LabelText = new("GUIText");
		LabelText.ConsoleLabel = ConsoleLabel..".LabelText";
		LabelText.Init(self);
		LabelText.Align.X = XALIGN_LEFT;
		
		NumberText = new("GUIText");
		NumberText.ConsoleLabel = ConsoleLabel..".NumberText";
		NumberText.Init(self);
		NumberText.PrefLineLength = 7;
		
		MainFill = new("GUIColorRibbon");
		MainFill.ConsoleLabel = ConsoleLabel..".MainFill";
		MainFill.Init(self);
		
		OverFill = new("GUIColorRibbon");
		OverFill.ConsoleLabel = ConsoleLabel..".OverFill";
		OverFill.Init(self);
		
		DrawMaxValue = DrawValue = true;
		ValueInterp = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
		MaxValueInterp = DynamicValueInterpolator.Create(0, 0.15, 1, 6);
		LengthBase = 200;
	}
	
	void SetBackgroundTextureSet(String textureNamePrefix, int texUseType, bool preserveAspectRatio = true) {
		DrawUnder = new("GUIEdgeGroup");
		DrawUnder.ConsoleLabel = ConsoleLabel..".DrawUnder";
		DrawUnder.Init(self);
		GUIEdgeGroup(DrawUnder).UseTextureSet(textureNamePrefix, texUseType, preserveAspectRatio);
		RequestLayout();
	}
	
	void SetForegroundTextureSet(String textureNamePrefix, int texUseType, bool preserveAspectRatio = true) {
		DrawOver = new("GUIEdgeGroup");
		DrawOver.ConsoleLabel = ConsoleLabel..".DrawOver";
		DrawOver.Init(self);
		GUIEdgeGroup(DrawOver).UseTextureSet(textureNamePrefix, texUseType, preserveAspectRatio);
		RequestLayout();
	}
	
	void Tick() {
		ValueInterp.Update(Value);
		
		let oldMaxValueInterp = MaxValueInterp.GetValue();
		MaxValueInterp.Update(MaxValue);
		
		// If the whole meter needs to grow/shrink, then we need to recompute layout.
		if (oldMaxValueInterp != MaxValueInterp.GetValue() && LengthScale > 0.)
			RequestLayout();
	}
	
	override double PreferredWidth(double height = -1.) {
		return max(
			NumberText == null? 0. : NumberText.PreferredWidth(height),
			MainFill == null? 0. : MainFill.PreferredWidth(height),
			OverFill == null? 0. : OverFill.PreferredWidth(height),
			DrawUnder == null? 0. : DrawUnder.PreferredWidth(height),
			DrawOver == null? 0. : DrawOver.PreferredWidth(height)
		) + Insets.X(EffXScale());
	}
	
	override double PreferredHeight(double width = -1.) {
		return max(
			NumberText == null? 0. : NumberText.PreferredHeight(width),
			MainFill == null? 0. : MainFill.PreferredHeight(width),
			OverFill == null? 0. : OverFill.PreferredHeight(width),
			DrawUnder == null? 0. : DrawUnder.PreferredHeight(width),
			DrawOver == null? 0. : DrawOver.PreferredHeight(width)
		) + Insets.Y(EffYScale());
	}
	
	private void LayoutChild(GUIWidget widget, String widgetName) {
		if (widget != null) {
			widget.Layout(Bounds);
			
			if (zsgui_debug_ribbonmeter_layout)
				Console.Printf("%s placement: %s.", widgetName, widget.Bounds.ToString());
		}
		else
			Console.Printf("%s not present, so not laying out.", widgetName);
	}
	
	private void LayoutFillChild(GUIColorRibbon widget, String widgetName, double fillFraction, bool forceLayout) {
		if (widget != null) {
			let fillRemainingWidth = widget.Bounds.Size.X - FillInsets.X(widget.EffXScale());
			let prevInset = widget.Insets.Right;
			widget.Insets.Right = FillInsets.Right + (fillRemainingWidth * fillFraction);
			
			if (forceLayout || widget.Insets.Right != prevInset) {
				widget.Layout(Bounds);
				
				if (zsgui_debug_ribbonmeter_layout)
					Console.Printf("%s has been laid out with insets %s, and is now positioned at %s.", widgetName, widget.Insets.ToString(), widget.Bounds.ToString());
			}
		}
	}
	
	private double GetFillFraction(double adjust = 0.) {
		let vi = ValueInterp.GetValue(), mvi = MaxValueInterp.GetValue();
		double rf;
		
		if (mvi > 0)
			rf = double(vi) / double(mvi);
		else
			rf = 1;
		
		return clamp(rf + adjust, 0., 1.);
	}
	
	override void Layout(Rectangle area) {
		Super.Layout(area);
		
		if (zsgui_debug_ribbonmeter_layout)
			Console.Printf(">>> ZsGUI: Laying out %s into area %s.", ToString(), area.ToString());
		
		if (MainFill != null || OverFill != null) {
			double fl;
			if (LengthScale > 0.)
				fl = min(LengthBase, double(MaxValueInterp.GetValue()) * LengthScale + LengthAdd);
			else
				fl = LengthBase;
			if (MainFill != null) MainFill.PreferredLength = fl;
			if (OverFill != null) OverFill.PreferredLength = fl;
		}
		
		Super.Layout(area);
		
		if (zsgui_debug_ribbonmeter_layout)
			Console.Printf("Computed bounds: %s", Bounds.ToString());
		
		LayoutChild(NumberText, "NumberText");
		LayoutChild(LabelText, "LabelText");
		LayoutChild(DrawUnder, "DrawUnder");
		LayoutChild(DrawOver, "DrawOver");
		LayoutFillChild(MainFill, "MainFill", GetFillFraction(), true);
		LayoutFillChild(OverFill, "OverFill", GetFillFraction(-1), true);
		
		if (zsgui_debug_ribbonmeter_layout)
			Console.Printf("<<< ZsGUI: Laying out %s finished.", ToString());
	}
	
	override void Draw() {
		Super.Draw();
		
		if (DrawUnder != null) DrawUnder.Draw();
		
		if (MainFill != null) {
			LayoutFillChild(MainFill, "MainFill", GetFillFraction(), false);
			MainFill.Draw();
		}
		
		if (OverFill != null) {
			LayoutFillChild(OverFill, "OverFill", GetFillFraction(-1), false);
			OverFill.Draw();
		}
		
		if (DrawOver != null) DrawOver.Draw();
		if (LabelText != null) LabelText.Draw();
		
		if (NumberText != null && DrawValue) {
			if (DrawMaxValue)
				NumberText.Text = String.Format("%d/%d", ValueInterp.GetValue(), MaxValueInterp.GetValue());
			else
				NumberText.Text = String.Format("%d", ValueInterp.GetValue());
			
			NumberText.LayoutText();
			NumberText.Draw();
		}
	}
}
