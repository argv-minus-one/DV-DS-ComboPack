/**
 * A GUI widget that contains up to 9 other widgets, and draws them in a grid. The middle column and row will expand as needed to fill the draw area, while the other columns/rows will not expand.
 */
class GUIEdgeGroup : GUIWidget {
	/**
	 * The children of this widget. They are arranged into columns (the first array dimension), then rows (the second array dimension). For example, [2][3] is the bottom center child.
	 */
	GUIWidget Children[3][3];
	
	override double PreferredWidth(double height = -1.) {
		double width[3];
		for (let col = 0; col < 3; col++)
		for (let row = 0; row < 3; row++)
		if (Children[col][row] != null)
			width[col] = max(width[col], Children[col][row].PreferredWidth(height));
		return width[0] + width[1] + width[2];
	}
	
	override double PreferredHeight(double width = -1.) {
		double height[3];
		for (let col = 0; col < 3; col++)
		for (let row = 0; row < 3; row++)
		if (Children[col][row] != null)
			height[row] = max(height[row], Children[col][row].PreferredHeight(width));
		return height[0] + height[1] + height[2];
	}
	
	private void CheckBias(in out EResizeBias bias, int col, int row) {
		if (bias == RBIAS_NONE && Children[col][row] != null)
			bias = Children[col][row].ResizeBias();
	}
	
	override EResizeBias ResizeBias() {
		// Check the center cells.
		EResizeBias bias;
		CheckBias(bias, 1, 1);
		CheckBias(bias, 0, 1);
		CheckBias(bias, 2, 1);
		CheckBias(bias, 1, 0);
		CheckBias(bias, 1, 2);
		return bias;
	}
	
	override bool NeedsLayout() {
		if (Super.NeedsLayout())
			return true;
		
		for (let col = 0; col < 3; col++)
		for (let row = 0; row < 3; row++)
			if (Children[col][row] && Children[col][row].NeedsLayout())
				return true;
		
		return false;
	}
	
	override void Layout() {
		Super.Layout();
		
		Rectangle ca;
		GetContentArea(ca);
		
		if (zsgui_debug_edgegroup)
			Console.Printf(">>> ZsGUI: Laying out %s in area %s.", ToString(), ca.ToString());
		
		// Get the preferred sizes of the rows and columns.
		double colSizes[3], rowSizes[3];
		for (let col = 0; col < 3; col++)
		for (let row = 0; row < 3; row++) {
			let ps = Children[col][row] == null? (0, 0) : Children[col][row].PreferredSize(ca.Size);
			
			if (zsgui_debug_edgegroup && Children[col][row] != null)
				Console.Printf("Preferred size for child %s is %fx%f.", Children[col][row].ToString(), ps.X, ps.Y);
			
			colSizes[col] = max(0., colSizes[col], ps.X);
			rowSizes[row] = max(0., rowSizes[row], ps.Y);
		}
		
		if (zsgui_debug_edgegroup)
			Console.Printf(
				"Computed column sizes: %f, %f, %f.\nComputed row sizes: %f, %f, %f.",
				colSizes[0], colSizes[1], colSizes[2],
				rowSizes[0], rowSizes[1], rowSizes[2]
			);
		
		// Find the total preferred size in both dimensions.
		Vector2 totalPrefSize = (
			colSizes[0] + colSizes[1] + colSizes[2],
			rowSizes[0] + rowSizes[1] + rowSizes[2]
		);
		
		if (zsgui_debug_edgegroup)
			Console.Printf(
				"Total preferred size: %f,%f",
				totalPrefSize.X, totalPrefSize.Y
			);
		
		// Take the difference between the space we're given and the total space the children prefer.
		let diff = ca.Size - totalPrefSize;
		
		// Grow/shrink the columns/rows.
		if (diff.X > 0.)
			colSizes[1] += diff.X;
		else for (let col = 0; col < 3; col++)
			colSizes[col] += diff.X * (colSizes[col] / totalPrefSize.X);
		
		if (diff.Y > 0.)
			rowSizes[1] += diff.Y;
		else for (let row = 0; row < 3; row++)
			rowSizes[row] += diff.Y * (rowSizes[row] / totalPrefSize.Y);
		
		if (zsgui_debug_edgegroup)
			Console.Printf(
				"Adjusted column sizes: %f, %f, %f\nAdjusted row sizes: %f, %f, %f",
				colSizes[0], colSizes[1], colSizes[2],
				rowSizes[0], rowSizes[1], rowSizes[2]
			);
		
		// Size and position the children into their places on the grid.
		let colPos = ca.Origin.X;
		for (let col = 0; col < 3; col++) {
			let rowPos = ca.Origin.Y;
			
			for (let row = 0; row < 3; row++) {
				let child = Children[col][row];
				if (child != null) {
					child.Bounds.Origin = (colPos, rowPos);
					child.Bounds.Size = (colSizes[col], rowSizes[row]);
					child.Layout();
					
					if (zsgui_debug_edgegroup)
						Console.Printf(
							"Laid out child %s (column %d, row %d): %s",
							child.ToString(),
							col, row,
							child.Bounds.ToString()
						);
				}
				
				rowPos += rowSizes[row];
			}
			
			colPos += colSizes[col];
		}
		
		if (zsgui_debug_edgegroup)
			Console.Printf("<<< ZsGUI: Finished laying out %s.", ToString());
		// Done!
	}
	
	override void Draw() {
		Super.Draw();
		
		for (let col = 0; col < 3; col++)
		for (let row = 0; row < 3; row++)
		if (Children[col][row] != null)
			Children[col][row].Draw();
	}
	
	static const String TextureSetNameSuffixes[] = {
		"A", "B", "C", "D", "E", "F", "G", "H", "I"
	};
	
	void UseTextureSet(String textureNamePrefix, int texUseType = TexMan.Type_Any) {
		bool found = false;
		
		for (let col = 0; col < 3; col++)
		for (let row = 0; row < 3; row++) {
			let tex = TexMan.CheckForTexture(textureNamePrefix..TextureSetNameSuffixes[row * 3 + col], texUseType);
			if (tex.IsValid()) {
				found = true;
				let im = new("GUIImage");
				im.ConsoleLabel = String.Format("%s.%s", ConsoleLabel, TextureSetNameSuffixes[row * 3 + col]);
				im.Init(self);
				im.Image = tex;
				im.PreserveAspectRatio = false;
				Children[col][row] = im;
				
				switch (col) {
					case 0: im.Align.X = XALIGN_RIGHT; break;
					case 2: im.Align.X = XALIGN_LEFT; break;
					default: im.align.X = XALIGN_CENTER;
				}
				
				switch (row) {
					case 0: im.Align.Y = YALIGN_BOTTOM; break;
					case 2: im.Align.Y = YALIGN_TOP; break;
					default: im.Align.Y = YALIGN_CENTER;
				}
			}
			else
				Children[col][row] = null;
		}
		
		if (!found)
			Console.Printf("\crGUIEdgeGroup.UseTextureSet: No textures found with prefix %s!", textureNamePrefix);
	}
	
	void Clear() {
		for (let col = 0; col < 3; col++)
		for (let row = 0; row < 3; row++)
			Children[col][row] = null;
	}
}
