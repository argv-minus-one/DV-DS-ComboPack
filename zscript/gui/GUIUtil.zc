// An assortment of data structures related to HUD graphics.

struct GUIUtil {
	/** The machine epsilon for the “double” type.  */
	const Epsilon = 1.1102230246251565E-16;
	
	static bool IsAboutZero(double x) {
		return x < Epsilon && x > -Epsilon;
	}
	
	static bool IsAboutEqual(double a, double b) {
		let d = a - b;
		return d > -Epsilon && d < Epsilon;
	}
	
	static Color ApplyAlpha(Color c, double alpha) {
		let colorAlpha = double(c.A) / 255.;
		colorAlpha *= alpha;
		colorAlpha *= 255.;
		c &= 0xffffff;
		c |= int(colorAlpha) << 24;
		return c;
	}
	
	static Vector2 Vec2Min(Vector2 a, Vector2 b) {
		return (
			min(a.X, b.X),
			min(a.Y, b.Y)
		);
	}
	
	static Vector2 Vec2Max(Vector2 a, Vector2 b) {
		return (
			max(a.X, b.X),
			max(a.Y, b.Y)
		);
	}
	
	static Vector2 Vec2Mul(Vector2 a, Vector2 b) {
		return (a.X * b.X, a.Y * b.Y);
	}
	
	static int NearestPaletteColor(Color c) {
		// TODO: Need a better implementation here! This is a very crude way to match colors (although it works in the simplest cases).
		int paletteColorSoFar;
		Color nearestSoFar;
		int distanceSoFar = 1;
		
		for (let i = 0; distanceSoFar > 0 && i < 256; i++) {
			let pc = Screen.PaletteColor(i);
			
			int da[3];
			da[0] = abs(c.R - pc.R);
			da[1] = abs(c.G - pc.G);
			da[2] = abs(c.B - pc.B);
			let d = (da[0] + da[1] + da[2]) / 3;
			
			if (i == 0 || d < distanceSoFar) {
				paletteColorSoFar = i;
				nearestSoFar = pc;
				distanceSoFar = d;
			}
		}
		
		return paletteColorSoFar;
	}
}

enum GUIXAlignment {
	XALIGN_CENTER,
	XALIGN_LEFT,
	XALIGN_RIGHT
};

enum GUIYAlignment {
	YALIGN_CENTER,
	YALIGN_TOP,
	YALIGN_BOTTOM
};

struct GUIXYAlignment {
	GUIXAlignment X;
	GUIYAlignment Y;
}

struct Rectangle {
	Vector2 Origin;
	Vector2 Size;
	
	void Copy(Rectangle other) {
		Origin = other.Origin;
		Size = other.Size;
	}
	
	void Zero() {
		Origin = (0, 0);
		Size = (0, 0);
	}
	
	Vector2 ScaleForTexture(TextureID tex) {
		let texSize = TexMan.GetScaledSize(tex);
		return (Size.X / texSize.X, Size.Y / texSize.Y);
	}
	
	void PositionIn(Rectangle other, GUIXAlignment xalign, GUIYAlignment yalign) {
		Size.X = max(Size.X, 0.);
		Size.Y = max(Size.Y, 0.);
		other.Size.X = max(other.Size.X, 0.);
		other.Size.Y = max(other.Size.Y, 0.);
		
		switch (xalign) {
			case XALIGN_LEFT:
				Origin.X = other.Origin.X; break;
			
			case XALIGN_RIGHT:
				Origin.X = other.Origin.X + other.Size.X - Size.X; break;
			
			default:
				Origin.X = (other.Origin.X + other.Size.X / 2.) - (Size.X / 2.);
		}
		
		switch (yalign) {
			case YALIGN_TOP:
				Origin.Y = other.Origin.Y; break;
			
			case YALIGN_BOTTOM:
				Origin.Y = other.Origin.Y + other.Size.Y - Size.Y; break;
			
			default:
				Origin.Y = (other.Origin.Y + other.Size.Y / 2.) - (Size.Y / 2.);
		}
	}
	
	void PositionAbout(Vector2 point, GUIXAlignment xalign, GUIYAlignment yalign) {
		switch (xalign) {
			case XALIGN_LEFT:
				Origin.X = point.X; break;
			
			case XALIGN_RIGHT:
				Origin.X = point.X - Size.X; break;
			
			default:
				Origin.X = point.X - (Size.X / 2.);
		}
		
		switch (yalign) {
			case YALIGN_TOP:
				Origin.Y = point.Y; break;
			
			case YALIGN_BOTTOM:
				Origin.Y = point.Y - Size.Y; break;
			
			default:
				Origin.Y = point.Y - (Size.Y / 2.);
		}
	}
	
	String ToString() {
		return String.Format("%f,%f %fx%f", Origin.X, Origin.Y, Size.X, Size.Y);
	}
}

struct GUIInsets {
	double Top, Right, Bottom, Left;
	
	void Copy(GUIInsets other) {
		Top = other.Top;
		Right = other.Right;
		Bottom = other.Bottom;
		Left = other.Left;
	}
	
	void Set(double top, double right, double bottom, double left) {
		self.Top = top;
		self.Right = right;
		self.Bottom = bottom;
		self.Left = left;
	}
	
	void Apply(in out Rectangle rect, Vector2 scale = (1, 1), bool outward = false) {
		rect.Size = ApplySize(rect.Size, scale, outward);
		
		Vector2 originOffset = (
			Left * Scale.X,
			Top * Scale.Y
		);
		
		if (outward)
			rect.Origin -= originOffset;
		else
			rect.Origin += originOffset;
	}
	
	Vector2 ApplySize(Vector2 size, Vector2 scale = (1, 1), bool outward = false) {
		Vector2 totalInsets = (
			(Left + Right) * Scale.X,
			(Top + Bottom) * Scale.Y
		);
		
		if (outward)
			return size + totalInsets;
		else
			return size - totalInsets;
	}
	
	double X(double scale = 1) {
		return (Left + Right) * scale;
	}
	
	double Y(double scale = 1) {
		return (Top + Bottom) * scale;
	}
	
	String ToString() {
		return String.Format("t:%f,r:%f,b:%f,l:%f", Top, Right, Bottom, Left);
	}
}

struct PalettedColor {
	Color DTAColor;
	
	Color GetTrueColor() {
		return 0xFF000000 | DTAColor;
	}
	
	int GetPaletteColor() {
		return DTAColor.A;
	}
	
	void Set(Color trueColor, int paletteColor = -1) {
		DTAColor = trueColor;
		
		if (paletteColor > 0)
			DTAColor.A = paletteColor;
		else
			DTAColor.A = GUIUtil.NearestPaletteColor(trueColor);
	}
	
	void Copy(PalettedColor other) {
		DTAColor = other.DTAColor;
	}
}
