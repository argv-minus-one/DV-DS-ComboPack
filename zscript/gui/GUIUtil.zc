// An assortment of data structures related to HUD graphics.

const INT_MAX = 0x7fffffff;
const INT_MIN = -0x80000000;

/** The machine epsilon for the “double” type. */
const DOUBLE_EPSILON = 1.1102230246251565E-16;

struct GUIUtil {
	static bool IsAboutZero(double x) {
		return x < DOUBLE_EPSILON && x > -DOUBLE_EPSILON;
	}
	
	static bool IsAboutEqual(double a, double b) {
		let d = a - b;
		return d > -DOUBLE_EPSILON && d < DOUBLE_EPSILON;
	}
	
	static Color ApplyAlpha(Color c, double alpha) {
		let colorAlpha = double(c.A) / 255.;
		colorAlpha *= alpha;
		colorAlpha *= 255.;
		c &= 0xffffff;
		c |= int(colorAlpha) << 24;
		return c;
	}
	
	static Vector2 Vec2Min(Vector2 a, Vector2 b) {
		return (
			min(a.X, b.X),
			min(a.Y, b.Y)
		);
	}
	
	static Vector2 Vec2Max(Vector2 a, Vector2 b) {
		return (
			max(a.X, b.X),
			max(a.Y, b.Y)
		);
	}
	
	static Vector2 Vec2Mul(Vector2 a, Vector2 b) {
		return (a.X * b.X, a.Y * b.Y);
	}
	
	static Vector2 Vec2Div(Vector2 a, Vector2 b) {
		return (a.X / b.X, a.Y / b.Y);
	}
	
	static int NearestPaletteColor(Color c) {
		// Roughly the same algorithm as BestColor in v_palette.cpp.
		int paletteColorSoFar;
		Color nearestSoFar;
		int distanceSoFar = 1;
		
		for (let i = 0; distanceSoFar > 0 && i < 256; i++) {
			let pc = Screen.PaletteColor(i);
			
			int da[3];
			da[0] = c.R - pc.R;
			da[1] = c.G - pc.G;
			da[2] = c.B - pc.B;
			let d = da[0]*da[0] + da[1]*da[1] + da[2]*da[2];
			
			if (i == 0 || d < distanceSoFar) {
				paletteColorSoFar = i;
				nearestSoFar = pc;
				distanceSoFar = d;
			}
		}
		
		return paletteColorSoFar;
	}
	
	static Vector2 ScreenSizeVec() {
		return (
			Screen.GetWidth(),
			Screen.GetHeight()
		);
	}
}

enum GUIXAlignment {
	XALIGN_CENTER,
	XALIGN_LEFT,
	XALIGN_RIGHT
};

enum GUIYAlignment {
	YALIGN_CENTER,
	YALIGN_TOP,
	YALIGN_BOTTOM
};

struct GUIXYAlignment {
	GUIXAlignment X;
	GUIYAlignment Y;
	
	void Copy(GUIXYAlignment other) {
		X = other.X;
		Y = other.Y;
	}
}

struct Rectangle {
	Vector2 Origin;
	Vector2 Size;
	
	void Copy(Rectangle other) {
		Origin = other.Origin;
		Size = other.Size;
	}
	
	void Zero() {
		Origin = (0, 0);
		Size = (0, 0);
	}
	
	void ToInts(out RectangleInt other, bool roundInward = false) {
		other.Origin[0] = int(Origin.X + (roundInward? .5 : 0.));
		other.Origin[1] = int(Origin.Y + (roundInward? .5 : 0.));
		other.Size[0] = int(Size.X + (roundInward? 0. : .5));
		other.Size[1] = int(Size.Y + (roundInward? 0. : .5));
	}
	
	void FullScreen() {
		Origin = (0, 0);
		Size = (Screen.GetWidth(), Screen.GetHeight());
	}
	
	Vector2 ScaleForTexture(TextureID tex) {
		let texSize = TexMan.GetScaledSize(tex);
		return (Size.X / texSize.X, Size.Y / texSize.Y);
	}
	
	void PositionIn(Rectangle other, GUIXAlignment xalign, GUIYAlignment yalign) {
		Size.X = max(Size.X, 0.);
		Size.Y = max(Size.Y, 0.);
		other.Size.X = max(other.Size.X, 0.);
		other.Size.Y = max(other.Size.Y, 0.);
		
		switch (xalign) {
			case XALIGN_LEFT:
				Origin.X = other.Origin.X; break;
			
			case XALIGN_RIGHT:
				Origin.X = other.Origin.X + other.Size.X - Size.X; break;
			
			default:
				Origin.X = (other.Origin.X + other.Size.X / 2.) - (Size.X / 2.);
		}
		
		switch (yalign) {
			case YALIGN_TOP:
				Origin.Y = other.Origin.Y; break;
			
			case YALIGN_BOTTOM:
				Origin.Y = other.Origin.Y + other.Size.Y - Size.Y; break;
			
			default:
				Origin.Y = (other.Origin.Y + other.Size.Y / 2.) - (Size.Y / 2.);
		}
	}
	
	void PositionAbout(Vector2 point, GUIXAlignment xalign, GUIYAlignment yalign) {
		switch (xalign) {
			case XALIGN_LEFT:
				Origin.X = point.X; break;
			
			case XALIGN_RIGHT:
				Origin.X = point.X - Size.X; break;
			
			default:
				Origin.X = point.X - (Size.X / 2.);
		}
		
		switch (yalign) {
			case YALIGN_TOP:
				Origin.Y = point.Y; break;
			
			case YALIGN_BOTTOM:
				Origin.Y = point.Y - Size.Y; break;
			
			default:
				Origin.Y = point.Y - (Size.Y / 2.);
		}
	}
	
	double Top() { return Origin.Y; }
	double Left() { return Origin.X; }
	double Bottom() { return Origin.Y + Size.Y; }
	double Right() { return Origin.X + Size.X; }
	
	Vector2 BottomRight() {
		return (Origin.X + Size.X, Origin.Y + Size.Y);
	}
	
	void Intersect(Rectangle other) {
		Vector2 originDiff = (
			max(other.Origin.X - Origin.X, 0.),
			max(other.Origin.Y - Origin.Y, 0.)
		);
		
		let brDiff = BottomRight() - other.BottomRight();
		if (brDiff.X < 0.) brDiff.X = 0;
		if (brDiff.Y < 0.) brDiff.Y = 0;
		
		Origin += originDiff;
		Size -= originDiff + brDiff;
	}
	
	void IntersectInt(RectangleInt other) {
		Rectangle otherFloat;
		other.ToFloats(otherFloat);
		Intersect(otherFloat);
	}
	
	String ToString() {
		return String.Format("%f,%f %fx%f", Origin.X, Origin.Y, Size.X, Size.Y);
	}
}

struct RectangleInt {
	int Origin[2];
	int Size[2];
	
	void Copy(RectangleInt other) {
		Origin[0] = other.Origin[0];
		Origin[1] = other.Origin[1];
		Size[0] = other.Size[0];
		Size[1] = other.Size[1];
	}
	
	void Zero() {
		Origin[0] = Origin[1] = Size[0] = Size[1] = 0;
	}
	
	void ToFloats(out Rectangle other) {
		other.Origin = (Origin[0], Origin[1]);
		other.Size = (Size[0], Size[1]);
	}
	
	void FullScreen() {
		Origin[0] = Origin[1] = 0;
		Size[0] = Screen.GetWidth();
		Size[1] = Screen.GetHeight();
	}
	
	int Left() { return Origin[0]; }
	int Top() { return Origin[1]; }
	int Bottom() { return Origin[1] + Size[1]; }
	int Right() { return Origin[0] + Size[0]; }
	
	void Intersect(RectangleInt other) {
		int cornerDiffs[4];
		for (let i = 0; i < 2; i++)
			cornerDiffs[i] = max(Origin[i] - other.Origin[i], 0);
		cornerDiffs[2] = min(Right() - other.Right(), 0);
		cornerDiffs[3] = min(Bottom() - other.Bottom(), 0);
		
		for (let i = 0; i < 2; i++)
			Origin[i] += cornerDiffs[i];
		
		for (let i = 0; i < 2; i++)
			Size[i] -= cornerDiffs[i - 2] + cornerDiffs[i];
	}
	
	void IntersectFloat(Rectangle other, bool roundInward = false) {
		RectangleInt otherInt;
		other.ToInts(otherInt, roundInward);
		Intersect(otherInt);
	}
	
	String ToString() {
		return String.Format("%d,%d %dx%d", Origin[0], Origin[1], Size[0], Size[1]);
	}
}

struct GUIInsets {
	double Top, Right, Bottom, Left;
	
	void Copy(GUIInsets other) {
		Top = other.Top;
		Right = other.Right;
		Bottom = other.Bottom;
		Left = other.Left;
	}
	
	void Set(double top, double right, double bottom, double left) {
		self.Top = top;
		self.Right = right;
		self.Bottom = bottom;
		self.Left = left;
	}
	
	void Apply(in out Rectangle rect, Vector2 scale = (1, 1), bool outward = false) {
		rect.Size = ApplySize(rect.Size, scale, outward);
		
		Vector2 originOffset = (
			Left * Scale.X,
			Top * Scale.Y
		);
		
		if (outward)
			rect.Origin -= originOffset;
		else
			rect.Origin += originOffset;
	}
	
	Vector2 ApplySize(Vector2 size, Vector2 scale = (1, 1), bool outward = false) {
		Vector2 totalInsets = (
			(Left + Right) * Scale.X,
			(Top + Bottom) * Scale.Y
		);
		
		if (outward)
			return size + totalInsets;
		else
			return size - totalInsets;
	}
	
	double X(double scale = 1) {
		return (Left + Right) * scale;
	}
	
	double Y(double scale = 1) {
		return (Top + Bottom) * scale;
	}
	
	String ToString() {
		return String.Format("t:%f,r:%f,b:%f,l:%f", Top, Right, Bottom, Left);
	}
}

struct PalettedColor {
	Color DTAColor;
	
	Color GetTrueColor() {
		return 0xFF000000 | DTAColor;
	}
	
	int GetPaletteColor() {
		return DTAColor.A;
	}
	
	void Set(Color trueColor, int paletteColor = -1) {
		DTAColor = trueColor;
		
		if (paletteColor > 0)
			DTAColor.A = paletteColor;
		else
			DTAColor.A = GUIUtil.NearestPaletteColor(trueColor);
	}
	
	void Copy(PalettedColor other) {
		DTAColor = other.DTAColor;
	}
}
