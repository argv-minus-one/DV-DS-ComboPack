/**
 * A drawing context. Each DrawContext has its own coordinate system and draw settings, independent of any other DrawContext. It also provides a context-sensitive drawing API, which delegates to the drawing API of struct Screen.
 *
 * All fields of this struct are hidden, and may change in future versions (e.g. if a future version of ZScript provides support for matrix transformations). Instead, use the accessor and mutator methods to manipulate the context.
 */
struct DrawContext {
	private bool Initialized;
	String ConsoleLabel;
	private Vector2 ScaleXfrm;
	private double EffAlpha;
	Font TextFont;
	int TextColor;
	ERenderStyle RenderStyle;
	bool ClipToBounds;
	
	/**
	 * Bottom-right coordinates of the nominal draw area. Code should not draw except between (0,0) and Bounds.
	 *
	 * If ClipToBounds is true, draw calls will be clipped to within that area. Otherwise, drawing outside of that area is discouraged but permitted.
	 *
	 * The Initial method sets this to the size of the screen.
	 */
	Vector2 Bounds;
	
	/** Translation of this DC, in unscaled coordinates. */
	private Vector2 TranslateXfrm;
	
	bool AlphaMaskFill;
	PalettedColor AlphaMaskFillColor;
	
	bool IgnoreTextureMasks;
	
	/**
	 * Completely resets the state of this DrawContext. After that, calls to its draw methods will be equivalent to calling Screen methods directly.
	 *
	 * The ConsoleLabel is not reset.
	 */
	void Initial() {
		TranslateXfrm = (0, 0);
		Bounds = (Screen.GetWidth(), Screen.GetHeight());
		ScaleXfrm = (1, 1);
		EffAlpha = 1;
		TextFont = "SmallFont";
		TextColor = Font.CR_UNDEFINED;
		RenderStyle = STYLE_Normal;
		ClipToBounds = false;
		Initialized = true;
	}
	
	/**
	 * Copies the state of the given DrawContext into this one.
	 *
	 * The ConsoleLabel is not copied.
	 */
	void Copy(DrawContext other) {
		TranslateXfrm = other.TranslateXfrm;
		ScaleXfrm = other.ScaleXfrm;
		EffAlpha = other.EffAlpha;
		TextFont = other.TextFont;
		TextColor = other.TextColor;
		RenderStyle = other.RenderStyle;
		ClipToBounds = other.ClipToBounds;
		Bounds = other.Bounds;
		Initialized = true;
	}
	
	String ToString() {
		return String.Format("DrawContext %s (xlat X:%f Y:%f, scale X:%f Y:%f, bounds X:%f Y:%f)", ConsoleLabel, TranslateXfrm.X, TranslateXfrm.Y, ScaleXfrm.X, ScaleXfrm.Y, Bounds.X, Bounds.Y);
	}
	
	/**
	 * Translates the coordinate system of this DrawContext by the given vector.
	 *
	 * By default, the Bounds remain the same, effectively translating both the top-left and bottom-right corners of the drawing area. If translateBounds is set to false, the Bounds are instead adjusted so that the bottom-right corner stays where it is, and only the top-left corner moves.
	 *
	 * Note that, to prevent the Bounds from becoming negative, the bottom-right corner will still move if the top-left corner is moved past it in either dimension.
	 */
	void Translate(Vector2 v, bool translateBounds = true) {
		TranslateXfrm += GUIUtil.Vec2Mul(v, ScaleXfrm);
		
		if (!translateBounds)
			Bounds = (
				max(Bounds.X - v.X, 0.),
				max(Bounds.Y - v.Y, 0.)
			);
	}
	
	/**
	 * Scales the coordinate system of this DrawContext by the given vector.
	 *
	 * By default, the Bounds are also scaled, such that the on-screen area between (0,0) and Bounds (that is, the drawing area) is the same. If scaleBounds is set to false, the Bounds are left as they are, effectively scaling the size of the drawing area instead.
	 */
	void Scale(Vector2 v, bool scaleBounds = true) {
		if (v.X <= 0. || v.Y <= 0.) {
			if (zsgui_debug_drawcontext_abortonerror)
				Object.ThrowAbortException("%s: Call to Scale(%f,%f). Zero or negative scale factors are not allowed. \c-(To only log this condition without crashing, set the CVar \c+zsgui_debug_drawcontext_abortonerror\c- to \c+false\c-.)", ToString(), v.X, v.Y);
			else
				Console.Printf("%s: \crIgnoring call to Scale(%f,%f). Zero or negative scale factors are not allowed. \c-(To crash on this condition and get a ZScript stack trace, set the CVar \c+zsgui_debug_drawcontext_abortonerror\c- to \c+true\c-.)", ToString(), v.X, v.Y);
		}
		else {
			ScaleXfrm = GUIUtil.Vec2Mul(ScaleXfrm, v);
			
			if (scaleBounds)
				Bounds = GUIUtil.Vec2Div(Bounds, v);
		}
	}
	
	void Fade(double v) {
		EffAlpha *= clamp(v, 0., 1.);
	}
	
	double GetEffAlpha() {
		return EffAlpha;
	}
	
	Vector2 ToScreenPoint(Vector2 v) {
		return TranslateXfrm + GUIUtil.Vec2Mul(v, ScaleXfrm);
	}
	
	Vector2 ToScreenSize(Vector2 v) {
		return GUIUtil.Vec2Mul(v, ScaleXfrm);
	}
	
	Vector2 ToDCPoint(Vector2 v) {
		return GUIUtil.Vec2Div(v, ScaleXfrm) - TranslateXfrm;
	}
	
	Vector2 ToDCSize(Vector2 v) {
		return GUIUtil.Vec2Div(v, ScaleXfrm);
	}
	
	Color ApplyAlpha(Color c) {
		return Color(int(double(c.A) * EffAlpha), c.R, c.G, c.B);
	}
	
	void ToScreenRect(in out Rectangle rect) {
		rect.Origin = ToScreenPoint(rect.Origin);
		rect.Size = ToScreenSize(rect.Size);
	}
	
	void ToDCRect(in out Rectangle rect) {
		rect.Origin = ToDCPoint(rect.Origin);
		rect.Size = ToDCSize(rect.Size);
	}
	
	void Fill(Rectangle area, Color trueColor, int palColor = -1) {
		ToScreenRect(area);
		Screen.Clear(area.Origin.X, area.Origin.Y, area.Origin.X + area.Size.X, area.Origin.Y + area.Size.Y, ApplyAlpha(trueColor), palColor);
	}
	
	void Dim(Rectangle area, Color c, double amount) {
		ToScreenRect(area);
		Screen.Dim(c, amount * EffAlpha, area.Origin.X, area.Origin.Y, area.Size.X, area.Size.Y);
	}
	
	void DrawTexture(Rectangle area, TextureID tex, bool animate = false) {
		Rectangle texArea;
		texArea.Size = (INT_MAX, INT_MAX); // Oddly, that's what the engine uses, even though the coords are doubles.
		PalettedColor fillColor; // dummy
		
		DrawTexture_(area, tex, texArea, animate, false, fillColor);
	}
	
	void DrawTexturePiece(Rectangle area, TextureID tex, Rectangle texArea, bool animate = false) {
		PalettedColor fillColor; // dummy
		
		DrawTexture_(area, tex, texArea, animate, false, fillColor);
	}
	
	void DrawAlphaFill(Rectangle area, PalettedColor fillColor, TextureID mask, bool animate = false) {
		Rectangle texArea;
		texArea.Size = (INT_MAX, INT_MAX);
		
		DrawTexture_(area, mask, texArea, animate, true, fillColor);
	}
	
	void DrawAlphaFillPiece(Rectangle area, PalettedColor fillColor, TextureID mask, Rectangle maskArea, bool animate = false) {
		DrawTexture_(area, mask, maskArea, animate, true, fillColor);
	}
	
	private void DrawTexture_(Rectangle area, TextureID tex, Rectangle texArea, bool animate, bool alphaFill, PalettedColor fillColor) {
		ToScreenRect(area);
		
		Screen.DrawTexture(
			tex, animate,
			area.Origin.X, area.Origin.Y,
			DTA_DestWidthF, area.Size.X,
			DTA_DestHeightF, area.Size.Y,
			DTA_Alpha, EffAlpha,
			DTA_ClipTop, ClipToBounds? int(area.Origin.Y) : 0,
			DTA_ClipBottom, ClipToBounds? int((area.Origin.Y + area.Size.Y) + .5) : Screen.GetHeight(),
			DTA_ClipLeft, ClipToBounds? int(area.Origin.X) : 0,
			DTA_ClipRight, ClipToBounds? int((area.Origin.X + area.Size.X) + .5) : Screen.GetWidth(),
			DTA_Masked, !IgnoreTextureMasks,
			DTA_RenderStyle, RenderStyle,
			DTA_WindowLeft, texArea.Origin.X,
			DTA_WindowRight, texArea.Origin.X + texArea.Size.X,
			DTA_AlphaChannel, alphaFill,
			DTA_FillColor, fillColor.DTAColor
		);
	}
	
	void DrawFrame(Rectangle area) {
		ToScreenRect(area);
		Screen.DrawFrame(int(area.Origin.X), int(area.Origin.Y), int(area.Size.X + .5), int(area.Size.Y + .5));
	}
	
	void DrawChar(Vector2 origin, int character, int charCellWidth = 0, int charCellHeight = 0) {
		origin = ToScreenPoint(origin);
		Vector2 size;
		if (ClipToBounds) size = ToScreenSize(Bounds);
		
		let charCell = ToScreenSize((charCellWidth, charCellHeight));
		charCellWidth = int(charCell.X + .5);
		charCellHeight = int(charCell.Y + .5);
		
		Screen.DrawChar(
			TextFont, TextColor,
			origin.X, origin.Y,
			character,
			DTA_CellX, charCellWidth,
			DTA_CellY, charCellHeight,
			DTA_Alpha, EffAlpha,
			DTA_ClipTop, ClipToBounds? int(origin.Y) : 0,
			DTA_ClipBottom, ClipToBounds? int((origin.Y + size.Y) + .5) : INT_MAX,
			DTA_ClipLeft, ClipToBounds? int(origin.X) : 0,
			DTA_ClipRight, ClipToBounds? int((origin.X + size.X) + .5) : INT_MAX,
			DTA_RenderStyle, RenderStyle
		);
	}
	
	void DrawText(Vector2 origin, String text, int charCellWidth = 0, int charCellHeight = 0) {
		origin = ToScreenPoint(origin);
		Vector2 size;
		if (ClipToBounds) size = ToScreenSize(Bounds);
		
		let charCell = ToScreenSize((charCellWidth, charCellHeight));
		charCellWidth = int(charCell.X + .5);
		charCellHeight = int(charCell.Y + .5);
		
		Screen.DrawText(
			TextFont, TextColor,
			origin.X, origin.Y,
			text,
			DTA_CellX, charCellWidth,
			DTA_CellY, charCellHeight,
			DTA_Alpha, EffAlpha,
			DTA_ClipTop, ClipToBounds? int(origin.Y) : 0,
			DTA_ClipBottom, ClipToBounds? int((origin.Y + size.Y) + .5) : INT_MAX,
			DTA_ClipLeft, ClipToBounds? int(origin.X) : 0,
			DTA_ClipRight, ClipToBounds? int((origin.X + size.X) + .5) : INT_MAX,
			DTA_RenderStyle, RenderStyle
		);
	}
}
