/**
 * A drawing context. Each DrawContext has its own coordinate system and draw settings, independent of any other DrawContext. It also provides a context-sensitive drawing API, which delegates to the drawing API of struct Screen.
 *
 * All fields of this struct are hidden, and may change in future versions (e.g. if a future version of ZScript provides support for matrix transformations). Instead, use the accessor and mutator methods to manipulate the context.
 */
struct DrawContext {
	private bool Initialized;
	String ConsoleLabel;
	private Vector2 ScaleXfrm;
	private double EffAlpha;
	Font TextFont;
	int TextColor;
	ERenderStyle RenderStyle;
	bool UseClipArea;
	Rectangle ClipArea;
	
	/** Translation of this DC, in unscaled coordinates. */
	private Vector2 TranslateXfrm;
	
	bool AlphaMaskFill;
	PalettedColor AlphaMaskFillColor;
	
	bool IgnoreTextureMasks;
	
	/**
	 * Completely resets the state of this DrawContext. After that, calls to its draw methods will be equivalent to calling Screen methods directly.
	 *
	 * The ConsoleLabel is not reset.
	 */
	void Initial() {
		TranslateXfrm = (0, 0);
		ScaleXfrm = (1, 1);
		EffAlpha = 1;
		TextFont = "SmallFont";
		TextColor = Font.CR_UNDEFINED;
		RenderStyle = STYLE_Normal;
		UseClipArea = false;
		ClipArea.Zero();
		Initialized = true;
	}
	
	/**
	 * Copies the state of the given DrawContext into this one.
	 *
	 * The ConsoleLabel is not copied.
	 */
	void Copy(DrawContext other) {
		TranslateXfrm = other.TranslateXfrm;
		ScaleXfrm = other.ScaleXfrm;
		EffAlpha = other.EffAlpha;
		TextFont = other.TextFont;
		TextColor = other.TextColor;
		RenderStyle = other.RenderStyle;
		UseClipArea = false;
		ClipArea.Copy(other.ClipArea);
		Initialized = true;
	}
	
	String ToString() {
		return String.Format("DrawContext %s (xlta X:%f Y:%f, scale X:%f Y:%f)", ConsoleLabel, TranslateXfrm.X, TranslateXfrm.Y, ScaleXfrm.X, ScaleXfrm.Y);
	}
	
	/**
	 * Translates the coordinate system of this DrawContext by the given vector.
	 *
	 * By default, the ClipArea is adjusted such that it covers the same area in the new coordinate system as it did in the previous one. If the preserveClip parameter is set to true, however, the ClipArea keeps the same coordinates, effectively translating it too.
	 */
	void Translate(Vector2 v, bool preserveClip = false) {
		let vs = GUIUtil.Vec2Mul(v, ScaleXfrm);
		
		TranslateXfrm += vs;
		
		if (!preserveClip)
			ClipArea.Origin -= vs;
	}
	
	/**
	 * Scales the coordinate system of this DrawContext by the given vector.
	 *
	 * By default, the ClipArea is adjusted such that it covers the same area in the new coordinate system as it did in the previous one. If the preserveClip parameter is set to true, however, the ClipArea keeps the same coordinates, effectively scaling it too.
	 */
	void Scale(Vector2 v, bool preserveClip = false) {
		if (v.X <= 0. || v.Y <= 0.) {
			if (zsgui_debug_drawcontext_abortonerror)
				Object.ThrowAbortException("%s: Call to Scale(%f,%f). Zero or negative scale factors are not allowed. \c-(To only log this condition without crashing, set the CVar \c+zsgui_debug_drawcontext_abortonerror\c- to \c+false\c-.)", ToString(), v.X, v.Y);
			else
				Console.Printf("%s: \crIgnoring call to Scale(%f,%f). Zero or negative scale factors are not allowed. \c-(To crash on this condition and get a ZScript stack trace, set the CVar \c+zsgui_debug_drawcontext_abortonerror\c- to \c+true\c-.)", ToString(), v.X, v.Y);
		}
		else {
			ScaleXfrm = GUIUtil.Vec2Mul(ScaleXfrm, v);
			
			if (!preserveClip) {
				ClipArea.Origin = GUIUtil.Vec2Div(ClipArea.Origin, v);
				ClipArea.Size = GUIUtil.Vec2Div(ClipArea.Size, v);
			}
		}
	}
	
	void Fade(double v) {
		EffAlpha *= clamp(v, 0., 1.);
	}
	
	double GetEffAlpha() {
		return EffAlpha;
	}
	
	Vector2 ToScreenPoint(Vector2 v) {
		return TranslateXfrm + GUIUtil.Vec2Mul(v, ScaleXfrm);
	}
	
	Vector2 ToScreenSize(Vector2 v) {
		return GUIUtil.Vec2Mul(v, ScaleXfrm);
	}
	
	Vector2 ToDCPoint(Vector2 v) {
		return GUIUtil.Vec2Div(v, ScaleXfrm) - TranslateXfrm;
	}
	
	Vector2 ToDCSize(Vector2 v) {
		return GUIUtil.Vec2Div(v, ScaleXfrm);
	}
	
	Color ApplyAlpha(Color c) {
		return Color(int(double(c.A) * EffAlpha), c.R, c.G, c.B);
	}
	
	void ToScreenRect(in out Rectangle rect) {
		rect.Origin = ToScreenPoint(rect.Origin);
		rect.Size = ToScreenSize(rect.Size);
	}
	
	void ToDCRect(in out Rectangle rect) {
		rect.Origin = ToDCPoint(rect.Origin);
		rect.Size = ToDCSize(rect.Size);
	}
	
	void Fill(Rectangle area, Color trueColor, int palColor = -1) {
		ToScreenRect(area);
		Screen.Clear(area.Origin.X, area.Origin.Y, area.Origin.X + area.Size.X, area.Origin.Y + area.Size.Y, ApplyAlpha(trueColor), palColor);
	}
	
	void Dim(Rectangle area, Color c, double amount) {
		ToScreenRect(area);
		Screen.Dim(c, amount * EffAlpha, area.Origin.X, area.Origin.Y, area.Size.X, area.Size.Y);
	}
	
	private void ToScreenClip(in out Rectangle cla) {
		if (UseClipArea) {
			cla.Copy(ClipArea);
			ToScreenRect(cla);
		}
	}
	
	void DrawTexture(Rectangle area, TextureID tex, bool animate = false) {
		Rectangle texArea;
		texArea.Size = (INT_MAX, INT_MAX); // Oddly, that's what the engine uses, even though the coords are doubles.
		PalettedColor fillColor; // dummy
		
		DrawTexture_(area, tex, texArea, animate, false, fillColor);
	}
	
	void DrawTexturePiece(Rectangle area, TextureID tex, Rectangle texArea, bool animate = false) {
		PalettedColor fillColor; // dummy
		
		DrawTexture_(area, tex, texArea, animate, false, fillColor);
	}
	
	void DrawAlphaFill(Rectangle area, PalettedColor fillColor, TextureID mask, bool animate = false) {
		Rectangle texArea;
		texArea.Size = (INT_MAX, INT_MAX);
		
		DrawTexture_(area, mask, texArea, animate, true, fillColor);
	}
	
	void DrawAlphaFillPiece(Rectangle area, PalettedColor fillColor, TextureID mask, Rectangle maskArea, bool animate = false) {
		DrawTexture_(area, mask, maskArea, animate, true, fillColor);
	}
	
	private void DrawTexture_(Rectangle area, TextureID tex, Rectangle texArea, bool animate, bool alphaFill, PalettedColor fillColor) {
		ToScreenRect(area);
		Rectangle cla; ToScreenClip(cla);
		
		Screen.DrawTexture(
			tex, animate,
			area.Origin.X, area.Origin.Y,
			DTA_DestWidthF, area.Size.X,
			DTA_DestHeightF, area.Size.Y,
			DTA_Alpha, EffAlpha,
			DTA_ClipTop, UseClipArea? int(cla.Origin.Y) : 0,
			DTA_ClipBottom, UseClipArea? int((cla.Origin.Y + cla.Size.Y) + .5) : Screen.GetHeight(),
			DTA_ClipLeft, UseClipArea? int(cla.Origin.X) : 0,
			DTA_ClipRight, UseClipArea? int((cla.Origin.X + cla.Size.X) + .5) : Screen.GetWidth(),
			DTA_Masked, !IgnoreTextureMasks,
			DTA_RenderStyle, RenderStyle,
			DTA_WindowLeft, texArea.Origin.X,
			DTA_WindowRight, texArea.Origin.X + texArea.Size.X,
			DTA_AlphaChannel, alphaFill,
			DTA_FillColor, fillColor.DTAColor
		);
	}
	
	void DrawFrame(Rectangle area) {
		ToScreenRect(area);
		Screen.DrawFrame(int(area.Origin.X), int(area.Origin.Y), int(area.Size.X + .5), int(area.Size.Y + .5));
	}
	
	void DrawChar(Vector2 origin, int character, int charCellWidth = 0, int charCellHeight = 0) {
		origin = ToScreenPoint(origin);
		Rectangle cla; ToScreenClip(cla);
		
		let charCell = ToScreenPoint((charCellWidth, charCellHeight));
		charCellWidth = int(charCell.X + .5);
		charCellHeight = int(charCell.Y + .5);
		
		Screen.DrawChar(
			TextFont, TextColor,
			origin.X, origin.Y,
			character,
			DTA_CellX, charCellWidth,
			DTA_CellY, charCellHeight,
			DTA_Alpha, EffAlpha,
			DTA_ClipTop, UseClipArea? int(cla.Origin.Y) : 0,
			DTA_ClipBottom, UseClipArea? int((cla.Origin.Y + cla.Size.Y) + .5) : Screen.GetHeight(),
			DTA_ClipLeft, UseClipArea? int(cla.Origin.X) : 0,
			DTA_ClipRight, UseClipArea? int((cla.Origin.X + cla.Size.X) + .5) : Screen.GetWidth(),
			DTA_RenderStyle, RenderStyle
		);
	}
	
	void DrawText(Vector2 origin, String text, int charCellWidth = 0, int charCellHeight = 0) {
		origin = ToScreenPoint(origin);
		Rectangle cla; ToScreenClip(cla);
		
		let charCell = ToScreenPoint((charCellWidth, charCellHeight));
		charCellWidth = int(charCell.X + .5);
		charCellHeight = int(charCell.Y + .5);
		
		Screen.DrawText(
			TextFont, TextColor,
			origin.X, origin.Y,
			text,
			DTA_CellX, charCellWidth,
			DTA_CellY, charCellHeight,
			DTA_Alpha, EffAlpha,
			DTA_ClipTop, UseClipArea? int(cla.Origin.Y) : 0,
			DTA_ClipBottom, UseClipArea? int((cla.Origin.Y + cla.Size.Y) + .5) : Screen.GetHeight(),
			DTA_ClipLeft, UseClipArea? int(cla.Origin.X) : 0,
			DTA_ClipRight, UseClipArea? int((cla.Origin.X + cla.Size.X) + .5) : Screen.GetWidth(),
			DTA_RenderStyle, RenderStyle
		);
	}
}
