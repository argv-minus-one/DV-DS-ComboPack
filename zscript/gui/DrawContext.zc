/**
 * A drawing context. Each DrawContext has its own coordinate system and draw settings, independent of any other DrawContext. It also provides a context-sensitive drawing API, which delegates to the drawing API of struct Screen.
 *
 * All fields of this struct are hidden, and may change in future versions (e.g. if a future version of ZScript provides support for matrix transformations). Instead, use the accessor and mutator methods to manipulate the context.
 */
struct DrawContext {
	private bool Initialized;
	String ConsoleLabel;
	private Vector2 ScaleXfrm;
	private double EffAlpha;
	Font TextFont;
	int TextColor;
	bool ClipToBounds;
	
	/**
	 * Bottom-right coordinates of the nominal draw area. Code should not draw except between (0,0) and Bounds.
	 *
	 * If ClipToBounds is true, draw calls will be clipped to within that area. Otherwise, drawing outside of that area is discouraged but permitted.
	 */
	Vector2 Bounds;
	
	/** Translation of this DC, in unscaled coordinates. */
	private Vector2 TranslateXfrm;
	
	bool AlphaMaskFill;
	PalettedColor AlphaMaskFillColor;
	
	bool IgnoreTextureMasks;
	
	/**
	 * Completely resets the state of this DrawContext. After that, calls to its draw methods will be equivalent to calling Screen methods directly.
	 *
	 * The ConsoleLabel is not reset.
	 */
	void Initial() {
		TranslateXfrm = (0, 0);
		ScaleXfrm = (1, 1);
		EffAlpha = 1;
		TextFont = "SmallFont";
		TextColor = Font.CR_UNDEFINED;
		ClipToBounds = false;
		Initialized = true;
	}
	
	/**
	 * Copies the state of the given DrawContext into this one.
	 *
	 * The ConsoleLabel is not copied.
	 */
	void Copy(DrawContext other) {
		TranslateXfrm = other.TranslateXfrm;
		ScaleXfrm = other.ScaleXfrm;
		EffAlpha = other.EffAlpha;
		TextFont = other.TextFont;
		TextColor = other.TextColor;
		ClipToBounds = other.ClipToBounds;
		Bounds = other.Bounds;
		Initialized = true;
	}
	
	String ToString(bool fieldsOnly = false) {
		let result = String.Format(
			"xlat=(%f,%f) scale=(%f,%f) bounds=(%f,%f%s) alpha=%f",
			TranslateXfrm.X, TranslateXfrm.Y,
			ScaleXfrm.X, ScaleXfrm.Y,
			Bounds.X, Bounds.Y,
			ClipToBounds? " clipping" : "",
			EffAlpha
		);
		
		if (!fieldsOnly)
			result = String.Format("DrawContext %s (%s)", ConsoleLabel, result);
		
		return result;
	}
	
	/**
	 * Translates the coordinate system of this DrawContext by the given vector.
	 *
	 * By default, the Bounds remain the same, effectively translating both the top-left and bottom-right corners of the drawing area. If translateBounds is set to false, the Bounds are instead adjusted so that the bottom-right corner stays where it is, and only the top-left corner moves.
	 *
	 * Note that, to prevent the Bounds from becoming negative, the bottom-right corner will still move if the top-left corner is moved past it in either dimension.
	 */
	void Translate(Vector2 v, bool translateBounds = true) {
		TranslateXfrm += GUIUtil.Vec2Mul(v, ScaleXfrm);
		
		if (!translateBounds)
			Bounds = (
				max(Bounds.X - v.X, 0.),
				max(Bounds.Y - v.Y, 0.)
			);
	}
	
	/**
	 * Scales the coordinate system of this DrawContext by the given vector.
	 *
	 * By default, the Bounds are also scaled, such that the on-screen area between (0,0) and Bounds (that is, the drawing area) is the same. If scaleBounds is set to false, the Bounds are left as they are, effectively scaling the size of the drawing area instead.
	 */
	void Scale(Vector2 v, bool scaleBounds = true) {
		if (v.X <= 0. || v.Y <= 0.) {
			if (zsgui_debug_drawcontext_abortonerror)
				Object.ThrowAbortException("%s: Call to Scale(%f,%f). Zero or negative scale factors are not allowed. \c-(To only log this condition without crashing, set the CVar \c+zsgui_debug_drawcontext_abortonerror\c- to \c+false\c-.)", ToString(), v.X, v.Y);
			else
				Console.Printf("%s: \crIgnoring call to Scale(%f,%f). Zero or negative scale factors are not allowed. \c-(To crash on this condition and get a ZScript stack trace, set the CVar \c+zsgui_debug_drawcontext_abortonerror\c- to \c+true\c-.)", ToString(), v.X, v.Y);
		}
		else {
			ScaleXfrm = GUIUtil.Vec2Mul(ScaleXfrm, v);
			
			if (scaleBounds)
				Bounds = GUIUtil.Vec2Div(Bounds, v);
		}
	}
	
	void ShrinkDrawArea(double top, double right, double bottom, double left) {
		Translate((left, top));
		Bounds = (
			max(Bounds.X - right - left, 0.),
			max(Bounds.Y - bottom - top, 0.)
		);
	}
	
	void GrowDrawArea(double top, double right, double bottom, double left) {
		ShrinkDrawArea(-top, -right, -bottom, -left);
	}
	
	void ApplyInsets(GUIInsets insets) {
		ShrinkDrawArea(insets.Top, insets.Right, insets.Bottom, insets.Left);
	}
	
	void UnapplyInsets(GUIInsets insets) {
		GrowDrawArea(insets.Top, insets.Right, insets.Bottom, insets.Left);
	}
	
	void Fade(double v) {
		EffAlpha *= clamp(v, 0., 1.);
	}
	
	double GetEffAlpha() {
		return EffAlpha;
	}
	
	Vector2 ToScreenPoint(Vector2 v) {
		return TranslateXfrm + GUIUtil.Vec2Mul(v, ScaleXfrm);
	}
	
	Vector2 ToScreenSize(Vector2 v) {
		return GUIUtil.Vec2Mul(v, ScaleXfrm);
	}
	
	Vector2 ToDCPoint(Vector2 v) {
		return GUIUtil.Vec2Div(v, ScaleXfrm) - TranslateXfrm;
	}
	
	Vector2 ToDCSize(Vector2 v) {
		return GUIUtil.Vec2Div(v, ScaleXfrm);
	}
	
	Color ApplyAlpha(Color c) {
		return Color(int(double(c.A) * EffAlpha), c.R, c.G, c.B);
	}
	
	void ToScreenRect(in out Rectangle rect) {
		rect.Origin = ToScreenPoint(rect.Origin);
		rect.Size = ToScreenSize(rect.Size);
	}
	
	void ToDCRect(in out Rectangle rect) {
		rect.Origin = ToDCPoint(rect.Origin);
		rect.Size = ToDCSize(rect.Size);
	}
	
	void GetScreenDrawArea(out Rectangle rect) {
		rect.Origin = (0, 0);
		rect.Size = Bounds;
		ToScreenRect(rect);
	}
	
	void GetScreenDrawAreaInt(out RectangleInt rect, bool roundInward = false) {
		Rectangle rectFloat;
		GetScreenDrawArea(rectFloat);
		rectFloat.ToInts(rect, roundInward);
	}
	
	void ApplyClip(in out Rectangle screenRect) {
		if (ClipToBounds) {
			Rectangle clip;
			GetScreenDrawArea(clip);
			screenRect.Intersect(clip);
		}
	}
	
	void GetClipInt(out RectangleInt rect, bool roundInward = false) {
		if (ClipToBounds)
			GetScreenDrawAreaInt(rect, roundInward);
		else
			rect.FullScreen();
	}
	
	void Fill(Rectangle area, Color trueColor, int palColor = -1) {
		Rectangle screenArea;
		screenArea.Copy(area);
		ToScreenRect(screenArea);
		ApplyClip(screenArea);
		
		let alphaColor = ApplyAlpha(trueColor);
		
		if (zsgui_debug_draw_fill)
			Console.Printf(
				"%s: Filling area %s with color ARGB=%d,%d,%d,%d palette=%d.",
				ToString(),
				screenArea.ToString(),
				alphaColor.A, alphaColor.R, alphaColor.G, alphaColor.B,
				palColor
			);
		
		Screen.Clear(screenArea.Origin.X, screenArea.Origin.Y, screenArea.Origin.X + screenArea.Size.X, screenArea.Origin.Y + screenArea.Size.Y, alphaColor, palColor);
	}
	
	void Dim(Rectangle area, Color c, double amount) {
		Rectangle screenArea;
		screenArea.Copy(area);
		ToScreenRect(screenArea);
		ApplyClip(screenArea);
		
		let effAmount = amount * EffAlpha;
		
		if (zsgui_debug_draw_fill)
			Console.Printf(
				"%s: Dimming area %s with color RGB=%d,%d,%d amount=%f.",
				ToString(),
				screenArea.ToString(),
				c.R, c.G, c.B,
				effAmount
			);
		
		Screen.Dim(c, amount, screenArea.Origin.X, screenArea.Origin.Y, screenArea.Size.X, screenArea.Size.Y);
	}
	
	void DrawTexture(Rectangle area, TextureID tex, bool animate = false) {
		Rectangle texArea;
		texArea.Size = (INT_MAX, INT_MAX); // Oddly, that's what the engine uses, even though the coords are doubles.
		PalettedColor fillColor; // dummy
		
		DrawTexture_(area, tex, texArea, animate, false, fillColor);
	}
	
	void DrawTexturePiece(Rectangle area, TextureID tex, Rectangle texArea, bool animate = false) {
		PalettedColor fillColor; // dummy
		
		DrawTexture_(area, tex, texArea, animate, false, fillColor);
	}
	
	void DrawAlphaFill(Rectangle area, PalettedColor fillColor, TextureID mask, bool animate = false) {
		Rectangle texArea;
		texArea.Size = (INT_MAX, INT_MAX);
		
		DrawTexture_(area, mask, texArea, animate, true, fillColor);
	}
	
	void DrawAlphaFillPiece(Rectangle area, PalettedColor fillColor, TextureID mask, Rectangle maskArea, bool animate = false) {
		DrawTexture_(area, mask, maskArea, animate, true, fillColor);
	}
	
	private void DrawTexture_(Rectangle area, TextureID tex, Rectangle texArea, bool animate, bool alphaFill, PalettedColor fillColor) {
		Rectangle screenArea;
		screenArea.Copy(area);
		ToScreenRect(screenArea);
		
		RectangleInt clip;
		GetClipInt(clip);
		
		if (zsgui_debug_draw_texture) {
			String msg = String.Format(
				"%s:\n\tDrawing texture %d to area %s.\n\tClip top=%d right=%d bottom=%d left=%d\n\tAlpha: %f\n\tTexture window (columns): %f,%f",
				ToString(),
				tex,
				screenArea.ToString(),
				clip.Top(), clip.Right(), clip.Bottom(), clip.Left(),
				EffAlpha,
				texArea.Left(), texArea.Right()
			);
			
			if (alphaFill) {
				let f = fillColor.DTAColor;
				msg = String.Format(
					"%s\n\tAlpha fill: RGB:%d,%d,%d palette:%d",
					msg,
					f.R, f.G, f.B, f.A
				);
			}
			
			if (IgnoreTextureMasks)
				msg = msg.."\n\tIgnoring texture mask";
			
			if (animate)
				msg = msg.."\n\tAnimated";
			
			Console.Printf("%s", msg);
		}
		
		Screen.DrawTexture(
			tex, animate,
			screenArea.Origin.X, screenArea.Origin.Y,
			DTA_DestWidthF, screenArea.Size.X,
			DTA_DestHeightF, screenArea.Size.Y,
			DTA_Alpha, EffAlpha,
			DTA_ClipTop, clip.Top(),
			DTA_ClipBottom, clip.Bottom(),
			DTA_ClipLeft, clip.Left(),
			DTA_ClipRight, clip.Right(),
			DTA_Masked, !IgnoreTextureMasks,
			DTA_WindowLeftF, texArea.Left(),
			DTA_WindowRightF, texArea.Right(),
			DTA_AlphaChannel, alphaFill,
			DTA_FillColor, fillColor.DTAColor
		);
	}
	
	void DrawFrame(Rectangle area) {
		Rectangle screenArea;
		screenArea.Copy(area);
		ToScreenRect(screenArea);
		ApplyClip(screenArea);
		
		RectangleInt screenAreaInt;
		screenArea.ToInts(screenAreaInt);
		
		if (zsgui_debug_draw_fill)
			Console.Printf(
				"%s:\n\tDrawing frame at %d,%d of size %d,%d.",
				screenAreaInt.Origin[0], screenAreaInt.Origin[1],
				screenAreaInt.Size[0], screenAreaInt.Size[1]
			);
		
		Screen.DrawFrame(screenAreaInt.Origin[0], screenAreaInt.Origin[1], screenAreaInt.Size[0], screenAreaInt.Size[1]);
	}
	
	void DrawChar(Vector2 origin, int character, int charCellWidth = 0, int charCellHeight = 0) {
		let screenOrigin = ToScreenPoint(origin);
		
		int charCell[2]; {
			let charCellF = ToScreenSize((charCellWidth, charCellHeight));
			charCell[0] = int(charCellF.X + .5);
			charCell[1] = int(charCellF.Y + .5);
		}
		
		RectangleInt clip;
		GetClipInt(clip);
		
		if (zsgui_debug_draw_text)
			Console.Printf(
				"%s:\n\tDrawing single character %d at position %f,%f.\n\tChar cell size: %d,%d\n\tClip top=%d right=%d bottom=%d left=%d\n\tAlpha: %f",
				ToString(),
				character,
				screenOrigin.X, screenOrigin.Y,
				charCell[0], charCell[1],
				clip.Top(), clip.Right(), clip.Bottom(), clip.Left(),
				EffAlpha
			);
		
		Screen.DrawChar(
			TextFont, TextColor,
			screenOrigin.X, screenOrigin.Y,
			character,
			DTA_CellX, charCell[0],
			DTA_CellY, charCell[1],
			DTA_Alpha, EffAlpha,
			DTA_ClipTop, clip.Top(),
			DTA_ClipBottom, clip.Bottom(),
			DTA_ClipLeft, clip.Left(),
			DTA_ClipRight, clip.Right()
		);
	}
	
	void DrawText(Vector2 origin, String text, int charCellWidth = 0, int charCellHeight = 0) {
		let screenOrigin = ToScreenPoint(origin);
		
		int charCell[2]; {
			let charCellF = ToScreenSize((charCellWidth, charCellHeight));
			charCell[0] = int(charCellF.X + .5);
			charCell[1] = int(charCellF.Y + .5);
		}
		
		RectangleInt clip;
		GetClipInt(clip);
		
		if (zsgui_debug_draw_text) {
			let textBeginning = text.Left(40);
			if (text.Length() > textBeginning.Length())
				textBeginning = textBeginning.."...";
			
			Console.Printf(
				"%s:\n\tDrawing string \"%s\" at position %f,%f.\n\tChar cell size: %d,%d\n\tClip top=%d right=%d bottom=%d left=%d\n\tAlpha: %f",
				ToString(),
				textBeginning,
				screenOrigin.X, screenOrigin.Y,
				charCell[0], charCell[1],
				clip.Top(), clip.Right(), clip.Bottom(), clip.Left(),
				EffAlpha
			);
		}
		
		Screen.DrawText(
			TextFont, TextColor,
			screenOrigin.X, screenOrigin.Y,
			text,
			DTA_CellX, charCell[0],
			DTA_CellY, charCell[1],
			DTA_Alpha, EffAlpha,
			DTA_ClipTop, clip.Top(),
			DTA_ClipBottom, clip.Bottom(),
			DTA_ClipLeft, clip.Left(),
			DTA_ClipRight, clip.Right()
		);
	}
}
