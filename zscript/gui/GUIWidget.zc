class GUIWidget ui abstract {
	GUIWidget Parent;
	double Alpha;
	Vector2 Scale;
	GUIInsets Insets;
	
	/**
	 * Label for this widget. It will appear in console debug and error messages concerning this widget.
	 *
	 * This field should be set *before* calling the Init method, as Init itself may emit log messages.
	 */
	String ConsoleLabel;
	
	/**
	 * Current drawing context for this widget. It is set by the LayoutChild and TopLayout methods.
	 *
	 * The coordinate system of this DrawContext is the content area of this widget, and accounts for this widget's Alpha, Scale, and Insets, as well as any transformations applied by the parent widget.
	 */
	protected DrawContext DC;
	
	/**
	 * How this widget is to align its content inside its bounding area.
	 *
	 * If this widget must draw outside its bounds, it will do so in the opposite direction. For example, a top-left-aligned widget will overflow in the bottom-right direction.
	 *
	 * By default, the alignment is centered in both dimensions. Widgets may change this in their Init method. Applications may set this as well.
	 */
	GUIXYAlignment Align;
	
	virtual void Init(GUIWidget parent) {
		self.Parent = parent;
		Alpha = 1;
		Scale = (1, 1);
	}
	
	/**
	 * Finds the top-level ancestor of this widget. The top-level ancestor is the widget whose Parent is null. If this widget is itself top-level, then this widget is returned. Does not return null.
	 */
	GUIWidget TopLevelAncestor() {
		GUIWidget r = self;
		for (let w = r; w != null; w = w.Parent)
			r = w;
		return r;
	}
	
	/**
	 * Computes the preferred width of this widget.
	 *
	 * The preferred size is the size at which this widget would look best. Layout code is free to ignore the preferred size, however, in favor of other layout considerations.
	 *
	 * The parameter “height” contains the already-computed height of this widget, if one is available. If the ResizeBias is set to RBIAS_VERTICAL, layout code should first compute a height (using PreferredHeight(-1)) before computing a preferred width. A negative value for the “height” parameter means that information is not available.
	 *
	 * The returned value accounts for the Scale and Insets of this widget.
	 */
	virtual double PreferredWidth(double height = -1.) {
		return 0;
	}
	
	/**
	 * Computes the preferred height of this widget.
	 *
	 * The preferred size is the size at which this widget would look best. Layout code is free to ignore the preferred size, however, in favor of other layout considerations.
	 *
	 * The parameter “width” contains the already-computed width of this widget, if one is available. If the ResizeBias is set to RBIAS_HORIZONTAL, layout managers should first compute a width (using PreferredWidth(-1)) before computing a preferred height. A negative value for the “width” parameter means that information is not available.
	 *
	 * The returned value accounts for the Scale and Insets of this widget.
	 */
	virtual double PreferredHeight(double width = -1.) {
		return 0;
	}
	
	/**
	 * Computes the preferred size of this widget.
	 *
	 * This calls PreferredWidth and PreferredHeight to do the actual calculation. If the ResizeBias isn't RBIAS_NONE, the dimensions are computed in the appropriate order. Otherwise, they are computed independently.
	 *
	 * The parameter “outer” gives the pre-computed dimensions that this widget should fit itself into. These are passed as the parameters of the PreferredWidth and PreferredHeight methods. If no value is known for a given dimension, pass -1 in that dimension. The default value is (-1, -1), which requests the unconstrained preferred size.
	 *
	 * The returned value accounts for the Scale and Insets of this widget.
	 */
	Vector2 PreferredSize(Vector2 outer = (-1., -1.)) {
		double d;
		switch (ResizeBias()) {
			case RBIAS_HORIZONTAL:
				d = PreferredWidth(outer.Y);
				return (d, PreferredHeight(d));
			
			case RBIAS_VERTICAL:
				d = PreferredHeight(outer.X);
				return (PreferredWidth(d), d);
			
			default:
				return (PreferredWidth(outer.X), PreferredHeight(outer.Y));
		}
	}
	
	/**
	 * Returns the current resize bias of this widget. The resize bias (if any) means that this widget needs to know one of its sizes before it can compute the other.
	 *
	 * Possible return values are:
	 * - RBIAS_NONE: Neither height nor width depend on each other.
	 * - RBIAS_HORIZONTAL: The height of this widget depends on its width.
	 * - RBIAS_VERTICAL: The width of this widget depends on its height.
	 *
	 * The default implementation of this method simply returns RBIAS_NONE.
	 */
	virtual EResizeBias ResizeBias() {
		return RBIAS_NONE;
	}
	
	enum EResizeBias {
		RBIAS_NONE,
		RBIAS_HORIZONTAL,
		RBIAS_VERTICAL
	};
	
	private void SetupDC() {
		DC.ConsoleLabel = ConsoleLabel..".DC";
		
		if (UsingTopLayout) {
			// Find the bounds.
			DC.Bounds = AutoResize? PreferredSize(TopLayoutArea.Size) : TopLayoutArea.Size;
			
			// Find the (top-left) origin.
			Rectangle effArea;
			effArea.Size = DC.Bounds;
			effArea.PositionAbout(TopLayoutArea.Origin, Align.X, Align.Y);
			
			// Initialize the drawing context.
			DC.Initial();
			DC.Translate(effArea.Origin);
		}
		
		// Set up the drawing context.
		DC.Scale(Scale);
		DC.ApplyInsets(Insets);
		DC.Fade(Alpha);
		
		if (zsgui_debug_layout)
			Console.Printf("%s: Drawing context initialized: %s", ToString(), DC.ToString(fieldsOnly: true));
	}
	
	/**
	 * Lays out a child widget. This method sets up the child's Parent, DC, and Bounds fields, then calls its Layout method.
	 *
	 * This method is similar to TopLayout, but is meant for child widgets instead of top-level ones.
	 *
	 * Note that this method is called on the *parent* widget, and given the child as a parameter.
	 */
	protected void LayoutChild(GUIWidget child, Rectangle area) {
		LayoutChildWithDC(child, area, DC);
	}
	
	protected void LayoutChildWithDC(GUIWidget child, Rectangle area, DrawContext dc) {
		child.Parent = self;
		child.UsingTopLayout = false;
		child.DC.Copy(dc);
		child.DC.Translate(area.Origin);
		child.DC.Bounds = area.Size;
		child.SetupDC();
		child.Layout();
	}
	
	/**
	 * Lays out this top-level widget. Applications should call this method on their top-level widgets to position and size them.
	 *
	 * This method clears the Parent field, sets up the DC and Bounds fields, and calls Layout.
	 *
	 * This method is similar to LayoutChild, but is meant for top-level widgets instead of child ones.
	 *
	 * @param origin The point on screen that this widget is to be positioned at. The widget is aligned to this point according to the Align field.
	 *
	 * @param size The size that this widget is to have. May be negative, in which case the size is automatically computed from this widget's preferred size.
	 *
	 * @param autoResize If true, the size parameter is taken as only a hint, and the actual size is computed by passing size to the PreferredSize method. If false, the size parameter is used directly. If either dimension of size is negative, this parameter is ignored, and the actual size is computed as though it were true.
	 */
	void TopLayout(Vector2 origin, Vector2 size = (-1, -1), bool autoResize = true) {
		UsingTopLayout = true;
		Parent = null;
		TopLayoutArea.Origin = origin;
		TopLayoutArea.Size = size;
		self.AutoResize = autoResize || size.X < 0. || size.Y < 0.;
		Layout();
	}
	
	private bool LayoutDone, UsingTopLayout, AutoResize;
	private Rectangle TopLayoutArea;
	
	/**
	 * Lays out this widget's content and descendants.
	 *
	 * This method is expected to carry out any computation needed to draw, that doesn't have to be done every frame. In particular, this includes calculating positions and sizes for child widgets and other content; thus, the name Layout.
	 *
	 * This is called by the TopLayout and LayoutChild methods.
	 *
	 * Subclasses need to override this method to perform whatever layout steps they need, including laying out any child widgets (with the LayoutChild method). Subclasses must call Super.Layout() first, as this base-class method may change the DC and Bounds fields, and resets the flag set by RequestLayout.
	 *
	 * This base-class method also, if enabled, emits a log message stating this widget's current position and bounds (in screen coordinates).
	 */
	virtual void Layout() {
		if (UsingTopLayout)
			SetupDC();
		
		LayoutDone = true;
		
		if (zsgui_debug_layout)
			Console.Printf("ZsGUI: Laying out %s into area %s (DC bounds: %f,%f).", ToString(), ScreenAreaToString(), DC.Bounds.X, DC.Bounds.Y);
	}
	
	/**
	 * Invalidates the layout of this widget and all ancestors. Layout will be recomputed during the next Draw call.
	 *
	 * This needs to be called whenever there is a change (other than by the Layout method) to this widget's size, position, scale factor, or parent.
	 */
	void RequestLayout() {
		LayoutDone = false;
		if (Parent != null)
			Parent.RequestLayout();
	}
	
	/**
	 * Returns a textual description of this widget. This is used when logging error messages.
	 */
	virtual String ToString() {
		return String.Format("%s %s", GetClassName(), ConsoleLabel);
	}
	
	String ScreenAreaToString() {
		Rectangle r;
		r.Size = DC.Bounds;
		DC.ToScreenRect(r);
		return r.ToString();
	}
	
	virtual void Draw() {
		if (!LayoutDone)
			Layout();
		
		if (zsgui_debug_show_box) {
			Rectangle bounds;
			bounds.Size = DC.Bounds;
			DC.DrawFrame(bounds);
		}
	}
}
