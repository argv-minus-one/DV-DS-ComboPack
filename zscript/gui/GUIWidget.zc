class GUIWidget ui abstract {
	GUIWidget Parent;
	GUIInsets Insets;
	
	/**
	 * Label for this widget. It will appear in console debug and error messages concerning this widget.
	 *
	 * This field should be set *before* calling the Init method, as Init itself may emit log messages.
	 */
	String ConsoleLabel;
	
	/**
	 * The current bounding area for this widget.
	 *
	 * This is set by the parent widget's Layout method (if there is a parent) or the application (if this is a top-level widget).
	 *
	 * Widgets are not to change their own Bounds (unless told to do so, e.g. by the TopLayout method). Information about the layout of a widget's content (such as where to draw lines of text) should be stored in other fields defined by the specific widget class, not in the Bounds field.
	 */
	Rectangle Bounds;
	
	/**
	 * How this widget is to align its content inside its bounding area.
	 *
	 * If this widget must draw outside its bounds, it will do so in the opposite direction. For example, a top-left-aligned widget will overflow in the bottom-right direction.
	 *
	 * By default, the alignment is centered in both dimensions. Widgets may change this in their Init method. Applications may set this as well.
	 */
	GUIXYAlignment Align;
	
	virtual void Init(GUIWidget parent) {
		self.Parent = parent;
	}
	
	/**
	 * Finds the top-level ancestor of this widget. The top-level ancestor is the widget whose Parent is null. If this widget is itself top-level, then this widget is returned. Does not return null.
	 */
	GUIWidget TopLevelAncestor() {
		GUIWidget r = self;
		for (let w = r; w != null; w = w.Parent)
			r = w;
		return r;
	}
	
	/**
	 * Computes the preferred width of this widget.
	 *
	 * The preferred size is the size at which this widget would look best. Layout code is free to ignore the preferred size, however, in favor of other layout considerations.
	 *
	 * The parameter “height” contains the already-computed height of this widget, if one is available. If the ResizeBias is set to RBIAS_VERTICAL, layout code should first compute a height (using PreferredHeight(-1)) before computing a preferred width. A negative value for the “height” parameter means that information is not available.
	 *
	 * The returned value accounts for the Insets of this widget.
	 */
	virtual double PreferredWidth(double height = -1.) {
		return 0;
	}
	
	/**
	 * Computes the preferred height of this widget.
	 *
	 * The preferred size is the size at which this widget would look best. Layout code is free to ignore the preferred size, however, in favor of other layout considerations.
	 *
	 * The parameter “width” contains the already-computed width of this widget, if one is available. If the ResizeBias is set to RBIAS_HORIZONTAL, layout managers should first compute a width (using PreferredWidth(-1)) before computing a preferred height. A negative value for the “width” parameter means that information is not available.
	 *
	 * The returned value accounts for the Insets of this widget.
	 */
	virtual double PreferredHeight(double width = -1.) {
		return 0;
	}
	
	/**
	 * Computes the preferred size of this widget.
	 *
	 * This calls PreferredWidth and PreferredHeight to do the actual calculation. If the ResizeBias isn't RBIAS_NONE, the dimensions are computed in the appropriate order. Otherwise, they are computed independently.
	 *
	 * The parameter “outer” gives the pre-computed dimensions that this widget should fit itself into. These are passed as the parameters of the PreferredWidth and PreferredHeight methods. If no value is known for a given dimension, pass -1 in that dimension. The default value is (-1, -1), which requests the unconstrained preferred size.
	 *
	 * The returned value accounts for the Insets of this widget.
	 */
	Vector2 PreferredSize(Vector2 outer = (-1., -1.)) {
		double d;
		switch (ResizeBias()) {
			case RBIAS_HORIZONTAL:
				d = PreferredWidth(outer.Y);
				return (d, PreferredHeight(d));
			
			case RBIAS_VERTICAL:
				d = PreferredHeight(outer.X);
				return (PreferredWidth(d), d);
			
			default:
				return (PreferredWidth(outer.X), PreferredHeight(outer.Y));
		}
	}
	
	/**
	 * Computes the current content area of this widget.
	 *
	 * This is mainly intended for use by this widget's layout code, for positioning its content.
	 */
	void GetContentArea(out Rectangle rect) {
		rect.Copy(Bounds);
		Insets.Apply(rect);
	}
	
	/**
	 * Returns the current resize bias of this widget. The resize bias (if any) means that this widget needs to know one of its sizes before it can compute the other.
	 *
	 * Possible return values are:
	 * - RBIAS_NONE: Neither height nor width depend on each other.
	 * - RBIAS_HORIZONTAL: The height of this widget depends on its width.
	 * - RBIAS_VERTICAL: The width of this widget depends on its height.
	 *
	 * The default implementation of this method simply returns RBIAS_NONE.
	 */
	virtual EResizeBias ResizeBias() {
		return RBIAS_NONE;
	}
	
	enum EResizeBias {
		RBIAS_NONE,
		RBIAS_HORIZONTAL,
		RBIAS_VERTICAL
	};
	
	/**
	 * Lays out a child widget. This method sets up the child's Parent and Bounds fields, then calls its Layout method.
	 *
	 * This method is similar to TopLayout, but is meant for child widgets instead of top-level ones.
	 *
	 * Note that this method is called on the *parent* widget, and given the child as a parameter.
	 */
	protected void LayoutChild(GUIWidget child, Rectangle area) {
		child.Parent = self;
		child.Bounds.Copy(area);
		child.UsingTopLayout = false;
		child.Layout();
	}
	
	/**
	 * Lays out this top-level widget. Applications should call this method on their top-level widgets to position and size them.
	 *
	 * This method clears the Parent field, sets up the Bounds field, and calls Layout.
	 *
	 * This method is similar to LayoutChild, but is meant for top-level widgets instead of child ones.
	 *
	 * @param origin The point on screen that this widget is to be positioned at. The widget is aligned to this point according to the Align field.
	 *
	 * @param size The size that this widget is to have. May be negative, in which case the size is automatically computed from this widget's preferred size.
	 *
	 * @param autoResize If true, the size parameter is taken as only a hint, and the actual size is computed by passing size to the PreferredSize method. If false, the size parameter is used directly. If either dimension of size is negative, this parameter is ignored, and the actual size is computed as though it were true.
	 */
	void TopLayout(Vector2 origin, Vector2 size = (-1, -1), bool autoResize = true) {
		UsingTopLayout = true;
		Parent = null;
		TopLayoutArea.Origin = origin;
		TopLayoutArea.Size = size;
		self.AutoResize = autoResize || size.X < 0. || size.Y < 0.;
		Layout();
	}
	
	private bool LayoutDone, UsingTopLayout, AutoResize;
	private Rectangle TopLayoutArea;
	
	/**
	 * Lays out this widget and all descendants.
	 *
	 * This method is expected to carry out any computation needed to draw, that doesn't have to be done every frame. In particular, this includes calculating positions and sizes for child widgets and other content; thus, the name Layout.
	 *
	 * This is called by the TopLayout and LayoutChild methods. It is also called by the Draw method, if needed.
	 *
	 * Subclasses need to override this method to perform whatever layout steps they need, including laying out any child widgets (with the LayoutChild method). Subclasses must call Super.Layout() first, as this base-class method resets the flag set by RequestLayout.
	 *
	 * This base-class method also, if enabled, emits a log message stating this widget's current position and size.
	 */
	virtual void Layout() {
		if (UsingTopLayout) {
			// Find the size.
			Bounds.Size = AutoResize? PreferredSize(TopLayoutArea.Size) : TopLayoutArea.Size;
			
			// Find the (top-left) origin.
			Bounds.PositionAbout(TopLayoutArea.Origin, Align.X, Align.Y);
		}
		
		LayoutDone = true;
		
		if (zsgui_debug_layout) {
			Rectangle ca;
			GetContentArea(ca);
			Console.Printf("ZsGUI: Laying out %s into area %s.", ToString(), ca.ToString());
		}
	}
	
	/**
	 * Invalidates the layout of this widget. Layout will be recomputed during the next Draw call on any top-level ancestor.
	 *
	 * This needs to be called whenever there is a change (other than by the Layout method) to this widget's size or position.
	 *
	 * This method may be overridden, if a widget needs to perform some additional action whenever layout becomes needed. Be sure to call Super.RequestLayout() from overrides.
	 */
	virtual void RequestLayout() {
		LayoutDone = false;
	}
	
	/**
	 * Returns true if this widget, or any descendant, needs to be laid out again (because RequestLayout has been called, or because Layout has never been called). Otherwise returns false.
	 *
	 * Subclasses should override this method to also call it on their children.
	 */
	virtual bool NeedsLayout() {
		return !LayoutDone;
	}
	
	/**
	 * Calls Layout() only if NeedsLayout() returns true. Otherwise, does nothing.
	 */
	void LayoutIfNeeded() {
		if (NeedsLayout())
			Layout();
	}
	
	/**
	 * Returns a textual description of this widget. This is used when logging error messages.
	 */
	virtual String ToString() {
		return String.Format("%s %s", GetClassName(), ConsoleLabel);
	}
	
	/**
	 * Informs this widget that a new game tic has happened.
	 *
	 * By default, this method does nothing. Subclasses may perform whatever action they need in response to this event. Subclasses that have child widgets should call their Tick methods as well.
	 */
	virtual void Tick() {}
	
	virtual void Draw() {
		if (!Parent)
			LayoutIfNeeded();
		
		if (zsgui_debug_show_box) {
			Rectangle ca;
			GetContentArea(ca);
			Screen.DrawFrame(ca.Origin.X, ca.Origin.Y, ca.Size.X, ca.Size.Y);
		}
	}
}
