class GUIWidget ui abstract {
	GUIWidget Parent;
	double Alpha;
	Vector2 Scale;
	GUIInsets Insets;
	
	/**
	 * Label for this widget. It will appear in console debug and error messages concerning this widget.
	 *
	 * This field should be set *before* calling the Init method, as Init itself may emit log messages.
	 */
	String ConsoleLabel;
	
	/**
	 * The current bounding area for this widget. Accounts for the Scale of this and ancestor widgets.
	 *
	 * This is set by the parent widget's Layout method (if there is a parent) or the application (if this is a top-level widget).
	 *
	 * Widgets are not to change their own Bounds (unless told to do so, e.g. by the AutoSize method). Information about the layout of a widget's content (such as where to draw lines of text) should be stored in other fields defined by the specific widget class, not in the Bounds field.
	 */
	Rectangle Bounds;
	
	/**
	 * How this widget is to align its content inside its bounding area.
	 *
	 * If this widget must draw outside its bounds, it will do so in the opposite direction. For example, a top-left-aligned widget will overflow in the bottom-right direction.
	 *
	 * By default, the alignment is centered in both dimensions. Widgets may change this in their Init method. Applications may set this as well.
	 */
	GUIXYAlignment Align;
	
	virtual void Init(GUIWidget parent) {
		self.Parent = parent;
		Alpha = 1;
		Scale = (1, 1);
	}
	
	/**
	 * Finds the top-level ancestor of this widget. The top-level ancestor is the widget whose Parent is null. If this widget is itself top-level, then this widget is returned. Does not return null.
	 */
	GUIWidget TopLevelAncestor() {
		GUIWidget r = self;
		for (let w = r; w != null; w = w.Parent)
			r = w;
		return r;
	}
	
	/**
	 * Computes the preferred width of this widget.
	 *
	 * The preferred size is the size at which this widget would look best. Layout code is free to ignore the preferred size, however, in favor of other layout considerations.
	 *
	 * The parameter “height” contains the already-computed height of this widget, if one is available. If the ResizeBias is set to RBIAS_VERTICAL, layout code should first compute a height (using PreferredHeight(-1)) before computing a preferred width. A negative value for the “height” parameter means that information is not available.
	 *
	 * The returned value accounts for the EffScale of this widget.
	 */
	virtual double PreferredWidth(double height = -1.) {
		return 0;
	}
	
	/**
	 * Computes the preferred height of this widget.
	 *
	 * The preferred size is the size at which this widget would look best. Layout code is free to ignore the preferred size, however, in favor of other layout considerations.
	 *
	 * The parameter “width” contains the already-computed width of this widget, if one is available. If the ResizeBias is set to RBIAS_HORIZONTAL, layout managers should first compute a width (using PreferredWidth(-1)) before computing a preferred height. A negative value for the “width” parameter means that information is not available.
	 *
	 * The returned value accounts for the EffScale of this widget.
	 */
	virtual double PreferredHeight(double width = -1.) {
		return 0;
	}
	
	/**
	 * Computes the preferred size of this widget.
	 *
	 * This calls PreferredWidth and PreferredHeight to do the actual calculation. If the ResizeBias isn't RBIAS_NONE, the dimensions are computed in the appropriate order. Otherwise, they are computed independently.
	 *
	 * The parameter “outer” gives the pre-computed dimensions that this widget should fit itself into. These are passed as the parameters of the PreferredWidth and PreferredHeight methods. If no value is known for a given dimension, pass -1 in that dimension. The default value is (-1, -1), which requests the unconstrained preferred size.
	 */
	Vector2 PreferredSize(Vector2 outer = (-1., -1.)) {
		double d;
		switch (ResizeBias()) {
			case RBIAS_HORIZONTAL:
				d = PreferredWidth(outer.Y);
				return (d, PreferredHeight(d));
			
			case RBIAS_VERTICAL:
				d = PreferredHeight(outer.X);
				return (PreferredWidth(d), d);
			
			default:
				return (PreferredWidth(outer.X), PreferredHeight(outer.Y));
		}
	}
	
	/**
	 * Computes the current content area of this widget.
	 *
	 * This is mainly intended for use by this widget's layout code, for positioning its content.
	 */
	void GetContentArea(out Rectangle rect) {
		rect.Copy(Bounds);
		Insets.Apply(rect, EffScale());
	}
	
	/**
	 * Returns the current resize bias of this widget. The resize bias (if any) means that this widget needs to know one of its sizes before it can compute the other.
	 *
	 * Possible return values are:
	 * - RBIAS_NONE: Neither height nor width depend on each other.
	 * - RBIAS_HORIZONTAL: The height of this widget depends on its width.
	 * - RBIAS_VERTICAL: The width of this widget depends on its height.
	 *
	 * The default implementation of this method simply returns RBIAS_NONE.
	 */
	virtual EResizeBias ResizeBias() {
		return RBIAS_NONE;
	}
	
	enum EResizeBias {
		RBIAS_NONE,
		RBIAS_HORIZONTAL,
		RBIAS_VERTICAL
	};
	
	double EffAlpha() {
		let a = Alpha;
		if (Parent != null)
			a *= Parent.EffAlpha();
		return clamp(a, 0., 1.);
	}
	
	Vector2 EffScale() {
		if (Parent == null)
			return Scale;
		else
			return GUIUtil.Vec2Mul(Scale, Parent.EffScale());
	}
	
	double EffXScale() {
		let scale = EffScale();
		return scale.X;
	}
	
	double EffYScale() {
		let scale = EffScale();
		return scale.Y;
	}
	
	void AutoSize() {
		Bounds.Size = PreferredSize();
		Bounds.PositionAbout(Bounds.Origin, Align.X, Align.Y);
		Layout();
	}
	
	private bool _LayoutDone;
	
	/**
	 * Lays out this widget and all descendants.
	 *
	 * This method is expected to resize and reposition this widget and any child widgets into the space allotted for this widget's content (as given by the GetContentArea method). For each child widget, this method must set the child's Bounds, then call its Layout method.
	 *
	 * This is called by the Draw method initially, and again whenever the RequestLayout method is called.
	 *
	 * Subclasses need to override this method to perform whatever layout steps they need, including positioning of any child widgets. Subclasses also need to call Super.Layout at some point.
	 *
	 * The base class implementation of this method simply resets the flag set by RequestLayout, and if enabled, emits a log message stating this widget's current bounds and content area.
	 */
	virtual void Layout() {
		_LayoutDone = true;
		
		if (zsgui_debug_layout) {
			Rectangle ca;
			GetContentArea(ca);
			Console.Printf("ZsGUI: Laying out %s into area %s (content area %s).", ToString(), Bounds.ToString(), ca.ToString());
		}
	}
	
	/**
	 * Invalidates the layout of this widget and all ancestors. Layout will be recomputed during the next Draw call.
	 *
	 * This needs to be called whenever there is a change (other than by the Layout method) to this widget's size, position, scale factor, or parent.
	 */
	void RequestLayout() {
		_LayoutDone = false;
		if (Parent != null)
			Parent.RequestLayout();
	}
	
	/**
	 * Returns a textual description of this widget. This is used when logging error messages.
	 */
	virtual String ToString() {
		return String.Format("%s %s", GetClassName(), ConsoleLabel);
	}
	
	virtual void Draw() {
		if (!_LayoutDone)
			Layout();
	}
}
