class GUIWidget ui {
	GUIWidget Parent;
	double Alpha;
	Vector2 Scale;
	GUIInsets Insets;
	bool Resizable;
	
	/**
	 * Label for this widget. It will appear in console debug and error messages concerning this widget.
	 *
	 * This field should be set *before* calling the Init method, as Init itself may emit log messages.
	 */
	String ConsoleLabel;
	
	/** The current bounding area for this widget. Accounts for the Scale of this and ancestor widgets. */
	Rectangle Bounds;
	
	/**
	 * How this widget is to align its content inside its bounding area.
	 *
	 * If this widget must draw outside its bounds, it will do so in the opposite direction. For example, a top-left-aligned widget will overflow in the bottom-right direction.
	 *
	 * In top-level widgets, this is set by the application. In non-top-level widgets, this is set by the parent.
	 */
	GUIXYAlignment Align;
	
	virtual void Init(GUIWidget parent) {
		self.Parent = parent;
		Alpha = 1;
		Scale = (1, 1);
		Resizable = true;
	}
	
	/**
	 * Finds the top-level ancestor of this widget. The top-level ancestor is the widget whose Parent is null. If this widget is itself top-level, then this widget is returned. Does not return null.
	 */
	GUIWidget TopLevelAncestor() {
		GUIWidget r = self;
		for (let w = r; w != null; w = w.Parent)
			r = w;
		return r;
	}
	
	/**
	 * Computes the preferred width of this widget.
	 *
	 * The preferred size is the size at which this widget would look best. Layout code is free to ignore the preferred size, however, in favor of other layout considerations.
	 *
	 * The parameter “height” contains the already-computed height of this widget, if one is available. If the ResizeBias is set to RBIAS_VERTICAL, layout code should first compute a height (using PreferredHeight(-1)) before computing a preferred width. A negative value for the “height” parameter means that information is not available.
	 *
	 * The returned value accounts for the EffScale of this widget.
	 */
	virtual double PreferredWidth(double height = -1.) {
		return 0;
	}
	
	/**
	 * Computes the preferred height of this widget.
	 *
	 * The preferred size is the size at which this widget would look best. Layout code is free to ignore the preferred size, however, in favor of other layout considerations.
	 *
	 * The parameter “width” contains the already-computed width of this widget, if one is available. If the ResizeBias is set to RBIAS_HORIZONTAL, layout managers should first compute a width (using PreferredWidth(-1)) before computing a preferred height. A negative value for the “width” parameter means that information is not available.
	 *
	 * The returned value accounts for the EffScale of this widget.
	 */
	virtual double PreferredHeight(double width = -1.) {
		return 0;
	}
	
	/**
	 * Computes the preferred size of this widget.
	 *
	 * This calls PreferredWidth and PreferredHeight to do the actual calculation. If the ResizeBias isn't RBIAS_NONE, the dimensions are computed in the appropriate order. Otherwise, they are computed independently.
	 *
	 * The parameter “outer” gives the pre-computed dimensions that this widget should fit itself into. These are passed as the parameters of the PreferredWidth and PreferredHeight methods. If no value is known for a given dimension, pass -1 in that dimension. The default value is (-1, -1), which requests the unconstrained preferred size.
	 */
	Vector2 PreferredSize(Vector2 outer = (-1., -1.)) {
		double d;
		switch (ResizeBias()) {
			case RBIAS_HORIZONTAL:
				d = PreferredWidth(outer.Y);
				return (d, PreferredHeight(d));
			
			case RBIAS_VERTICAL:
				d = PreferredHeight(outer.X);
				return (PreferredWidth(d), d);
			
			default:
				return (PreferredWidth(outer.X), PreferredHeight(outer.Y));
		}
	}
	
	/**
	 * Returns the current resize bias of this widget. The resize bias (if any) means that this widget needs to know one of its sizes before it can compute the other.
	 *
	 * Possible return values are:
	 * - RBIAS_NONE: Neither height nor width depend on each other.
	 * - RBIAS_HORIZONTAL: The height of this widget depends on its width.
	 * - RBIAS_VERTICAL: The width of this widget depends on its height.
	 *
	 * The default implementation of this method simply returns RBIAS_NONE.
	 */
	virtual EResizeBias ResizeBias() {
		return RBIAS_NONE;
	}
	
	enum EResizeBias {
		RBIAS_NONE,
		RBIAS_HORIZONTAL,
		RBIAS_VERTICAL
	};
	
	double EffAlpha() {
		let a = Alpha;
		if (Parent != null)
			a *= Parent.EffAlpha();
		return clamp(a, 0., 1.);
	}
	
	Vector2 EffScale() {
		if (Parent == null)
			return Scale;
		else
			return GUIUtil.Vec2Mul(Scale, Parent.EffScale());
	}
	
	double EffXScale() {
		let scale = EffScale();
		return scale.X;
	}
	
	double EffYScale() {
		let scale = EffScale();
		return scale.Y;
	}
	
	void LayoutAutoSize(Vector2 origin) {
		Rectangle rect;
		rect.Origin = origin;
		rect.Size = (-1, -1);
		Layout(rect);
	}
	
	private bool _LayoutDone;
	
	/**
	 * Lays out this widget and all descendants.
	 *
	 * This method is expected to resize and reposition this widget and any child widgets into the space allotted for this widget (as given in the “area” parameter).
	 *
	 * If you override this method but don't call Super.Layout, then you need to call the LayoutDone method before returning. If you do neither, your widget will still work, but it will waste a bunch of CPU time.
	 *
	 * This is called by the Draw method initially, and again whenever the RequestLayout method is called.
	 *
	 * If Resizable is true, and the given area has a negative size in one or both dimensions, then the preferred size will be used.
	 */
	virtual void Layout(Rectangle area) {
		if (Resizable)
			Bounds.Size = Insets.ApplySize(PreferredSize(area.Size), EffScale());
		
		Bounds.PositionIn(area, Align.X, Align.Y);
		LayoutDone();
		
		if (zsgui_debug_layout)
			Console.Printf("ZsGUI: Basic layout for %s done. Provided area was %s. Final bounds are %s.", ToString(), area.ToString(), Bounds.ToString());
	}
	
	/**
	 * This method needs to be called once the Layout method completes. If you override the Layout method and don't call Super.Layout, then you need to call this method.
	 */
	protected void LayoutDone() {
		_LayoutDone = true;
	}
	
	/**
	 * Invalidates the layout of this widget and all ancestors. Layout will be recomputed during the next Draw call.
	 *
	 * This needs to be called whenever there is a change (other than by the Layout method) to this widget's size, position, scale factor, or parent.
	 */
	void RequestLayout() {
		_LayoutDone = false;
		if (Parent != null)
			Parent.RequestLayout();
	}
	
	/**
	 * Returns a textual description of this widget. This is used when logging error messages.
	 */
	virtual String ToString() {
		return String.Format("%s %s", GetClassName(), ConsoleLabel);
	}
	
	virtual void Draw() {
		if (!_LayoutDone)
			Layout(Bounds);
	}
}
