class GUIWidget ui {
	GUIWidget Parent;
	double Alpha;
	Vector2 Scale;
	GUIInsets Insets;
	bool Resizable/*, ResizeProportionally*/;
	
	/**
	 * Label for this widget. It will appear in console debug and error messages concerning this widget.
	 *
	 * This field should be set *before* calling the Init method, as Init itself may emit log messages.
	 */
	String ConsoleLabel;
	
	/** The current bounding area for this widget. Accounts for the Scale of this and ancestor widgets. */
	Rectangle Bounds;
	
	/**
	 * How this widget is to align its content inside its bounding area.
	 *
	 * If this widget must draw outside its bounds, it will do so in the opposite direction. For example, a top-left-aligned widget will overflow in the bottom-right direction.
	 *
	 * In top-level widgets, this is set by the application. In non-top-level widgets, this is set by the parent.
	 */
	GUIXYAlignment Align;
	
	virtual void Init(GUIWidget parent) {
		self.Parent = parent;
		Alpha = 1;
		Scale = (1, 1);
		Resizable = /*ResizeProportionally =*/ true;
	}
	
	/**
	 * Finds the top-level ancestor of this widget. The top-level ancestor is the widget whose Parent is null. If this widget is itself top-level, then this widget is returned. Does not return null.
	 */
	GUIWidget TopLevelAncestor() {
		GUIWidget r = self;
		for (let w = r; w != null; w = w.Parent)
			r = w;
		return r;
	}
	
	/**
	 * Computes the preferred width of this widget.
	 *
	 * The preferred size is the size at which this widget would look best. Layout code is free to ignore the preferred size, however, in favor of other layout considerations.
	 *
	 * The parameter “height” contains the already-computed height of this widget, if one is available. If the ResizeBias is set to RBIAS_VERTICAL, layout code should first compute a height (using PreferredHeight(-1)) before computing a preferred width. A negative value for the “height” parameter means that information is not available.
	 *
	 * The returned value accounts for the EffScale of this widget.
	 */
	virtual double PreferredWidth(double height = -1.) {
		return 0;
		// Previously: By default, the preferred size is equal to the minimum size. In other words, the default implementation of PreferredWidth simply calls MinimumWidth.
		//return MinimumWidth(height);
	}
	
	/**
	 * Computes the preferred height of this widget.
	 *
	 * The preferred size is the size at which this widget would look best. Layout code is free to ignore the preferred size, however, in favor of other layout considerations.
	 *
	 * The parameter “width” contains the already-computed width of this widget, if one is available. If the ResizeBias is set to RBIAS_HORIZONTAL, layout managers should first compute a width (using PreferredWidth(-1)) before computing a preferred height. A negative value for the “width” parameter means that information is not available.
	 *
	 * The returned value accounts for the EffScale of this widget.
	 */
	virtual double PreferredHeight(double width = -1.) {
		return 0;
		// Previously: By default, the preferred size is equal to the minimum size. In other words, the default implementation of PreferredHeight simply calls MinimumHeight.
		//return MinimumHeight(width);
	}
	
	/**
	 * Computes the preferred size of this widget.
	 *
	 * This calls PreferredWidth and PreferredHeight to do the actual calculation. If the ResizeBias isn't RBIAS_NONE, the dimensions are computed in the appropriate order. Otherwise, they are computed independently.
	 *
	 * The parameter “outer” gives the pre-computed dimensions that this widget should fit itself into. These are passed as the parameters of the PreferredWidth and PreferredHeight methods. If no value is known for a given dimension, pass -1 in that dimension. The default value is (-1, -1), which requests the unconstrained preferred size.
	 */
	Vector2 PreferredSize(Vector2 outer = (-1., -1.)) {
		double d;
		switch (ResizeBias()) {
			case RBIAS_HORIZONTAL:
				d = PreferredWidth(outer.Y);
				return (d, PreferredHeight(d));
			
			case RBIAS_VERTICAL:
				d = PreferredHeight(outer.X);
				return (PreferredWidth(d), d);
			
			default:
				return (PreferredWidth(outer.X), PreferredHeight(outer.Y));
		}
	}
	
	/*
	 * Computes the minimum width for this widget.
	 *
	 * The minimum size is the smallest size at which this widget will draw. If told to draw into an area smaller than that, it will draw outside of that area.
	 *
	 * The parameter “height” contains the already-computed height of this widget, if one is available. If the ResizeBias is set to RBIAS_VERTICAL, layout managers should first compute a height (using MinimumHeight(-1)) before computing a preferred width. A negative value for the “height” parameter means that information is not available.
	 *
	 * The returned value accounts for the EffScale of this widget.
	virtual double MinimumWidth(double height = -1.) {
		return 0;
	}
	 */
	
	/*
	 * Computes the minimum height of this widget.
	 *
	 * The minimum size is the smallest size at which this widget can draw correctly. If told to draw into an area smaller than that, it may draw outside of that area.
	 *
	 * The parameter “width” contains the already-computed width of this widget, if one is available. If the ResizeBias is set to RBIAS_HORIZONTAL, layout managers should first compute a width (using MinimumWidth(-1)) before computing a preferred height. A negative value for the “width” parameter means that information is not available.
	 *
	 * The returned value accounts for the EffScale of this widget.
	virtual double MinimumHeight(double width = -1.) {
		return 0;
	}
	 */
	
	/*
	 * Computes the minimum size of this widget.
	 *
	 * The minimum size is the smallest size at which this widget will draw. If told to draw into an area smaller than that, it will draw outside of that area.
	 *
	 * This calls MinimumWidth and MinimumHeight to do the actual calculation. If the ResizeBias isn't RBIAS_NONE, the dimensions are computed in the appropriate order. Otherwise, they are computed independently.
	 *
	 * The parameter “outer” gives the pre-computed dimensions that this widget should fit itself into. These are passed as the parameters of the MinimumWidth and MinimumHeight methods. If no value is known for a given dimension, pass -1 in that dimension. The default value is (-1, -1), which requests the unconstrained minimum size.
	Vector2 MinimumSize(Vector2 outerSize = (-1., -1.)) {
		double d;
		switch (ResizeBias()) {
			case RBIAS_HORIZONTAL:
				d = MinimumWidth(outer.Y);
				return (d, MinimumHeight(d));
			
			case RBIAS_VERTICAL:
				d = MinimumHeight(outer.X);
				return (MinimumWidth(d), d);
			
			default:
				return (MinimumWidth(outer.X), MinimumHeight(outer.Y));
		}
	}
	 */
	
	/**
	 * Returns the current resize bias of this widget. The resize bias (if any) means that this widget needs to know one of its sizes before it can compute the other.
	 *
	 * Possible return values are:
	 * - RBIAS_NONE: Neither height nor width depend on each other.
	 * - RBIAS_HORIZONTAL: The height of this widget depends on its width.
	 * - RBIAS_VERTICAL: The width of this widget depends on its height.
	 *
	 * The default implementation of this method simply returns RBIAS_NONE.
	 */
	virtual EResizeBias ResizeBias() {
		return RBIAS_NONE;
	}
	
	enum EResizeBias {
		RBIAS_NONE,
		RBIAS_HORIZONTAL,
		RBIAS_VERTICAL
	};
	
	double EffAlpha() {
		let a = Alpha;
		if (Parent != null)
			a *= Parent.EffAlpha();
		return clamp(a, 0., 1.);
	}
	
	Vector2 EffScale() {
		if (Parent == null)
			return Scale;
		else
			return GUIUtil.Vec2Mul(Scale, Parent.EffScale());
	}
	
	double EffXScale() {
		let scale = EffScale();
		return scale.X;
	}
	
	double EffYScale() {
		let scale = EffScale();
		return scale.Y;
	}
	
	void LayoutAutoSize(Vector2 origin) {
		Rectangle rect;
		rect.Origin = origin;
		rect.Size = (-1, -1);
		Layout(rect);
	}
	
	private bool _LayoutDone;
	
	/**
	 * Lays out this widget and all descendants.
	 *
	 * This method is expected to resize and reposition this widget and any child widgets into the space allotted for this widget (as given in the “area” parameter).
	 *
	 * If you override this method but don't call Super.Layout, then you need to call the LayoutDone method before returning. If you do neither, your widget will still work, but it will waste a bunch of CPU time.
	 *
	 * This is called by the Draw method initially, and again whenever the RequestLayout method is called.
	 *
	 * If Resizable is true, and the given area has a negative size in one or both dimensions, then the preferred size will be used.
	 */
	virtual void Layout(Rectangle area) {
		/*
		Insets.Apply(area, EffScale());
		
		if (Resizable) {
			// Compute minimum and preferred sizes of this widget, accounting for its resize bias.
			let ms = MinimumSize(area.Size);
			
			// If the minimum size is broken, log a detailed diagnostic. Hopefully, this will be enough information for people to figure out where the layout problem is.
			if (ms.X > area.Size.X || ms.Y > area.Size.Y) {
				let message = String.Format(
					"\cr%s has a minimum size of (%f,%f), but is being told to draw in an area of size (%f,%f). Drawing into a larger area anyway, which may not look good! The top-level ancestor (%s) may need to be given more space, or have its layout otherwise changed.",
					ToString(),
					ms.X, ms.Y,
					area.Size.X, area.Size.Y,
					TopLevelAncestor().ToString()
				);
				
				if (Parent == null)
					message = message..("\n\cd  This widget is top-level.");
				if (Parent != null) {
					message = message..("\n\cd  List of ancestors, top-level last:");
					for (let w = Parent; w != null; w = w.Parent) {
						message = message.AppendFormat("\n\cd  %s", w.ToString());
						if (w.Parent == null)
							message = message.." [top]";
					}
				}
				
				Console.Printf(message);
			}
			
			//let ps = PreferredSize(area.Size);
			//let ar = ps.X / ps.Y;
			
			// Since we ask for preferred width/height based on resize bias (if any), this probably isn't necessary.
			// Compare width and height to half-pixel precision.
			if (ResizeProportionally && int(Bounds.Size.Y * ar * 2.) != int(Bounds.Size.X * 2.))) {
				Vector2 diff = (abs(Bounds.Size.X - ps.X) / Bounds.Size.X, abs(Bounds.Size.Y - ps.Y) / Bounds.Size.Y);
				
				if (diff.X > diff.Y)
					Bounds.Size.X = Bounds.Size.Y * ar;
				else
					Bounds.Size.Y = Bounds.Size.X / ar;
			}
		}
		*/
		
		if (Resizable)
			Bounds.Size = Insets.ApplySize(PreferredSize(area.Size), EffScale());
		
		Bounds.PositionIn(area, Align.X, Align.Y);
		LayoutDone();
		
		if (zsgui_debug_layout)
			Console.Printf("ZsGUI: Basic layout for %s done. Provided area was %s. Final bounds are %s.", ToString(), area.ToString(), Bounds.ToString());
	}
	
	/**
	 * This method needs to be called once the Layout method completes. If you override the Layout method and don't call Super.Layout, then you need to call this method.
	 */
	protected void LayoutDone() {
		_LayoutDone = true;
	}
	
	/**
	 * Invalidates the layout of this widget and all ancestors. Layout will be recomputed during the next Draw call.
	 *
	 * This needs to be called whenever there is a change (other than by the Layout method) to this widget's size, position, scale factor, or parent.
	 */
	void RequestLayout() {
		_LayoutDone = false;
		if (Parent != null)
			Parent.RequestLayout();
	}
	
	/**
	 * Returns a textual description of this widget. This is used when logging error messages.
	 */
	virtual String ToString() {
		return String.Format("%s %s", GetClassName(), ConsoleLabel);
	}
	
	virtual void Draw() {
		if (!_LayoutDone)
			Layout(Bounds);
	}
}
