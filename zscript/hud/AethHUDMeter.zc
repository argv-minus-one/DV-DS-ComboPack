class AethHUDMeter : AethHUDWidget {
	protected DynamicValueInterpolator ValueInterp, MaxValueInterp;
	int Value, MaxValue;
	HUDFont NumberFont, LabelFont;
	ColorSeq FillColors, OverfillColors;
	double Length;
	bool DrawValue, DrawMaxValue;
	Insets Insets;
	SlicedTextureSet Background, Frame;
	
	/** If this is set to a positive value, then the length of the meter is MaxValue * LengthScale + LengthAdd, and the Length field is the maximum length instead. */
	double LengthScale;
	double LengthAdd;
	
	override void Init(AetheriusHUD hud) {
		Super.Init(hud);
		DrawMaxValue = DrawValue = true;
		ValueInterp = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
		MaxValueInterp = DynamicValueInterpolator.Create(0, 0.15, 1, 6);
		NumberFont = HUDFont.Create("DQHUDFONTSML");
		LabelFont = NumberFont;
		Length = 200;
		Insets.Set(6, 7, 6, 7);
	}
	
	override void Tick() {
		ValueInterp.Update(Value);
		MaxValueInterp.Update(MaxValue);
	}
	
	private bool ComplainedAboutNoFillColors;
	
	override void Draw(double ticFrac) {
		if (FillColors.Colors.Size() < 1) {
			if (!ComplainedAboutNoFillColors) {
				Console.Printf("\cr%s has no fill colors!", GetClassName());
				ComplainedAboutNoFillColors = true;
			}
			return;
		}
		else
			ComplainedAboutNoFillColors = false;
		
		//// Compute size ////
		Rectangle frameArea;
		String numberText;
		frameArea.Origin = Pos;
		
		// DrawString doesn't accept a scale factor, so ignore scaling for this one.
		// TODO: Find some way to scale it anyway?
		[frameArea.Size, numberText] = NumberAreaSizeAndText();
		
		{
			Vector2 v = DesiredFillAreaSize();
			frameArea.Size = GraphicsUtils.Vec2Max(frameArea.Size, v);
		}
		
		if (Background != NULL) {
			Vector2 v = GraphicsUtils.Vec2Mul(Background.TotalTextureSize(), Scale);
			frameArea.Size = GraphicsUtils.Vec2Max(frameArea.Size, v);
		}
		
		if (Frame != NULL) {
			Vector2 v = GraphicsUtils.Vec2Mul(Frame.TotalTextureSize(), Scale);
			frameArea.Size = GraphicsUtils.Vec2Max(frameArea.Size, v);
		}
		
		Rectangle fillArea;
		fillArea.Copy(frameArea);
		Insets.Apply(fillArea, Scale);
		
		//// Draw ////
		if (Background != NULL)
			Background.DrawHUD(hud, frameArea, DrawFlags, Alpha, Scale);
		
		DrawMeterFill(
			fillArea, FillColors,
			clamp(double(ValueInterp.mCurrentValue) / double(MaxValueInterp.mCurrentValue), 0., 1.)
		);
		DrawMeterFill(
			fillArea, OverfillColors,
			clamp(double(ValueInterp.mCurrentValue - MaxValueInterp.mCurrentValue) / double(MaxValueInterp.mCurrentValue), 0., 1.)
		);
		
		if (Frame != NULL)
			Frame.DrawHUD(hud, frameArea, DrawFlags, Alpha, Scale);
		
		DrawCenterText(frameArea, NumberFont, numberText);
	}
	
	protected virtual Vector2 DesiredFillAreaSize() {
		double desiredLength;
		
		if (LengthScale > 0.)
			desiredLength = min(MaxValueInterp.GetValue() * LengthScale + LengthAdd, Length);
		else
			desiredLength = Length;
		
		return (desiredLength * Scale.X, double(FillColors.Colors.Size()) * Scale.Y);
	}
	
	protected virtual Vector2, String NumberAreaSizeAndText() {
		if (!DrawValue)
			return (0, 0), "";
		
		let text = BaseStatusBar.FormatNumber(ValueInterp.GetValue());
		if (DrawMaxValue)
			text = text .. "/" .. BaseStatusBar.FormatNumber(MaxValueInterp.GetValue());
		
		Vector2 size = (
			NumberFont.mFont.StringWidth(text .. "xx"),
			NumberFont.mFont.GetHeight()
		);
		
		// Text is not scaled by the engine, so don't apply the scale factor here.
		return (size.X, size.Y), text;
	}
	
	protected void DrawMeterFill(Rectangle area, ColorSeq colors, double lengthFrac) {
		if (length <= 0. || colors.Colors.Size() <= 0)
			return;
		
		Vector2 rowSize;
		rowSize.Y = area.Size.Y / colors.Colors.Size();
		double rowSlant = Scale.X;
		rowSize.X = (area.Size.X - (colors.Colors.Size() * rowSlant)) * lengthFrac;
		
		for (let i = 0, size = colors.Colors.Size(); i < size; i++) {
			Color c = GraphicsUtils.ApplyAlpha(colors.Colors[i], Alpha);
			
			hud.Fill(
				c,
				area.Origin.X + ((size - i) * rowSlant),
				area.Origin.Y + (i * rowSize.Y),
				rowSize.X,
				rowSize.Y,
				DrawFlags
			);
		}
	}
	
	protected void DrawCenterText(Rectangle frameArea, HUDFont font_, String text) {
		let relativeOrigin = frameArea.Origin;
		relativeOrigin.X += frameArea.Size.X / 2;
		relativeOrigin.Y += (frameArea.Size.Y / 2) - (NumberFont.mFont.GetHeight() / 2);
		
		hud.DrawString(
			font_,
			text,
			relativeOrigin,
			DrawFlags | BaseStatusBar.DI_TEXT_ALIGN_CENTER,
			Font.CR_WHITE,
			Alpha
		);
	}
}
