class AethHUDMeter : GUIRibbonMeter {
	GUIEdgeGroup Frame, FrameGlow, BackgroundGlass;
	GUISwitchGroup DrawOverSwitcher;
	float FrameGlowOpacity;
	AethHUDMeter_MaxValueChangeEffect MaxValueChangeEffect;
	
	override void Init(GUIWidget parent) {
		Super.Init(parent);
		
		Frame = new("GUIEdgeGroup");
		Frame.ConsoleLabel = ConsoleLabel..".Frame";
		Frame.Init(self);
		Frame.UseTextureSet("SLAMFRM");
		
		FrameGlow = new("GUIEdgeGroup");
		FrameGlow.ConsoleLabel = ConsoleLabel..".FrameGlow";
		FrameGlow.Init(self);
		FrameGlow.UseTextureSet("SLAMFRG");
		
		SetFrameColors();
		
		let DrawOverStack = new("GUIStackGroup");
		DrawOverStack.ConsoleLabel = ConsoleLabel..".DrawOverStack";
		DrawOverStack.Init(self);
		DrawOverStack.Children.Resize(2);
		DrawOverStack.Children[0] = Frame;
		DrawOverStack.Children[1] = FrameGlow;
		DrawOver = DrawOverStack;
		
		BackgroundGlass = new("GUIEdgeGroup");
		BackgroundGlass.ConsoleLabel = ConsoleLabel..".BackgroundGlass";
		BackgroundGlass.Init(self);
		BackgroundGlass.UseTextureSet("SLAMBKG");
		DrawUnder = BackgroundGlass;
		
		MainFill.Skew = 1;
		OverFill.Skew = 1;
		FillInsets.Set(6, 8, 6, 8);
		NumberText.Insets.Set(6, 15, 6, 15);
		
		MaxValueChangeEffect = new("AethHUDMeter_MaxValueChangeEffect");
		MaxValueChangeEffect.ConsoleLabel = ConsoleLabel..".MaxValueChangeEffect";
		MaxValueChangeEffect.Init(self);
		
		let hudFont = Font.GetFont('DQHUDFONTSML');
		NumberText.TextFont = hudFont;
		LabelText.TextFont = hudFont;
		MaxValueChangeEffect.TextFont = hudFont;
		NumberText.FontBaseline = LabelText.FontBaseline = MaxValueChangeEffect.FontBaseline = 22;
	}
	
	override void Tick() {
		Super.Tick();
		MaxValueChangeEffect.Tick();
	}
	
	void SetFrameColors(Color normalColor = 0xff000000, int normalPaletteColor = -1, Color criticalColor = 0xffff0000, int criticalPaletteColor = -1) {
		for (let col = 0; col < 3; col++)
		for (let row = 0; row < 3; row++) {
			let nw = Frame.Children[col][row], cw = FrameGlow.Children[col][row];
			
			if (nw is "GUIImage") {
				GUIImage(nw).AlphaBlend = true;
				GUIImage(nw).AlphaBlendColor.Set(normalColor, normalPaletteColor);
			}
			
			if (cw is "GUIImage") {
				GUIImage(cw).AlphaBlend = true;
				GUIImage(cw).AlphaBlendColor.Set(criticalColor, criticalPaletteColor);
			}
		}
	}
	
	private Array<GUIImage> FrameGlowImages;
	
	override void Layout() {
		Super.Layout();
		
		FrameGlowImages.Clear();
		for (let col = 0; col < 3; col++)
		for (let row = 0; row < 3; row++)
		if (FrameGlow.Children[col][row] is "GUIImage")
			FrameGlowImages.Push(GUIImage(FrameGlow.Children[col][row]));
	}
	
	override void Draw() {
		for (let i = 0, l = FrameGlowImages.Size(); i < l; i++)
			FrameGlowImages[i].Opacity = FrameGlowOpacity;
		
		Super.Draw();
		MaxValueChangeEffect.Draw();
	}
}

class AethHUDMeter_MaxValueChangeEffect : GUIText {
	override void Init(GUIWidget parent) {
		Super.Init(parent);
		IgnoreOverflow = true;
		Align.X = XALIGN_LEFT;
		TextColor = Font.CR_GOLD;
	}
	
	/* Generated by this Scala program:
	 *
	 * import scala.math._
	 * def f(x: Double) = pow(x * 1.8 - 0.8, 3).toFloat
	 * val points = 0.0 to 1.0 by (1.0 / (35 * 4))
	 * val samples = points map f
	 * println(samples mkString ", ")
	 *
	 * Underlying math: y = (x*1.8-0.8)^3
	 */
	static const float AnimFrameOffsets[] = {
		-0.23730469, -0.21817759, -0.2003042, -0.18362184, -0.16807, -0.1535902, -0.14012605, -0.12762314, -0.11602906, -0.10529335, -0.09536743, -0.0862046, -0.07776, -0.06999054, -0.06285491, -0.056313515, -0.050328437, -0.044863418, -0.0398838, -0.035356507, -0.03125, -0.02753424, -0.024180654, -0.021162096, -0.018452812, -0.016028404, -0.013865791, -0.0119431745, -0.01024, -0.008736923, -0.0074157715, -0.006259506, -0.0052521876, -0.004378939, -0.0036259082, -0.0029802322, -0.00243, -0.001964216, -0.0015727637, -0.0012463687, -9.765625E-4, -7.5564545E-4, -5.766504E-4, -4.3330598E-4, -3.2E-4, -2.3174286E-4, -1.6413086E-4, -1.1330963E-4, -7.59375E-5, -4.9148864E-5, -3.0517578E-5, -1.8020324E-5, -1.0E-5, -5.1290895E-6, -2.373047E-6, -9.536743E-7, -3.125E-7, -7.415772E-8, -9.765625E-9, -3.0517577E-10, -0.0, 3.0517577E-10, 9.765625E-9, 7.415772E-8, 3.125E-7, 9.536743E-7, 2.373047E-6, 5.1290895E-6, 1.0E-5, 1.8020324E-5, 3.0517578E-5, 4.9148864E-5, 7.59375E-5, 1.1330963E-4, 1.6413086E-4, 2.3174286E-4, 3.2E-4, 4.3330598E-4, 5.766504E-4, 7.5564545E-4, 9.765625E-4, 0.0012463687, 0.0015727637, 0.001964216, 0.00243, 0.0029802322, 0.0036259082, 0.004378939, 0.0052521876, 0.006259506, 0.0074157715, 0.008736923, 0.01024, 0.0119431745, 0.013865791, 0.016028404, 0.018452812, 0.021162096, 0.024180654, 0.02753424, 0.03125, 0.035356507, 0.0398838, 0.044863418, 0.050328437, 0.056313515, 0.06285491, 0.06999054, 0.07776, 0.0862046, 0.09536743, 0.10529335, 0.11602906, 0.12762314, 0.14012605, 0.1535902, 0.16807, 0.18362184, 0.2003042, 0.21817759, 0.23730469, 0.25775033, 0.27958155, 0.3028676, 0.32768, 0.3540926, 0.38218158, 0.41202548, 0.44370532, 0.4773045, 0.51290894, 0.5506071, 0.59049, 0.63265127, 0.6771871, 0.72419643, 0.77378094, 0.826045, 0.8810957, 0.9390431, 1.0
	};
	
	/* Generated by this Scala program:
	 *
	 * import scala.math._
	 * def f(x: Double) = (1.0 - pow((x - 0.5) * 2.0, 8)).toFloat
	 * val points = 0.0 to 1.0 by (1.0 / (35 * 4))
	 * val samples = points map f
	 * println(samples mkString ", ")
	 *
	 * Underlying math: y = 1-((x-0.5)*2)^8
	 */
	static const float AnimFrameAlphas[] = {
		0.0, 0.108731814, 0.20697482, 0.29560852, 0.37545007, 0.4472579, 0.51173514, 0.5695328, 0.621253, 0.667452, 0.70864284, 0.7452983, 0.7778534, 0.80670774, 0.8322278, 0.8547496, 0.8745803, 0.89200026, 0.90726525, 0.9206079, 0.93223965, 0.942352, 0.9511184, 0.9586954, 0.9652241, 0.9708314, 0.97563106, 0.9797249, 0.9832038, 0.98614883, 0.9886317, 0.99071604, 0.99245805, 0.99390703, 0.99510634, 0.99609375, 0.9969022, 0.9975603, 0.9980927, 0.9985205, 0.9988619, 0.9991322, 0.99934465, 0.99951005, 0.9996378, 0.9997353, 0.999809, 0.99986416, 0.9999048, 0.9999344, 0.9999556, 0.99997056, 0.99998087, 0.9999879, 0.99999255, 0.9999955, 0.99999744, 0.99999857, 0.9999992, 0.99999964, 0.9999998, 0.99999994, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.99999994, 0.9999998, 0.99999964, 0.9999992, 0.99999857, 0.99999744, 0.9999955, 0.99999255, 0.9999879, 0.99998087, 0.99997056, 0.9999556, 0.9999344, 0.9999048, 0.99986416, 0.999809, 0.9997353, 0.9996378, 0.99951005, 0.99934465, 0.9991322, 0.9988619, 0.9985205, 0.9980927, 0.9975603, 0.9969022, 0.99609375, 0.99510634, 0.99390703, 0.99245805, 0.99071604, 0.9886317, 0.98614883, 0.9832038, 0.9797249, 0.97563106, 0.9708314, 0.9652241, 0.9586954, 0.9511184, 0.942352, 0.93223965, 0.9206079, 0.90726525, 0.89200026, 0.8745803, 0.8547496, 0.8322278, 0.80670774, 0.7778534, 0.7452983, 0.70864284, 0.667452, 0.621253, 0.5695328, 0.51173514, 0.4472579, 0.37545007, 0.29560852, 0.20697482, 0.108731814, 4.0856207E-14
	};
	
	private int Change, AnimFrame, PrevMaxValue;
	private double AnimOriginX, AnimScaleX;
	private bool AnimNeedsInit;
	
	override void Tick() {
		let hm = AethHUDMeter(self.Parent);
		if (!hm) return;
		
		if (!PrevMaxValue || PrevMaxValue > hm.MaxValue) {
			PrevMaxValue = hm.MaxValue;
			return;
		}
		else if (PrevMaxValue < hm.MaxValue) {
			Change += hm.MaxValue - PrevMaxValue;
			PrevMaxValue = hm.MaxValue;
			Text = String.Format("%+d", Change);
			AnimNeedsInit = true;
		}
		
		if (Change) {
			if (AnimFrame == AnimFrameOffsets.Size() - 1) {
				// Animation finished.
				Change = 0;
				AnimFrame = -1;
			}
			else {
				AnimFrame++;
				
				if (AnimNeedsInit) {
					// Animation starting.
					AnimNeedsInit = false;
					
					// Initialize position and animation scale. Don't let these change even if layout changes.
					AnimScaleX = hm.Bounds.Size.X * .5;
					AnimOriginX =
						hm.DrawValue && hm.NumberText?
						hm.NumberText.CurrentTextBounds.Right() + GUIText.OneChWidth(TextFont) :
						hm.Bounds.Origin.X + AnimScaleX;
					
					// Initialize bounds fields that don't change during the animation.
					Bounds.Origin.Y = hm.Bounds.Origin.Y;
					Bounds.Size.Y = hm.Bounds.Size.Y;
					Bounds.Size.X = DOUBLE_EPSILON;
				}
			}
		}
		
		if (AnimFrame != -1) {
			Bounds.Origin.X = AnimOriginX + (AnimFrameOffsets[AnimFrame] * AnimScaleX);
			Alpha = AnimFrameAlphas[AnimFrame];
			Layout();
		}
		else
			Alpha = 0;
	}
}
