extend class SceptreOfEmpyreaZSC
{
	static const uint16 SceptreDamageMin[] =
	{
		275, 280, 290,  320,  340, 365,
		425, 425, 545,  590,  640, 750,
		810, 875, 1015, 1015, 1255
	};
	
	static const uint16 SceptreDamageMax[] =
	{
		325, 330,  340,  370,  390, 415,
		475, 475,  595,  640,  690, 800,
		860, 925, 1065, 1065, 1305
	};
	
	static const uint8 SceptreRange[] =
	{
		130, 133, 135, 138, 140, 145,
		148, 153, 160, 165, 168, 170,
		173, 178, 180, 185, 192
	};
	
	const FullAttackAngle = 120.;
	
	protected PuffTracker puffs;
	
	action void A_SceptreAttack(
		int range = -1,
		int damageMin = -1,
		int damageMax = -1,
		Class<Actor> puffType = "SceptrePuff",
		double swingAngle = 0,
		double swingWidth = SceptreOfEmpyreaZSC.FullAttackAngle,
		bool puffWalls = true,
		bool rememberAlreadyHitActors = true,
		int enabledEffects = 0xFFFFFFFF
	) {
		if (range == -1)
			range = invoker.SceptreRange[invoker.SceptreLevel];
		if (damageMin == -1)
			damageMin = invoker.SceptreDamageMin[invoker.SceptreLevel];
		if (damageMax == -1)
			damageMax = invoker.SceptreDamageMax[invoker.SceptreLevel];
		
		class<Actor> replacedPuffType = GetReplacement(puffType);
		let puffDefaults = GetDefaultByType(replacedPuffType);
		bool actorsHit = false;
		
		let it = BlockThingsIterator.Create(self, range);
		while (it.Next())
		{
			let mo = it.thing;
			
			if (
				(mo.bMissile && (
					mo.target == self ||
					(mo.target != null && !self.isHostile(mo.target))
				)) ||
				!AetheriusBaseZSC.CanHitWith(self, mo, replacedPuffType, invoker)
			)
				continue;
			
			let angle = AngleTo(mo);
			if (absangle(angle, self.Angle + swingAngle) > SwingAngleStep)
				continue;
			
			// TODO: Check vertical angle (pitch)? Not needed for the Sceptre because its max angle is wider than 180° anyway, but…
			
			if (rememberAlreadyHitActors)
			{
				if (invoker.ActorsHitThisSwing.Find(mo) < invoker.ActorsHitThisSwing.Size())
					continue;
				else
					invoker.ActorsHitThisSwing.Push(mo);
			}
			
			int damage;
			if (damageMin)
			{
				if (damageMax)
					damage = random(damageMin, damageMax);
				else
					damage = damageMin;
			}
			else if (damageMax)
				damage = damageMax;
			else
				damage = 0;
			
			let shouldBleed =
				damage > 0 &&
				!mo.bMissile &&
				!mo.bNoBlood &&
				!mo.bInvulnerable &&
				!mo.bDormant &&
				!puffDefaults.bBloodlessImpact;
			
			let shouldPuff =
				!shouldBleed ||
				puffDefaults.bPuffOnActors;
			
			Actor puff;
			bool puffIsNew;
			
			[puff, puffIsNew] = invoker.puffs.PlaceAtNearestPoint(
				self, mo, replacedPuffType,
				flags: PF_HITTHING | PF_MELEERANGE |
				(shouldBleed? PF_HITTHINGBLEED : 0) |
				(shouldPuff? 0 : PF_TEMPORARY),
				wep: invoker
			);
			
			if (!puff.CanCollideWith(mo, false) || !mo.CanCollideWith(puff, true))
			{
				if (puffIsNew)
					puff.Destroy();
				continue;
			}
			
			{
				let sp = SceptrePuff(puff);
				if (sp)
				{
					sp.SceptreLevel = invoker.SceptreLevel;
					sp.EnabledEffects = enabledEffects;
					
					if (!puffIsNew)
						sp.Refresh();
				}
			}
			
			int actualDamage = 0;
			if (mo.bShootable && damage)
			{
				let modt = mo.bDontThrust;
				mo.bDontThrust = true;
				actualDamage = mo.DamageMobj(
					puff,
					self,
					random(damageMin, damageMax),
					invoker.DamageType,
					flags: DMG_INFLICTOR_IS_PUFF | (invoker.bPierceArmor? DMG_NO_ARMOR : 0),
					angle: puff.Angle
				);
				mo.bDontThrust = modt;
				
				if (puffDefaults.PoisonDamage > 0)
					mo.PoisonMobj(puff, self, puffDefaults.PoisonDamage, puffDefaults.PoisonDuration, puffDefaults.PoisonPeriod, puffDefaults.PoisonDamageType);
			}
			
			if (shouldBleed)
			{
				if (invoker.bAxeBlood || invoker.bBloodSplatter)
					mo.BloodSplatter(puff.Pos, puff.Angle, invoker.bAxeBlood);
				else
					mo.SpawnBlood(puff.Pos, puff.Angle, actualDamage);
			}
			
			if (!shouldPuff)
				puff.Destroy();
			
			let deflectAngle = Normalize180(angle + frandom(-45., 45.));
			
			if (mo.bMissile)
			{
				mo.Vel.XY = AngleToVector(deflectAngle, mo.Speed * frandom(.6, 1.2));
				
				if (!mo.bFloorHugger && !mo.bCeilingHugger)
					mo.Vel.Z = frandom(-8., 8.);
			}
			else if (!mo.bDontThrust)
			{
				let deflectSpeed = min(
					(1. + (double(invoker.SceptreLevel) ** 2)) / sqrt(double(mo.Mass)),
					frandom(27, 33)
				);
				mo.Thrust(deflectSpeed, deflectAngle);
			}
			
			if (dvdsdebug_showmeleeinformation) Console.Printf(
				"%s's %s hit %s for %d %s damage, resulting in %s.",
				self.GetClassName(),
				invoker.GetClassName(),
				mo.GetClassName(),
				actualDamage, invoker.DamageType,
				(shouldPuff && shouldBleed)?
					String.Format("a %s and blood", puff.GetClassName()) :
					shouldPuff? String.Format("a %s", puff.GetClassName()) :
					shouldBleed? "blood" :
					"neither a puff nor blood"
			);
			
			actorsHit = true;
		}
		
		if (!actorsHit && puffWalls)
		{
			let wallHitAngle = Normalize180(self.Angle + swingAngle);
			
			let puff = LineAttack(
				Normalize180(self.Angle + swingAngle),
				range,
				AimLineAttack(swingAngle, range),
				random(damageMin, damageMax),
				puffDefaults.DamageType,
				puffType
			);
			
			if (puff is "SceptrePuff")
				SceptrePuff(puff).SceptreLevel = invoker.SceptreLevel;
		}
	}
}
