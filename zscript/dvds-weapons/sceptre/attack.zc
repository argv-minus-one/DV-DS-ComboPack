extend class SceptreOfEmpyreaZSC
{
	static const uint8 SceptreRange[] =
	{
		130, 133, 135, 138, 140, 145,
		148, 153, 160, 165, 168, 170,
		173, 178, 180, 185, 192
	};
	
	const FullAttackAngle = 120.;
	
	protected PuffTracker puffs;
	
	action void A_SceptreAttack(
		int damage,
		int damageDeviation,
		int range = -1,
		Class<Actor> puffType = "SceptrePuff",
		double swingAngle = 0,
		double swingWidth = SceptreOfEmpyreaZSC.FullAttackAngle,
		bool puffWalls = true,
		bool rememberAlreadyHitActors = true,
		int enabledEffects = 0xFFFFFFFF
	) {
		if (range == -1)
			range = invoker.SceptreRange[invoker.SceptreLevel];
		
		class<Actor> replacedPuffType = GetReplacement(puffType);
		let puffDefaults = GetDefaultByType(replacedPuffType);
		bool actorsHit = false;
		
		let it = BlockThingsIterator.Create(self, range);
		while (it.Next())
		{
			let mo = it.thing;
			
			if (
				(mo.bMissile && (
					mo.target == self ||
					(mo.target != null && !self.isHostile(mo.target))
				)) ||
				!AetheriusBaseZSC.CanHitWith(self, mo, replacedPuffType, invoker)
			)
				continue;
			
			let angle = AngleTo(mo);
			if (absangle(angle, self.Angle + swingAngle) > SwingAngleStep)
				continue;
			
			// TODO: Check vertical angle (pitch)? Not needed for the Sceptre because its max angle is wider than 180° anyway, but…
			
			if (rememberAlreadyHitActors)
			{
				if (invoker.ActorsHitThisSwing.Find(mo) < invoker.ActorsHitThisSwing.Size())
					continue;
				else
					invoker.ActorsHitThisSwing.Push(mo);
			}
			
			let damageThisHit = damage + random(-damageDeviation, damageDeviation);
			
			let shouldBleed =
				damageThisHit > 0 &&
				!mo.bMissile &&
				!mo.bNoBlood &&
				!mo.bInvulnerable &&
				!mo.bDormant &&
				!puffDefaults.bBloodlessImpact;
			
			let shouldPuff =
				!shouldBleed ||
				puffDefaults.bPuffOnActors;
			
			Actor puff;
			bool puffIsNew;
			
			[puff, puffIsNew] = invoker.puffs.PlaceAtNearestPoint(
				self, mo, replacedPuffType,
				flags: PF_HITTHING | PF_MELEERANGE |
				(shouldBleed? PF_HITTHINGBLEED : 0) |
				(shouldPuff? 0 : PF_TEMPORARY),
				wep: invoker
			);
			
			if (!puff.CanCollideWith(mo, false) || !mo.CanCollideWith(puff, true))
			{
				if (puffIsNew)
					puff.Destroy();
				continue;
			}
			
			{
				let sp = SceptrePuff(puff);
				if (sp)
				{
					sp.SceptreLevel = invoker.SceptreLevel;
					sp.EnabledEffects = enabledEffects;
					
					if (!puffIsNew)
						sp.Refresh();
				}
			}
			
			int actualDamage = 0;
			if (mo.bShootable && damage)
			{
				let modt = mo.bDontThrust;
				mo.bDontThrust = true;
				actualDamage = mo.DamageMobj(
					puff,
					self,
					damageThisHit,
					invoker.DamageType,
					flags: DMG_INFLICTOR_IS_PUFF | (invoker.bPierceArmor? DMG_NO_ARMOR : 0),
					angle: puff.Angle
				);
				mo.bDontThrust = modt;
				
				if (puffDefaults.PoisonDamage > 0)
					mo.PoisonMobj(puff, self, puffDefaults.PoisonDamage, puffDefaults.PoisonDuration, puffDefaults.PoisonPeriod, puffDefaults.PoisonDamageType);
			}
			
			if (shouldBleed)
			{
				if (invoker.bAxeBlood || invoker.bBloodSplatter)
					mo.BloodSplatter(puff.Pos, puff.Angle, invoker.bAxeBlood);
				else
					mo.SpawnBlood(puff.Pos, puff.Angle, actualDamage);
			}
			
			if (!shouldPuff)
				puff.Destroy();
			
			let deflectAngle = Normalize180(angle + frandom(-45., 45.));
			
			if (mo.bMissile)
			{
				mo.Vel.XY = AngleToVector(deflectAngle, mo.Speed * frandom(.6, 1.2));
				
				if (!mo.bFloorHugger && !mo.bCeilingHugger)
					mo.Vel.Z = frandom(-8., 8.);
			}
			else if (!mo.bDontThrust)
			{
				let deflectSpeed = min(
					(1. + (double(invoker.SceptreLevel) ** 2)) / sqrt(double(mo.Mass)),
					frandom(27, 33)
				);
				mo.Thrust(deflectSpeed, deflectAngle);
			}
			
			if (dvdsdebug_showmeleeinformation) Console.Printf(
				"%s's %s hit %s for %d %s damage, resulting in %s.",
				self.GetClassName(),
				invoker.GetClassName(),
				mo.GetClassName(),
				actualDamage, invoker.DamageType,
				(shouldPuff && shouldBleed)?
					String.Format("a %s and blood", puff.GetClassName()) :
					shouldPuff? String.Format("a %s", puff.GetClassName()) :
					shouldBleed? "blood" :
					"neither a puff nor blood"
			);
			
			actorsHit = true;
		}
		
		if (!actorsHit && puffWalls)
		{
			let wallHitAngle = Normalize180(self.Angle + swingAngle);
			
			let puff = LineAttack(
				Normalize180(self.Angle + swingAngle),
				range,
				AimLineAttack(swingAngle, range),
				0,
				puffDefaults.DamageType,
				puffType
			);
			
			if (puff is "SceptrePuff")
				SceptrePuff(puff).SceptreLevel = invoker.SceptreLevel;
		}
	}
	
	/** Computes damage. This accounts for buffs, debuffs, stats, etc. Used by A_SceptreAttack. */
	int, int ComputeDamage() const
	{
		int dmg, dev;
		
		if (dvdsdebug_showmeleeinformation)
			Console.Printf("Computing damage for Sceptre:");
		
		dmg = 300 + 3.8 * SceptreLevel * SceptreLevel;
		dev = 50;
		if (dvdsdebug_showmeleeinformation)
			Console.Printf("    Level %d: %d +- %d", SceptreLevel, dmg, dev);
		
		// [STRIFE] Stamina Upgrades
		{
			let strifeStamMult = (4. + CallACS("MiscVarCheckDECORATE", 317)) * (1. / 4.);
			dmg *= strifeStamMult;
			dev *= strifeStamMult;
			
			if (dvdsdebug_showmeleeinformation)
				Console.Printf("    Strife stamina upgrades (%d): %fx", CallACS("MiscVarCheckDECORATE", 317), strifeStamMult);
		}
		
		// Strength Stat Check
		{
			let ownerStrength = CallACS("MiscVarCheckDECORATE", 35);
			
			// Here, we use >> 5 instead of / 32, and >> 6 instead of / 64, because it's equivalent and faster.
			let strAdd = (((SceptreLevel * (4 + (ownerStrength >> 5))) + (16 + (SceptreLevel * (2 + (ownerStrength >> 6))))) * ownerStrength);
			let strWiden = (16 + SceptreLevel * (2 + (ownerStrength >> 6)));
			
			dmg += strAdd;
			dev += strWiden;
			
			if (dvdsdebug_showmeleeinformation)
				Console.Printf("    Strength (%d): +(%d +- %d)", ownerStrength, strAdd, strWiden);
		}
		
		// Berserk Check
		if (Owner.CountInv("PowerStrength"))
		{
			dmg *= 10;
			dev *= 10;
			
			if (dvdsdebug_showmeleeinformation)
				Console.Printf("    Berserk: 10x");
		}
		else
		{
			if (dvdsdebug_showmeleeinformation)
				Console.Printf("    Not berserk");
		}
		
		// StamUp Check
		{
			let stamUpRank = CallACS("MiscVarCheckDECORATE", 10005);
			let stamUpExRank = CallACS("MiscVarCheckDECORATE", 10006);
			let perkFactor = 1. + stamUpRank * .075 + stamUpExRank * .1875;
			
			dmg *= perkFactor;
			dev *= perkFactor;
			
			if (dvdsdebug_showmeleeinformation)
				Console.Printf("    Stamina perks (ranks %d, %d): %fx", stamUpRank, stamUpExRank, perkFactor);
		}
		
		if (dvdsdebug_showmeleeinformation)
			Console.Printf("    Result (Sceptre standard attack damage): %d +- %d", dmg, dev);
		
		// In the earlier Sceptre code, the Sceptre could hit the same monster up to 7 times per swing, and each hit also caused splash damage. This version only hits any monster once per swing, so we compensate by multiplying total damage by 4.
		return dmg * 4, dev * 4;
	}
}

class SceptreOfEmpyreaHitMonitor : StaticEventHandler
{
	override void WorldThingDamaged(WorldEvent evt)
	{
		if (evt.Damage > 0)
			GiveExpForHit(evt, evt.DamageSource, false);
	}
	
	override void WorldThingDied(WorldEvent evt)
	{
		if (evt.Inflictor)
			GiveExpForHit(evt, evt.Inflictor.Target, true);
	}
	
	private void GiveExpForHit(WorldEvent evt, Actor damageSource, bool isKill)
	{
		if (!(evt.Inflictor is 'SceptrePuff') || damageSource is 'Inventory')
			return;
		
		let sceptre = SceptreOfEmpyreaZSC(damageSource.FindInventory('SceptreOfEmpyreaZSC'));
		if (!sceptre || sceptre.Amount <= 0)
			return;
		
		sceptre.AwardSceptreHitExperience(evt.Thing, isKill);
	}
	
	override void RenderOverlay(RenderEvent evt)
	{
		// TODO: Remove this once the ACS HUD is updated.
		if (!playeringame[consoleplayer] || !players[consoleplayer].mo || !(players[consoleplayer].ReadyWeapon is 'SceptreOfEmpyreaZSC'))
			return;
		
		let mo = players[consoleplayer].mo;
		
		let sceptre = mo.FindInventory('SceptreOfEmpyreaZSC');
		if (!sceptre || !sceptre.Amount)
			return;
		
		Font f = Font.FindFont('SmallFont');
		let text = String.Format("Sceptre\nExp: % 7d\nLevel: % 2d", mo.CountInv('SceptreOfEmpyreaExperience'), mo.CountInv('SceptreOfEmpyreaLevel'));
		
		Screen.DrawText(
			f,
			Font.CR_UNTRANSLATED,
			Screen.GetWidth() - (4 * CleanXFac) - (f.StringWidth(text) * CleanXFac),
			4 * CleanYFac,
			text,
			DTA_CleanNoMove, true,
			DTA_Shadow
		);
	}
}
