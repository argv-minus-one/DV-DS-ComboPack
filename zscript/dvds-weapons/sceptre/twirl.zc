extend class SceptreOfEmpyreaZSC
{
	SceptreTwirling Twirling;
	protected float TwirlMPCostAccum, TwirlStamCostAccum;
	
	protected bool TwirlDeductCosts(bool showMessage = true)
	{
		if (TwirlMPCostAccum >= 1. && !AetheriusACS.CheckMP(TwirlMPCostAccum))
		{
			if (showMessage && Owner)
				Owner.A_Print("Not enough MP!");
			return false;
		}
		
		if (TwirlStamCostAccum >= 1. && !AetheriusACS.TryTakeStamina(TwirlStamCostAccum))
		{
			if (showMessage && Owner)
				Owner.A_Print("Not enough stamina!");
			return false;
		}
		else
			TwirlStamCostAccum -= floor(TwirlStamCostAccum);
		
		// Check MP, then check+take stamina, then take MP. That way, if Flora doesn't have enough of either, she won't lose any of either.
		AetheriusACS.TakeMP(TwirlMPCostAccum);
		TwirlMPCostAccum -= floor(TwirlMPCostAccum);
		
		return true;
	}
	
	protected void TwirlUpdate()
	{
		TwirlMPCostAccum +=      SceptreTwirlMPCost     [SceptreLevel];
		TwirlStamCostAccum +=    SceptreTwirlStaminaCost[SceptreLevel];
		Twirling.FullSpinRate =  TwirlSpinRate          [SceptreLevel];
		Twirling.ActiveSound =   TwirlSound             [SceptreLevel];
	}
	
	states
	{
		AltFire:
			#### # 1 A_SceptreLower(andThen: 1, speed: 6);
			wait;
			
			FLHS B 0 A_WeaponOffset(0, WEAPONBOTTOM);
			#### # 1 A_AnimateOffset(1, (0, WEAPONTOP), speed: 20);
			wait;
			
			#### # 0 {
				Class<Actor> rc = GetReplacement('SceptreTwirling');
				
				if (!(rc is 'SceptreTwirling'))
				{
					Console.Printf("\cg%s: Class %s, which replaces SceptreTwirling, is not a subtype of SceptreTwirling! Falling back to using stock SceptreTwirling instead of this replacement.", invoker.GetClassName(), rc.GetClassName());
					rc = 'SceptreTwirling';
				}
				
				// Spawn the twirling sceptre.
				invoker.Twirling = SceptreTwirling(Spawn(rc, pos: Pos, replace: NO_REPLACE));
				invoker.Twirling.master = self;
			}
			
		Twirling:
			FLHS A 0 A_JumpIf(!invoker.TwirlDeductCosts() || !invoker.Twirling, 'TwirlStop');
			#### # 1 { A_SceptreDefend(); invoker.TwirlUpdate(); }
			#### # 0 A_ReFire('Twirling');
		
		TwirlStop:
			// Start the recall animation, then wait for it to finish.
			#### # 0
			{
				if (invoker.Twirling)
					invoker.Twirling.Recall();
				invoker.TwirlStamCostAccum = invoker.TwirlMPCostAccum = 0.;
			}
			
			#### # 1 A_JumpIf(!invoker.Twirling || invoker.Twirling.ReadyToCatch, 1);
			wait;
			
			FLHS B 0 {
				if (invoker.Twirling)
				{
					invoker.Twirling.Destroy();
					invoker.Twirling = null;
				}
			}
			
			// Lower Flora's hand.
			#### # 1 A_AnimateOffset(1, (0, WEAPONBOTTOM), speed: 20);
			wait;
			
			#### # 0;
			goto Select;
	}
}

class SceptreTwirling : Actor
{
	default
	{
		+INTERPOLATEANGLES;
		+FLATSPRITE;
		+ROLLSPRITE;
		+ROLLCENTER;
		+NOINTERACTION;
		+BRIGHT;
		Speed 2;
		Height 40;
		Radius 40;
		Scale .08888888888888889; // (40 / 450) in double precision
		ActiveSound 'SceptreTwirl1';
		SceptreTwirling.SpinAccelMult (1./4.);
		SceptreTwirling.SpinRate 25;
		SceptreTwirling.TouchPos 14, -6, 0;
		SceptreTwirling.TouchAngle 180;
		SceptreTwirling.TwirlPos 30, 0, 0;
	}
	
	float SpinAccelMult;
	property SpinAccelMult: SpinAccelMult;
	
	float FullSpinRate;
	// How fast the Sceptre spins at full speed (in degrees per tic).
	property SpinRate: FullSpinRate;
	
	double TouchPosX, TouchPosY, TouchPosZ;
	// When the Sceptre is touching Flora's hand, this is the offset from her position relative to her yaw and pitch.
	property TouchPos: TouchPosX, TouchPosY, TouchPosZ;
	
	double TouchAngle;
	// When the Sceptre is touching Flora's hand, this is what its roll should be.
	property TouchAngle: TouchAngle;
	
	double TwirlPosX, TwirlPosY, TwirlPosZ;
	// Like TouchPos, but for when the Sceptre is out and twirling.
	property TwirlPos: TwirlPosX, TwirlPosY, TwirlPosZ;
	
	bool ReadyToCatch;
	protected ActorSpinner RotControl;
	private int SpawnTic;
	
	override void PostBeginPlay()
	{
		if (!master)
		{
			Console.Printf("\cr%s spawned without a master!", GetClassName());
			Destroy();
			return;
		}
		
		SpawnTic = gametic;
		Roll = TouchAngle;
		RotControl.mo = self;
	}
	
	override void Tick()
	{
		if (!master || master.bDestroyed || (master.bShootable && master.Health <= 0))
		{
			Destroy();
			return;
		}
		
		RotControl.Accel = SpinAccelMult * FullSpinRate;
		let prevRoll = Roll;
		RotControl.Tick();
		
		Super.Tick();
		
		// Play a sound when crossing angle 0 at speed.
		if (
			RotControl.Vel > 15. && (
				((prevRoll < 0. && prevRoll > -90.) && (Roll >= 0. && Roll < 90.)) ||
				((prevRoll > 0. && prevRoll < 90.) && (Roll <= 0. && Roll > -90.))
			)
		)
			A_PlaySound(ActiveSound);
		
		SetSpriteAndFrame();
		
		{
			// Move the twirling Sceptre toward/away from the wielder, depending on its angular velocity.
			Vector3 newPos;
			
			if (FullSpinRate != 0.) // Avoid dividing by zero.
			{
				let twirlPos = (TwirlPosX, TwirlPosY, TwirlPosZ);
				let touchPos = (TouchPosX, TouchPosY, TouchPosZ);
				let delta = twirlPos - touchPos;
				newPos = touchPos + delta.Unit() * delta.Length() * clamp(RotControl.Vel / FullSpinRate, 0., 1.);
			}
			else
				newPos = (TwirlPosX, TwirlPosY, TwirlPosZ);
			
			// If the wielder is a player character, align with its eyes. Otherwise, align with its height center.
			if (master.player)
				newPos.Z += master.player.viewheight;
			else
				newPos.Z += master.Height * .5;
			
			// Don't interpolate on the tic it was spawned. Doing so may create ugly graphical artifacts for a frame or two, since it's interpolating from an invalid state.
			let interpolate = gametic != SpawnTic;
			
			Warp(master, newPos.X, newPos.Y, newPos.Z, flags: (interpolate? WARPF_INTERPOLATE : 0)|WARPF_COPYPITCH|WARPF_COPYVELOCITY|WARPF_BOB|WARPF_NOCHECKPOSITION, pitch: 90.);
		}
	}
	
	protected action void A_SpinUp()
	{
		invoker.RotControl.CancelLanding();
		invoker.RotControl.DesVel = invoker.FullSpinRate;
	}
	
	protected action void A_SpinDown()
	{
		invoker.RotControl.DesVel = 0;
		invoker.RotControl.LandAt(invoker.TouchAngle);
	}
	
	void Recall()
	{
		SetStateLabel('Recall');
	}
	
	protected virtual void SetSpriteAndFrame()
	{
		state st;
		
		if (vid_rendermode == 4)
		{
			// If using the OpenGL renderer, use the fancy twirl style.
			bRollSprite = true;
			
			// The frames of the animation are under the FancyTwirlFrames label. +0 is with no blur, +1 is with a little blur, and so on.
			// So, for every degrees/tic of spin rate, increase blur by 1/25 (up to 4).
			uint f = min(abs(RotControl.Vel) / 25, 3);
			st = FindState('FancyTwirlFrames') + f;
		}
		else
		{
			// Fall back to the legacy style.
			bRollSprite = false;
			
			if (abs(deltaangle(Roll, TouchAngle)) < 45. && abs(RotControl.Vel) < 10.)
			{
				// Use the regular unblurred sprite in this situation.
				st = FindState('Spawn');
			}
			else
			{
				// First of all, choose the correct sprite set. There are two blur levels in this animation, so we'll go to the blurrier one at ≥50°/tic.
				if (abs(RotControl.Vel) >= 50.)
					st = FindState('LegacyTwirlFramesSuper');
				else
					st = FindState('LegacyTwirlFrames');
				
				// The frames for this animation are determined by the roll angle.
				// The angles of the sprite frames are:
				// 	A:-84.47°	B:-130.2°	C:-174.35°
				// 	D:140.75°	E:95.53°	F:50.67°
				// 	G:5.59°	H:-39.25°
				// Each frame is offset from the next one by about 45°.
				// The frame lookup table has been set up so that we'll get the right frame with the given index.
				uint f = floor(4.5 + (Normalize180(Roll - 90.) / 45.));
				f %= 8;
				st += f;
			}
		}
		
		sprite = st.sprite;
		frame = st.frame;
	}
	
	states
	{
		Spawn:
			SCEM Z 1;
			// Wait for the next tic before beginning to fly away and spin up.
			// Keep the TargetSpinRate up-to-date with respect to the FullSpinRate, which can change at any moment (when Flora gains a level in the Sceptre).
			#### # 1 A_SpinUp;
			wait;
		
		Recall:
			// Don't start spinning down until reaching full angular velocity.
			#### # 1 {
				if (invoker.RotControl.Vel >= invoker.FullSpinRate)
					return ResolveState(1);
				else
				{
					A_SpinUp();
					return ResolveState(null);
				}
			}
			wait;
			
			// Start spinning down.
			#### # 0 A_SpinDown;
			#### # 1 A_JumpIf(!invoker.RotControl.IsLandingInProgress(), 1);
			wait;
			
			// Recall finished.
			#### # -1 { invoker.ReadyToCatch = true; }
			stop;
		
		/*
		Blocked:
			#### # 0 A_PlaySound(SceptrePuff.HitWallSounds[0]);
			goto Recall;
		*/
			
		// This is a lookup table for sprites and frames. We never actually jump into any of these states; they're only used for sprite/frame lookup.
		FancyTwirlFrames: SCEM Z[^] -1;
		LegacyTwirlFrames: STR3 ABCDEFGH -1;
		LegacyTwirlFramesSuper: STR2 ABCDEFGH -1;
	}
}
