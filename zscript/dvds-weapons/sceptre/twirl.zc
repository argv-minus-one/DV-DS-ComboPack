extend class SceptreOfEmpyreaZSC
{
	SceptreTwirling Twirling;
	protected float TwirlMPCostAccum, TwirlStamCostAccum;
	
	protected bool TwirlDeductCosts(bool showMessage = true)
	{
		if (TwirlMPCostAccum >= 1. && !AetheriusACS.CheckMP(TwirlMPCostAccum))
		{
			if (showMessage && Owner)
				Owner.A_Print("Not enough MP!");
			return false;
		}
		
		if (TwirlStamCostAccum >= 1. && !AetheriusACS.TryTakeStamina(TwirlStamCostAccum))
		{
			if (showMessage && Owner)
				Owner.A_Print("Not enough stamina!");
			return false;
		}
		else
			TwirlStamCostAccum -= floor(TwirlStamCostAccum);
		
		// Check MP, then check+take stamina, then take MP. That way, if Flora doesn't have enough of either, she won't lose any of either.
		AetheriusACS.TakeMP(TwirlMPCostAccum);
		TwirlMPCostAccum -= floor(TwirlMPCostAccum);
		
		return true;
	}
	
	protected void TwirlUpdate()
	{
		TwirlMPCostAccum +=      SceptreTwirlMPCost     [SceptreLevel];
		TwirlStamCostAccum +=    SceptreTwirlStaminaCost[SceptreLevel];
		Twirling.FullSpinRate =  TwirlSpinRate          [SceptreLevel];
		Twirling.ActiveSound =   TwirlSound             [SceptreLevel];
		Twirling.SpinAccelMult = 1. / (35. - min(SceptreLevel, 16));
		Twirling.SpinDecelMult = Twirling.SpinAccelMult * 2.;
		
		if (ACS_NamedExecuteWithResult("GetBuffTimer", 7) > 0) {
			Twirling.SpinAccelMult *= 2.;
			Twirling.SpinDecelMult *= 2.;
		}
	}
	
	states
	{
		AltFire:
			#### # 1 A_SceptreLower(andThen: 1, speed: 3);
			wait;
			
			FLHS B 0 A_WeaponOffset(0, WEAPONBOTTOM);
			#### # 1 A_AnimateOffset(1, (0, WEAPONTOP), speed: 10);
			wait;
			
			#### # 0 {
				{
					let rc = GetReplacement("SceptreTwirling");
					if (!(rc is "SceptreTwirling"))
						ThrowAbortException("%s, the replacement for SceptreTwirling, is not a subtype of SceptreTwirling!", rc.GetClassName());
				}
				
				// Spawn the twirling sceptre.
				invoker.Twirling = SceptreTwirling(Spawn("SceptreTwirling", pos: Pos, replace: ALLOW_REPLACE));
				invoker.Twirling.master = self;
			}
			
		Twirling:
			FLHS A 0 A_JumpIf(!invoker.TwirlDeductCosts() || !invoker.Twirling, "TwirlStop");
			#### # 1 { A_SceptreDefend(); invoker.TwirlUpdate(); }
			#### # 0 A_ReFire("Twirling");
		
		TwirlStop:
			// Start the recall animation, then wait for it to finish.
			#### # 0
			{
				if (invoker.Twirling)
					invoker.Twirling.Recall();
				invoker.TwirlStamCostAccum = invoker.TwirlMPCostAccum = 0.;
			}
			
			#### # 1 A_JumpIf(!invoker.Twirling || invoker.Twirling.ReadyToCatch, 1);
			wait;
			
			FLHS B 0 {
				if (invoker.Twirling)
				{
					invoker.Twirling.Destroy();
					invoker.Twirling = null;
				}
			}
			
			// Lower Flora's hand.
			#### # 1 A_AnimateOffset(1, (0, WEAPONBOTTOM), speed: 10);
			wait;
			SCEM A 0 A_SceptreBeginRaise;
			#### # 1 A_SceptreRaise(andThen: "Ready", speed: 3);
			wait;
	}
}

class SceptreTwirling : Actor
{
	default
	{
		+INTERPOLATEANGLES;
		+FLATSPRITE;
		+ROLLSPRITE;
		+ROLLCENTER;
		+NOINTERACTION;
		+BRIGHT;
		Speed 2;
		Height 40;
		Radius 40;
		Scale .08888888888888889; // (40 / 450) in double precision
		ActiveSound "SceptreTwirl1";
		SceptreTwirling.SpinAccelMult (1./35.), (1./35.);
		SceptreTwirling.SpinRate 3, 25;
		SceptreTwirling.TouchPos 14, -6, 0;
		SceptreTwirling.TouchAngle 180;
		SceptreTwirling.TwirlPos 30, 0, 0;
	}
	
	float SpinAccelMult, SpinDecelMult;
	property SpinAccelMult: SpinAccelMult, SpinDecelMult;
	
	float MinSpinRate, FullSpinRate;
	// How fast the Sceptre spins initially and at full speed (in degrees per tic).
	property SpinRate: MinSpinRate, FullSpinRate;
	
	double TouchPosX, TouchPosY, TouchPosZ;
	// When the Sceptre is touching Flora's hand, this is the offset from her position relative to her yaw and pitch.
	property TouchPos: TouchPosX, TouchPosY, TouchPosZ;
	
	double TouchAngle;
	// When the Sceptre is touching Flora's hand, this is what its roll should be.
	property TouchAngle: TouchAngle;
	
	double TwirlPosX, TwirlPosY, TwirlPosZ;
	// Like TouchPos, but for when the Sceptre is out and twirling.
	property TwirlPos: TwirlPosX, TwirlPosY, TwirlPosZ;
	
	protected float SpinRate, TargetSpinRate, SpinDeltaAngle, SpinDeltaAccel;
	protected Vector3 PrevRelPos, CurrentRelPos, TargetRelPos;
	bool ReadyToCatch;
	private int SpawnTic;
	
	override void PostBeginPlay()
	{
		if (!master)
		{
			Console.Printf("\cr%s spawned without a master!", GetClassName());
			Destroy();
			return;
		}
		
		SpawnTic = gametic;
		PrevRelPos = CurrentRelPos = TargetRelPos = (TouchPosX, TouchPosY, TouchPosZ);
		Roll = TouchAngle;
	}
	
	override void Tick()
	{
		if (!master || master.bDestroyed || (master.bShootable && master.Health <= 0))
		{
			Destroy();
			return;
		}
		
		Super.Tick();
		
		// Actually spin.
		let prevRoll = Roll;
		if (
			SpinDeltaAngle != 0. &&
			(SpinDeltaAngle < 0.? SpinRate <= SpinDeltaAngle : SpinRate >= SpinDeltaAngle)
		)
		{
			// In delta angle mode, snap to the exact target angle.
			Roll = Normalize180(Roll + SpinDeltaAngle);
			SpinDeltaAngle = 0.;
			SpinRate = TargetSpinRate;
		}
		else if (SpinRate != 0.)
		{
			// Normal spinning.
			Roll = Normalize180(Roll + SpinRate);
			
			if (SpinDeltaAngle != 0.)
				SpinDeltaAngle -= SpinRate;
		}
		
		// Adjust the spin rate, as needed.
		// This needs to happen *after* adjusting the roll for this tic. Otherwise, delta angle mode may not stop, if the spin rate is too high.
		if (SpinDeltaAngle != 0.)
			// Spinning in delta angle mode, so use the delta angle acceleration factor instead.
			SpinRate += SpinDeltaAccel;
		else if (TargetSpinRate > SpinRate)
			// Accelerate.
			SpinRate = min(SpinRate + (SpinAccelMult * FullSpinRate), TargetSpinRate);
		else if (TargetSpinRate < SpinRate)
			// Decelerate.
			SpinRate = max(SpinRate - (SpinDecelMult * FullSpinRate), TargetSpinRate);
		
		// Play a sound when crossing angle 0 at speed.
		if (
			SpinRate > 15. && (
				((prevRoll < 0. && prevRoll > -90.) && (Roll >= 0. && Roll < 90.)) ||
				((prevRoll > 0. && prevRoll < 90.) && (Roll <= 0. && Roll > -90.))
			)
		)
			A_PlaySound(ActiveSound);
		
		if (CurrentRelPos != TargetRelPos)
		{
			// Move toward the destination.
			let delta = TargetRelPos - CurrentRelPos;
			let deltaLength = delta.Length();
			
			if (Speed >= deltaLength)
			{
				// Finished moving to the target relpos. Update PrevRelPos as well.
				PrevRelPos = CurrentRelPos = TargetRelPos;
			}
			else
			{
				// Not finished moving to the target relpos. Keep going.
				CurrentRelPos += delta.Unit() * Speed;
			}
		}
		
		SetSpriteAndFrame();
		
		{
			let realRelPos = CurrentRelPos;
			
			{
				/*
				// Correct for the user's pitch.
				let pitchCorrection = RotateVector((CurrentRelPos.X, CurrentRelPos.Z), -master.Pitch);
				realRelPos.X = pitchCorrection.X;
				realRelPos.Z = pitchCorrection.Y;
				*/
				// This is disabled because, if twirling the Sceptre while looking straight down, the Sceptre will disappear through the floor. And if it didn't, it'd be twirling through Flora's legs!
			}
			
			// If the wielder is a player character, align with its eyes. Otherwise, align with its height center.
			if (master.player)
				realRelPos.Z += master.player.viewheight;
			else
				realRelPos.Z += master.Height * .5;
			
			// Don't interpolate on the tic it was spawned. Doing so may create ugly graphical artifacts for a frame or two, since it's interpolating from an invalid state.
			let interpolate = gametic != SpawnTic;
			
			Warp(master, realRelPos.X, realRelPos.Y, realRelPos.Z, flags: (interpolate? WARPF_INTERPOLATE : 0)|WARPF_COPYPITCH|WARPF_COPYVELOCITY|WARPF_BOB|WARPF_NOCHECKPOSITION, pitch: 90.);
		}
	}
	
	protected action void A_MoveToTwirlPos()
	{
		invoker.PrevRelPos = invoker.CurrentRelPos;
		invoker.TargetRelPos = (invoker.TwirlPosX, invoker.TwirlPosY, invoker.TwirlPosZ);
	}
	
	protected action void A_MoveToTouchPos()
	{
		invoker.PrevRelPos = invoker.CurrentRelPos;
		invoker.TargetRelPos = (invoker.TouchPosX, invoker.TouchPosY, invoker.TouchPosZ);
	}
	
	protected action void A_SpinUp()
	{
		invoker.TargetSpinRate = invoker.FullSpinRate;
	}
	
	/** Enters delta angle mode. This will cause the Sceptre to accelerate/decelerate such that it is spinning at the targetSpinRate when it crosses the targetAngle. */
	protected action void A_SpinToAngle(float targetAngle, float targetSpinRate)
	{
		// Clear any previous delta angle mode, and set the new target spin rate.
		invoker.SpinDeltaAngle = 0.;
		invoker.TargetSpinRate = targetSpinRate;
		
		if (invoker.SpinRate == targetSpinRate)
			// If already at the targetSpinRate, there's nothing to do. The Sceptre will indeed cross the targetAngle at the targetSpinRate.
			return;
		
		// What's our maximum acceleration/deceleration rate? This will be positive if accelerating, or negative if decelerating.
		let accel =
			targetSpinRate > invoker.SpinRate?
			invoker.FullSpinRate * invoker.SpinAccelMult :
			invoker.FullSpinRate * -invoker.SpinDecelMult;
		
		// Can't do anything if the acceleration is zero!
		if (accel == 0.)
		{
			Console.Printf("\cg%s has a zero FullSpinRate or SpinAccelMult!\n[\c-FullSpinRate=\cf%f \c-SpinAccelMult=\cf%f \c-SpinDecelMult=\cf%f\cg]", GetClassName(), invoker.FullSpinRate, invoker.SpinAccelMult, invoker.SpinDecelMult);
			invoker.ReadyToCatch = true;
			invoker.Destroy();
			return;
		}
		
		// Given the current acceleration rate, what's the minimum time (in tics) needed to reach the targetSpinRate from the current SpinRate?
		// Credit to Carl Gauss for figuring out how to compute this part.
		let minTics = (targetSpinRate - invoker.SpinRate + accel) / accel;
		
		// In that time, assuming constant acceleration at the current rate (but with the spin rate never dropping below MinSpinRate), how far will the Sceptre spin?
		let minDeltaAngle = minTics * (
			abs(
				max(targetSpinRate, invoker.MinSpinRate)
				- max(invoker.SpinRate, invoker.MinSpinRate)
			) / 2.
		);
		
		// That probably won't be equal to targetAngle. How much farther must the Sceptre spin to reach the targetAngle?
		let remainingDeltaAngle = deltaangle(Normalize180(invoker.Roll + minDeltaAngle), targetAngle);
		if (remainingDeltaAngle < 0.)
			remainingDeltaAngle += 360.;
		
		// OK, now we have the full delta angle.
		invoker.SpinDeltaAngle = minDeltaAngle + remainingDeltaAngle;
		
		// At what rate should the Sceptre's spinning accelerate/decelerate, in order to reach the targetAngle right when it reaches the targetSpinRate?
		// FIXME: This is wrong! It causes the Sceptre to stop too soon when spinning down. It looks okayish, but not as good as it should.
		invoker.SpinDeltaAccel = invoker.SpinDeltaAngle == 0.? 0. : accel * (minDeltaAngle / invoker.SpinDeltaAngle);
		
		// And we're done!
		// Damn but this took me forever to figure out. [argv_minus_one]
	}
	
	protected action void A_SpinDown()
	{
		A_SpinToAngle(invoker.TouchAngle, 0.);
	}
	
	protected double ProgressTowardTargetRelPos()
	{
		if (TargetRelPos == CurrentRelPos)
			return 1.;
		else
		{
			let totalLength = abs((TargetRelPos - PrevRelPos).Length());
			let remainingLength = abs((TargetRelPos - CurrentRelPos).Length());
			return (totalLength - remainingLength) / totalLength;
		}
	}
	
	void Recall()
	{
		SetStateLabel("Recall");
	}
	
	protected virtual void SetSpriteAndFrame()
	{
		state st;
		
		if (vid_rendermode == 4)
		{
			// If using the OpenGL renderer, use the fancy twirl style.
			bRollSprite = true;
			
			// The frames of the animation are under the FancyTwirlFrames label. +0 is with no blur, +1 is with a little blur, and so on.
			// So, for every degrees/tic of spin rate, increase blur by 1/25 (up to 4).
			uint f = min(abs(SpinRate) / 25, 3);
			st = FindState("FancyTwirlFrames") + f;
		}
		else
		{
			// Fall back to the legacy style.
			bRollSprite = false;
			
			if (abs(deltaangle(Roll, TouchAngle)) < 45. && abs(SpinRate) < 10.)
			{
				// Use the regular unblurred sprite in this situation.
				st = FindState("Spawn");
			}
			else
			{
				// First of all, choose the correct sprite set. There are two blur levels in this animation, so we'll go to the blurrier one at ≥50°/tic.
				if (abs(SpinRate) >= 50.)
					st = FindState("LegacyTwirlFramesSuper");
				else
					st = FindState("LegacyTwirlFrames");
				
				// The frames for this animation are determined by the roll angle.
				// The angles of the sprite frames are:
				// 	A:-84.47°	B:-130.2°	C:-174.35°
				// 	D:140.75°	E:95.53°	F:50.67°
				// 	G:5.59°	H:-39.25°
				// Each frame is offset from the next one by about 45°.
				// The frame lookup table has been set up so that we'll get the right frame with the given index.
				uint f = floor(4.5 + (Normalize180(Roll - 90.) / 45.));
				f %= 8;
				st += f;
			}
		}
		
		sprite = st.sprite;
		frame = st.frame;
	}
	
	states
	{
		Spawn:
			SCEM Z 1;
			// Wait for the next tic before beginning to fly away and spin up.
			#### # 0 A_MoveToTwirlPos;
			// Keep the TargetSpinRate up-to-date with respect to the FullSpinRate, which can change at any moment (when Flora gains a level in the Sceptre).
			#### # 1 A_SpinUp;
			wait;
		
		Recall:
			// Start spinning down.
			#### # 0 A_SpinDown;
			#### # 1 A_JumpIf(invoker.SpinRate * 4. > invoker.SpinDeltaAngle, 1);
			wait;
			
			// Get into catch distance.
			#### # 0 A_MoveToTouchPos;
			#### # 1 A_JumpIf(invoker.SpinDeltaAngle == 0. && invoker.ProgressTowardTargetRelPos() > .99, 1);
			wait;
			
			// Recall finished.
			#### # -1 { invoker.ReadyToCatch = true; }
			stop;
		
		/*
		Blocked:
			#### # 0 A_PlaySound(SceptrePuff.HitWallSounds[0]);
			goto Recall;
		*/
			
		// This is a lookup table for sprites and frames. We never actually jump into any of these states; they're only used for sprite/frame lookup.
		FancyTwirlFrames: SCEM Z[^] -1;
		LegacyTwirlFrames: STR3 ABCDEFGH -1;
		LegacyTwirlFramesSuper: STR2 ABCDEFGH -1;
	}
}
