extend class SceptreOfEmpyreaZSC
{
	SceptreTwirling Twirling;
	protected float TwirlMPCostAccum, TwirlStamCostAccum;
	
	protected bool TwirlDeductCosts(bool showMessage = true)
	{
		if (TwirlMPCostAccum >= 1. && !AetheriusACS.CheckMP(TwirlMPCostAccum))
		{
			if (showMessage && Owner)
				Owner.A_Print("Not enough MP!");
			return false;
		}
		
		if (TwirlStamCostAccum >= 1. && !AetheriusACS.TryTakeStamina(TwirlStamCostAccum))
		{
			if (showMessage && Owner)
				Owner.A_Print("Not enough stamina!");
			return false;
		}
		else
			TwirlStamCostAccum -= floor(TwirlStamCostAccum);
		
		// Check MP, then check+take stamina, then take MP. That way, if Flora doesn't have enough of either, she won't lose any of either.
		AetheriusACS.TakeMP(TwirlMPCostAccum);
		TwirlMPCostAccum -= floor(TwirlMPCostAccum);
		
		return true;
	}
	
	protected void TwirlUpdate()
	{
		TwirlMPCostAccum +=      SceptreTwirlMPCost     [SceptreLevel];
		TwirlStamCostAccum +=    SceptreTwirlStaminaCost[SceptreLevel];
		Twirling.FullSpinRate =  TwirlSpinRate          [SceptreLevel];
		Twirling.ActiveSound =   TwirlSound             [SceptreLevel];
		Twirling.SpinAccelMult = 2. / (35. - min(SceptreLevel, 16));
		
		if (ACS_NamedExecuteWithResult("GetBuffTimer", 7) > 0)
			Twirling.SpinAccelMult *= 2.;
	}
	
	states
	{
		AltFire:
			#### # 1 A_SceptreLower(andThen: 1, speed: 3);
			wait;
			
			FLHS B 0 A_WeaponOffset(0, WEAPONBOTTOM);
			#### # 1 A_AnimateOffset(1, (0, WEAPONTOP), speed: 10);
			wait;
			
			#### # 0 {
				{
					let rc = GetReplacement("SceptreTwirling");
					if (!(rc is "SceptreTwirling"))
						ThrowAbortException("%s, the replacement for SceptreTwirling, is not a subtype of SceptreTwirling!", rc.GetClassName());
				}
				
				// Spawn the twirling sceptre.
				invoker.Twirling = SceptreTwirling(Spawn("SceptreTwirling", pos: Pos, replace: ALLOW_REPLACE));
				invoker.Twirling.master = self;
			}
			
		Twirling:
			FLHS A 0 A_JumpIf(!invoker.TwirlDeductCosts() || !invoker.Twirling, "TwirlStop");
			#### # 1 { A_SceptreDefend(); invoker.TwirlUpdate(); }
			#### # 0 A_ReFire("Twirling");
		
		TwirlStop:
			// Start the recall animation, then wait for it to finish.
			#### # 0
			{
				if (invoker.Twirling)
					invoker.Twirling.Recall();
				invoker.TwirlStamCostAccum = invoker.TwirlMPCostAccum = 0.;
			}
			
			#### # 1 A_JumpIf(!invoker.Twirling || invoker.Twirling.ReadyToCatch, 1);
			wait;
			
			FLHS B 0 {
				if (invoker.Twirling)
				{
					invoker.Twirling.Destroy();
					invoker.Twirling = null;
				}
			}
			
			// Lower Flora's hand.
			#### # 1 A_AnimateOffset(1, (0, WEAPONBOTTOM), speed: 10);
			wait;
			SCEM A 0 A_SceptreBeginRaise;
			#### # 1 A_SceptreRaise(andThen: "Ready", speed: 3);
			wait;
	}
}

class SceptreTwirling : Actor
{
	default
	{
		+INTERPOLATEANGLES;
		+FLATSPRITE;
		+ROLLSPRITE;
		+ROLLCENTER;
		+NOINTERACTION;
		+BRIGHT;
		Speed 2;
		Height 40;
		Radius 40;
		Scale .08888888888888889; // (40 / 450) in double precision
		ActiveSound "SceptreTwirl1";
		SceptreTwirling.SpinAccelMult (1./35.);
		SceptreTwirling.SpinRate 25;
		SceptreTwirling.TouchPos 14, -6, 0;
		SceptreTwirling.TouchAngle 180;
		SceptreTwirling.TwirlPos 30, 0, 0;
	}
	
	float SpinAccelMult;
	property SpinAccelMult: SpinAccelMult;
	
	float FullSpinRate;
	// How fast the Sceptre spins at full speed (in degrees per tic).
	property SpinRate: FullSpinRate;
	
	double TouchPosX, TouchPosY, TouchPosZ;
	// When the Sceptre is touching Flora's hand, this is the offset from her position relative to her yaw and pitch.
	property TouchPos: TouchPosX, TouchPosY, TouchPosZ;
	
	double TouchAngle;
	// When the Sceptre is touching Flora's hand, this is what its roll should be.
	property TouchAngle: TouchAngle;
	
	double TwirlPosX, TwirlPosY, TwirlPosZ;
	// Like TouchPos, but for when the Sceptre is out and twirling.
	property TwirlPos: TwirlPosX, TwirlPosY, TwirlPosZ;
	
	bool ReadyToCatch;
	protected ActorSpinner RotControl;
	protected Vector3 PrevRelPos, CurrentRelPos, TargetRelPos;
	private int SpawnTic;
	
	override void PostBeginPlay()
	{
		if (!master)
		{
			Console.Printf("\cr%s spawned without a master!", GetClassName());
			Destroy();
			return;
		}
		
		SpawnTic = gametic;
		PrevRelPos = CurrentRelPos = TargetRelPos = (TouchPosX, TouchPosY, TouchPosZ);
		Roll = TouchAngle;
		RotControl.mo = self;
	}
	
	override void Tick()
	{
		if (!master || master.bDestroyed || (master.bShootable && master.Health <= 0))
		{
			Destroy();
			return;
		}
		
		RotControl.Accel = SpinAccelMult * FullSpinRate;
		let prevRoll = Roll;
		RotControl.Tick();
		
		Super.Tick();
		
		// Play a sound when crossing angle 0 at speed.
		if (
			RotControl.Vel > 15. && (
				((prevRoll < 0. && prevRoll > -90.) && (Roll >= 0. && Roll < 90.)) ||
				((prevRoll > 0. && prevRoll < 90.) && (Roll <= 0. && Roll > -90.))
			)
		)
			A_PlaySound(ActiveSound);
		
		if (CurrentRelPos != TargetRelPos)
		{
			// Move toward the destination.
			let delta = TargetRelPos - CurrentRelPos;
			let deltaLength = delta.Length();
			
			if (Speed >= deltaLength)
			{
				// Finished moving to the target relpos. Update PrevRelPos as well.
				PrevRelPos = CurrentRelPos = TargetRelPos;
			}
			else
			{
				// Not finished moving to the target relpos. Keep going.
				CurrentRelPos += delta.Unit() * Speed;
			}
		}
		
		SetSpriteAndFrame();
		
		{
			let realRelPos = CurrentRelPos;
			
			{
				/*
				// Correct for the user's pitch.
				let pitchCorrection = RotateVector((CurrentRelPos.X, CurrentRelPos.Z), -master.Pitch);
				realRelPos.X = pitchCorrection.X;
				realRelPos.Z = pitchCorrection.Y;
				*/
				// This is disabled because, if twirling the Sceptre while looking straight down, the Sceptre will disappear through the floor. And if it didn't, it'd be twirling through Flora's legs!
			}
			
			// If the wielder is a player character, align with its eyes. Otherwise, align with its height center.
			if (master.player)
				realRelPos.Z += master.player.viewheight;
			else
				realRelPos.Z += master.Height * .5;
			
			// Don't interpolate on the tic it was spawned. Doing so may create ugly graphical artifacts for a frame or two, since it's interpolating from an invalid state.
			let interpolate = gametic != SpawnTic;
			
			Warp(master, realRelPos.X, realRelPos.Y, realRelPos.Z, flags: (interpolate? WARPF_INTERPOLATE : 0)|WARPF_COPYPITCH|WARPF_COPYVELOCITY|WARPF_BOB|WARPF_NOCHECKPOSITION, pitch: 90.);
		}
	}
	
	protected action void A_MoveToTwirlPos()
	{
		invoker.PrevRelPos = invoker.CurrentRelPos;
		invoker.TargetRelPos = (invoker.TwirlPosX, invoker.TwirlPosY, invoker.TwirlPosZ);
	}
	
	protected action void A_MoveToTouchPos()
	{
		invoker.PrevRelPos = invoker.CurrentRelPos;
		invoker.TargetRelPos = (invoker.TouchPosX, invoker.TouchPosY, invoker.TouchPosZ);
	}
	
	protected action void A_SpinUp()
	{
		invoker.RotControl.CancelLanding();
		invoker.RotControl.DesVel = invoker.FullSpinRate;
	}
	
	protected action void A_SpinDown()
	{
		invoker.RotControl.DesVel = 0;
		invoker.RotControl.LandAt(invoker.TouchAngle);
	}
	
	protected double ProgressTowardTargetRelPos()
	{
		if (TargetRelPos == CurrentRelPos)
			return 1.;
		else
		{
			let totalLength = abs((TargetRelPos - PrevRelPos).Length());
			let remainingLength = abs((TargetRelPos - CurrentRelPos).Length());
			return (totalLength - remainingLength) / totalLength;
		}
	}
	
	void Recall()
	{
		SetStateLabel("Recall");
	}
	
	protected virtual void SetSpriteAndFrame()
	{
		state st;
		
		if (vid_rendermode == 4)
		{
			// If using the OpenGL renderer, use the fancy twirl style.
			bRollSprite = true;
			
			// The frames of the animation are under the FancyTwirlFrames label. +0 is with no blur, +1 is with a little blur, and so on.
			// So, for every degrees/tic of spin rate, increase blur by 1/25 (up to 4).
			uint f = min(abs(RotControl.Vel) / 25, 3);
			st = FindState("FancyTwirlFrames") + f;
		}
		else
		{
			// Fall back to the legacy style.
			bRollSprite = false;
			
			if (abs(deltaangle(Roll, TouchAngle)) < 45. && abs(RotControl.Vel) < 10.)
			{
				// Use the regular unblurred sprite in this situation.
				st = FindState("Spawn");
			}
			else
			{
				// First of all, choose the correct sprite set. There are two blur levels in this animation, so we'll go to the blurrier one at ≥50°/tic.
				if (abs(RotControl.Vel) >= 50.)
					st = FindState("LegacyTwirlFramesSuper");
				else
					st = FindState("LegacyTwirlFrames");
				
				// The frames for this animation are determined by the roll angle.
				// The angles of the sprite frames are:
				// 	A:-84.47°	B:-130.2°	C:-174.35°
				// 	D:140.75°	E:95.53°	F:50.67°
				// 	G:5.59°	H:-39.25°
				// Each frame is offset from the next one by about 45°.
				// The frame lookup table has been set up so that we'll get the right frame with the given index.
				uint f = floor(4.5 + (Normalize180(Roll - 90.) / 45.));
				f %= 8;
				st += f;
			}
		}
		
		sprite = st.sprite;
		frame = st.frame;
	}
	
	states
	{
		Spawn:
			SCEM Z 1;
			// Wait for the next tic before beginning to fly away and spin up.
			#### # 0 A_MoveToTwirlPos;
			// Keep the TargetSpinRate up-to-date with respect to the FullSpinRate, which can change at any moment (when Flora gains a level in the Sceptre).
			#### # 1 A_SpinUp;
			wait;
		
		Recall:
			// Don't start spinning down until reaching at least half of full angular velocity.
			#### # 1 {
				if (invoker.RotControl.Vel >= invoker.FullSpinRate * .5)
					return ResolveState(1);
				else
				{
					A_SpinUp();
					return ResolveState(null);
				}
			}
			wait;
			
			// Start spinning down.
			#### # 0 A_SpinDown;
			#### # 1 A_JumpIf(invoker.RotControl.Vel <= invoker.FullSpinRate * .25, 1);
			wait;
			
			// Get into catch distance.
			#### # 0 A_MoveToTouchPos;
			#### # 1 A_JumpIf(!invoker.RotControl.IsLandingInProgress() && invoker.ProgressTowardTargetRelPos() > .99, 1);
			wait;
			
			// Recall finished.
			#### # -1 { invoker.ReadyToCatch = true; }
			stop;
		
		/*
		Blocked:
			#### # 0 A_PlaySound(SceptrePuff.HitWallSounds[0]);
			goto Recall;
		*/
			
		// This is a lookup table for sprites and frames. We never actually jump into any of these states; they're only used for sprite/frame lookup.
		FancyTwirlFrames: SCEM Z[^] -1;
		LegacyTwirlFrames: STR3 ABCDEFGH -1;
		LegacyTwirlFramesSuper: STR2 ABCDEFGH -1;
	}
}
