/*
TODO:
• Apply motion blur to twirl.
• Make it possible to cast spells through the shield.
• Implement the spin attack.
• Make all moves cost stamina.
• Make twirl also cost MP.
• Apply damage modifiers: berserk, debuffs, strength stat, etc.
• Port the FloraWeapon class to ZScript, then derive this class from it.

When done:
• Rename to SceptreOfEmpyrea.
• Remove ACS function “SceptreTwirlFrameCheck”.
• Remove allocation of ACS miscellaneous variables 198 and 397.
*/

class SceptreOfEmpyreaZSC : AetheriusBaseWeaponZSC //FloraWeapon //32221
{
	default
	{
		Tag "Sceptre of Empyrea";
		Scale 0.5;
		Weapon.SlotNumber 1;
		Weapon.SlotPriority 1;
		Weapon.KickBack 256;
		DamageType 'Sceptre';
		+SPECTRAL;
		+WEAPON.NOAUTOAIM;
		+WEAPON.NOALERT;
		+WEAPON.MELEEWEAPON;
		Inventory.PickupMessage "What a sight... Simplistic in its majesty...";
		Obituary "%o was smacked out of the ballpark by %k's \cjSceptre of Empyrea\c-.";
	}
	
	// Level tables //
	
	static const float SceptreAttackSpeeds[] =
	{
		 0,       -0.03125, -0.0625,  -0.09375, -0.125,
		-0.15625, -0.1875,  -0.21875, -0.25,    -0.28125,
		-0.3125,  -0.34375, -0.375,   -0.40625, -0.4375,
		-0.46875, -0.5
	};
	
	static const uint16 SceptreDamageMin[] =
	{
		275, 280, 290,  320,  340, 365,
		425, 425, 545,  590,  640, 750,
		810, 875, 1015, 1015, 1255
	};
	
	static const uint16 SceptreDamageMax[] =
	{
		325, 330,  340,  370,  390, 415,
		475, 475,  595,  640,  690, 800,
		860, 925, 1065, 1065, 1305
	};
	
	static const uint8 SceptreRange[] =
	{
		130, 133, 135, 138, 140, 145,
		148, 153, 160, 165, 168, 170,
		173, 178, 180, 185, 192
	};
	
	static const uint16 SceptreSwingStaminaCost[] =
	{
		575, 568, 561, 554, 546, 538,
		530, 521, 512, 503, 493, 483,
		473, 462, 451, 440, 428
	};
	
	static const Sound SceptreSwingSounds[] =
	{
		 "SceptreSwingLvl0",  "SceptreSwingLvl1",  "SceptreSwingLvl2",
		 "SceptreSwingLvl3",  "SceptreSwingLvl4",  "SceptreSwingLvl5",
		 "SceptreSwingLvl6",  "SceptreSwingLvl7",  "SceptreSwingLvl8",
		 "SceptreSwingLvl9", "SceptreSwingLvl10", "SceptreSwingLvl11",
		"SceptreSwingLvl12", "SceptreSwingLvl13", "SceptreSwingLvl14",
		"SceptreSwingLvl15", "SceptreSwingLvl16"
	};
	
	static const Sound SceptreSpinAttackSounds[] =
	{
		 "SceptreSwingLvl0",  "SceptreSwingLvl1",  "SceptreSwingLvl2",
		 "SceptreSwingLvl3",  "SceptreSwingLvl4",  "SceptreSwingLvl5",
		 "SceptreSwingLvl6",  "SceptreSwingLvl7",  "SceptreSwingLvl8",
		 "SceptreSwingLvl9", "SceptreSwingLvl10", "SceptreSwingLvl11",
		"SceptreSwingLvl12", "SceptreSwingLvl13", "SceptreSwingLvl14",
		"SceptreSwingLvl15", "SceptreSwingLvl16"
	};
	
	static const uint16 SceptreAerialAttackStaminaCost[] =
	{
		575, 568, 561, 554, 546, 538,
		530, 521, 512, 503, 493, 483,
		473, 462, 451, 440, 428
	};
	
	static const uint16 SceptreSpinAttackStaminaCost[] =
	{
		1005, 996, 987, 978, 969, 960,
		 951, 942, 933, 924, 915, 903,
		 891, 879, 867, 855, 840
	};
	
	static const uint16 SceptreTwirlStaminaCost[] =
	{
		// TODO
		1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1,
		1, 1, 1, 1
	};
	
	static const float SceptreTwirlMPCost[] =
	{
		0.21052632, 0.20988564, 0.2079636, 0.20476018, 0.2002754,
		0.19450927, 0.18746176, 0.1791329, 0.16952264, 0.15863106,
		0.14645809, 0.13300376, 0.11826806, 0.102251, 0.08495257,
		0.06637278, 0.046511628
	};
	
	const AerialAttackButtons = BT_JUMP;
	const AerialAttackMinCharLevel = 13;
	const AerialAttackMinSceptreLevel = 4;
	const SpinAttackButtons = BT_MOVELEFT | BT_MOVERIGHT;
	const SwingDefenseDuration = 12;
	const FullAttackAngle = 120.;
	
	// Code //
	
	protected int SceptreLevel, CharLevel;
	SceptreShieldPower Shield;
	SceptreTwirling Twirling;
	
	override void Tick()
	{
		if (Owner && Owner.player && Owner.player.ReadyWeapon == self)
		{
			SceptreLevel = CallACS("GetSceptreLevel");
			CharLevel = CallACS("GetPlayerLevel");
		}
		else
			SceptreLevel = CharLevel = 0;
		
		Super.Tick();
	}
	
	override float AnimSpeedFactor()
	{
		// If you try to just return SceptreAttackSpeeds[SceptreLevel], you'll cause an error. Odd.
		let f = SceptreAttackSpeeds[SceptreLevel];
		return f;
	}
	
	Array<Actor> ActorsHitThisSwing;
	double SwingAngle;
	
	const SwingAngleStart = -120.;
	const SwingAngleStep = (120. * 2. / 12.); // 240° over 12 tics.
	
	action void A_SceptreAttack(
		int range = -1,
		int damageMin = -1,
		int damageMax = -1,
		Class<Actor> puffType = "SceptrePuff",
		double swingAngle = 0,
		double swingWidth = SceptreOfEmpyreaZSC.FullAttackAngle,
		bool puffWalls = true,
		bool rememberAlreadyHitActors = true,
		int enabledEffects = 0xFFFFFFFF
	) {
		if (range == -1)
			range = invoker.SceptreRange[invoker.SceptreLevel];
		if (damageMin == -1)
			damageMin = invoker.SceptreDamageMin[invoker.SceptreLevel];
		if (damageMax == -1)
			damageMax = invoker.SceptreDamageMax[invoker.SceptreLevel];
		
		class<Actor> replacedPuffType = GetReplacement(puffType);
		let puffDefaults = GetDefaultByType(replacedPuffType);
		bool actorsHit = false;
		
		let it = ThinkerIterator.Create("Actor");
		for (let mo = Actor(it.Next()); mo; mo = Actor(it.Next()))
		{
			if (
				mo == self || mo.master == self ||
				(mo.bMissile && mo.target == self) ||
				mo.bDormant ||
				(
					puffDefaults.bAllowThruFlags &&
					(
						puffDefaults.bThruActors ||
						(puffDefaults.bMThruSpecies && puffDefaults.Species == mo.Species)
					)
				) ||
				((invoker.bThruGhost || puffDefaults.bThruGhost) && mo.bGhost) ||
				(mo.bSpectral && !puffDefaults.bSpectral) ||
				!(mo.bShootable || mo.bMissile) ||
				Distance3D(mo) > range ||
				(mo.CurSector.PortalGroup != CurSector.PortalGroup && !CheckSight(mo))
			)
				continue;
			
			let angle = AngleTo(mo);
			if (absangle(angle, self.Angle + swingAngle) > SwingAngleStep)
				continue;
			
			// TODO: Check vertical angle (pitch)? Not needed for the Sceptre because its max angle is wider than 180° anyway, but…
			
			if (rememberAlreadyHitActors)
			{
				if (invoker.ActorsHitThisSwing.Find(mo) < invoker.ActorsHitThisSwing.Size())
					continue;
				else
					invoker.ActorsHitThisSwing.Push(mo);
			}
			
			int damage;
			if (damageMin)
			{
				if (damageMax)
					damage = random(damageMin, damageMax);
				else
					damage = damageMin;
			}
			else if (damageMax)
				damage = damageMax;
			else
				damage = 0;
			
			let shouldBleed =
				damage > 0 &&
				!mo.bMissile &&
				!mo.bNoBlood &&
				!mo.bInvulnerable &&
				!mo.bDormant &&
				!puffDefaults.bBloodlessImpact;
			
			let shouldPuff =
				!shouldBleed ||
				puffDefaults.bPuffOnActors;
			
			Actor puff;
			bool puffIsNew;
			{
				let puffAngle = Normalize180(angle - 180.);
				let puffPos = mo.Vec3Offset(
					(mo.radius + 1) * cos(puffAngle),
					(mo.radius + 1) * sin(puffAngle),
					(mo.Height / 2) - mo.Floorclip
				);
				
				Inventory pt;
				if (
					shouldPuff && // puff needs to be tracked at all
					(pt = mo.FindInventory("SceptrePuffTracker")) && // there is a puff tracker
					pt.target && // there is already a tracked puff
					(pt.target.Pos - puffPos).Length() < max(pt.Owner.Radius, pt.Owner.Height) * .55 // the tracked puff is close enough
				)
				{
					puff = pt.target;
					
					if (!puff.CanCollideWith(mo, false) || !mo.CanCollideWith(puff, true))
						continue;
					
					puffIsNew = false;
					puff.SetXYZ(puffPos);
					puff.Angle = puffAngle;
				}
				else
				{
					puff = SpawnPuff(
						replacedPuffType,
						puffPos,
						puffAngle,
						puffAngle,
						0,
						flags: PF_HITTHING | PF_MELEERANGE |
						(shouldBleed? PF_HITTHINGBLEED : 0) |
						(shouldPuff? 0 : PF_TEMPORARY),
						victim: mo
					);
					puffIsNew = true;
					puff.tracer = mo;
					
					if (!puff.CanCollideWith(mo, false) || !mo.CanCollideWith(puff, true))
					{
						puff.Destroy();
						continue;
					}
					
					if (shouldPuff)
					{
						// If we found a tracker already, but decided its puff isn't eligible, then delete it.
						if (pt && pt.Owner)
							pt.Owner.RemoveInventory(pt);
						if (pt)
							pt.Destroy();
						
						pt = mo.GiveInventoryType("SceptrePuffTracker");
						pt.target = puff;
					}
				}
			}
			
			{
				let sp = SceptrePuff(puff);
				if (sp)
				{
					sp.SceptreLevel = invoker.SceptreLevel;
					sp.EnabledEffects = enabledEffects;
					
					if (!puffIsNew)
						sp.Refresh();
				}
			}
			
			int actualDamage = 0;
			if (mo.bShootable && damage)
			{
				let modt = mo.bDontThrust;
				mo.bDontThrust = true;
				actualDamage = mo.DamageMobj(
					puff,
					self,
					random(damageMin, damageMax),
					invoker.DamageType,
					flags: DMG_INFLICTOR_IS_PUFF | (invoker.bPierceArmor? DMG_NO_ARMOR : 0),
					angle: puff.Angle
				);
				mo.bDontThrust = modt;
				
				if (puffDefaults.PoisonDamage > 0)
					mo.PoisonMobj(puff, self, puffDefaults.PoisonDamage, puffDefaults.PoisonDuration, puffDefaults.PoisonPeriod, puffDefaults.PoisonDamageType);
			}
			
			if (shouldBleed)
			{
				if (invoker.bAxeBlood || invoker.bBloodSplatter)
					mo.BloodSplatter(puff.Pos, puff.Angle, invoker.bAxeBlood);
				else
					mo.SpawnBlood(puff.Pos, puff.Angle, actualDamage);
			}
			
			if (!shouldPuff)
				puff.Destroy();
			
			let deflectAngle = Normalize180(angle + frandom(-45., 45.));
			
			if (mo.bMissile)
			{
				mo.Vel.XY = AngleToVector(deflectAngle, mo.Speed * frandom(.6, 1.2));
				
				if (!mo.bFloorHugger && !mo.bCeilingHugger)
					mo.Vel.Z = frandom(-8., 8.);
			}
			else if (!mo.bDontThrust)
			{
				let deflectSpeed = min(
					(1. + (double(invoker.SceptreLevel) ** 2)) / sqrt(double(mo.Mass)),
					frandom(27, 33)
				);
				mo.Thrust(deflectSpeed, deflectAngle);
			}
			
			if (dvdsdebug_showmeleeinformation) Console.Printf(
				"%s's %s hit %s for %d %s damage, resulting in %s.",
				self.GetClassName(),
				invoker.GetClassName(),
				mo.GetClassName(),
				actualDamage, invoker.DamageType,
				(shouldPuff && shouldBleed)?
					String.Format("a %s and blood", puff.GetClassName()) :
					shouldPuff? String.Format("a %s", puff.GetClassName()) :
					shouldBleed? "blood" :
					"neither a puff nor blood"
			);
			
			actorsHit = true;
		}
		
		if (!actorsHit && puffWalls)
		{
			let wallHitAngle = Normalize180(self.Angle + swingAngle);
			
			let puff = LineAttack(
				Normalize180(self.Angle + swingAngle),
				range,
				AimLineAttack(swingAngle, range),
				random(damageMin, damageMax),
				puffDefaults.DamageType,
				puffType
			);
			
			if (puff is "SceptrePuff")
				SceptrePuff(puff).SceptreLevel = invoker.SceptreLevel;
		}
	}
	
	action void A_SceptreDefend()
	{
		if (invoker.Shield)
			invoker.Shield.EffectTics = 2;
		else
			invoker.Shield = SceptreShieldPower(self.GiveInventoryType("SceptreShieldPower"));
		
		A_SceptreAttack(
			damageMin: 0,
			damageMax: 0,
			puffWalls: false,
			rememberAlreadyHitActors: false,
			enabledEffects: SceptrePuff.SPFX_QUAKE_ALL | SceptrePuff.SPFX_SOUND_HITPROJECTILE
		);
	}
	
	bool CheckSpinAttack()
	{
		return
			Owner && Owner.player &&
			(Owner.player.cmd.buttons & SpinAttackButtons) == SpinAttackButtons &&
			CallACS("GetMiscellaneousVar", 244);
	}
	
	bool CheckAerialAttack()
	{
		return
			CharLevel >= AerialAttackMinCharLevel &&
			SceptreLevel >= AerialAttackMinSceptreLevel &&
			Owner && Owner.player &&
			Owner.Vel.Z < 0. &&
			(Owner.player.cmd.buttons & AerialAttackButtons) == AerialAttackButtons;
	}
	
	// Starting offset (completely offscreen): 87, 112
	// Ending offset (completely onscreen): 0, 32
	// Number of frames: 10
	// Interpolation step: -8.7, -8
	static const double SceptreRaiseStartOffset[] = { 87, 80 + WEAPONTOP };
	static const double SceptreRaiseEndOffset[] = { 0, WEAPONTOP };
	static const double SceptreRaiseStep[] = { -8.7, -8 };
	
	/** This should be called on a TNT1 A 1 frame, before beginning the sceptre raise animation proper. */
	action void A_SceptreBeginRaise()
	{
		A_WeaponOffset(invoker.SceptreRaiseStartOffset[0], invoker.SceptreRaiseStartOffset[1]);
	}
	
	action state A_SceptreRaise(statelabel andThen = null, double speed = 1)
	{
		if (!player)
			return null;
		
		let ps = player.FindPSprite(PSP_WEAPON);
		if (!ps)
			return null;
		
		if (andThen && ps.x <= invoker.SceptreRaiseEndOffset[0] && ps.y <= invoker.SceptreRaiseEndOffset[1])
		{
			if (andThen == "Ready")
				A_Raise(0);
			return ResolveState(andThen);
		}
		else
		{
			let nx = max(ps.x + (invoker.SceptreRaiseStep[0] * speed), invoker.SceptreRaiseEndOffset[0]);
			let ny = max(ps.y + (invoker.SceptreRaiseStep[1] * speed), invoker.SceptreRaiseEndOffset[1]);
			A_WeaponOffset(nx, ny, WOF_INTERPOLATE);
			return null;
		}
	}
	
	action state A_SceptreLower(statelabel andThen = null, bool switchWeaponWhenDone = false, double speed = 1)
	{
		if (!player)
			return null;
		
		let ps = player.FindPSprite(PSP_WEAPON);
		if (!ps)
			return null;
		
		if (ps.x >= invoker.SceptreRaiseStartOffset[0] && ps.y >= invoker.SceptreRaiseStartOffset[1])
		{
			if (switchWeaponWhenDone)
			{
				A_WeaponOffset(0, WEAPONBOTTOM);
				A_Lower();
				return null;
			}
			else
				return ResolveState(andThen);
		}
		else
		{
			let nx = min(ps.x - (invoker.SceptreRaiseStep[0] * speed), invoker.SceptreRaiseStartOffset[0]);
			let ny = min(ps.y - (invoker.SceptreRaiseStep[1] * speed), invoker.SceptreRaiseStartOffset[1]);
			A_WeaponOffset(nx, ny, WOF_INTERPOLATE);
			return null;
		}
	}
	
	action void A_SceptreRaiseReset()
	{
		A_WeaponOffset(invoker.SceptreRaiseEndOffset[0], invoker.SceptreRaiseEndOffset[1]);
	}
	
	states
	{
		Spawn:
			SERP C -1 nodelay
			{
				if (
					!multiplayer &&
					playeringame[0] &&
					(
						!(players[0].mo is "FloraBriscoletti") ||
						players[0].mo.CountInv("SceptreOfEmpyrea")
					)
				)
					Destroy();
			}
			stop;
		
		Select:
			TNT1 A 1
			{
				A_SceptreBeginRaise();
				A_SetCrosshair(8);
				SetInventory("DrawingDiarisBow", 0);
				invoker.AnimSpeedsEnabled = true;
			}
			
			SCEM A 1 A_SceptreRaise("Ready");
			wait;
		
		Deselect:
			TNT1 A 0
			{
				A_SetCrosshair(0);
				CallACS("MiscVarSetDECORATE",397,0);
			}
			
			SCEM A 1 A_SceptreLower(switchWeaponWhenDone: true);
			wait;
		
		Ready:
			TNT1 A 0
			{
				invoker.ActorsHitThisSwing.Clear();
				A_SceptreRaiseReset();
				
				if (invoker.Twirling)
				{
					invoker.Twirling.Destroy();
					invoker.Twirling = null;
				}
			}
			
			SCEM A 1
			{
				invoker.bMeleeWeapon = random(1,100) <= 95;
				A_WeaponReady(WRF_ALLOWUSER1);
			}
			wait;
		
		Fire:
			SCEM A 1
			{
				if (!invoker.CanOwnerMove())
					return state(null);
				else if (invoker.CheckAerialAttack())
					return ResolveState("AerialAttack");
				else if (invoker.CheckSpinAttack())
					return ResolveState("SpinAttack");
				else
					return A_SceptreLower("Hold", speed: 1.5);
			}
			wait;
		
		Hold:
			TNT1 A 0 A_SceptreRaiseReset;
			
			TNT1 A 1
			{
				let inMenu = CallACS("GetMiscellaneousVar", 2500);
				let asleep = CallACS("GetBuffTimer", 20);
				
				if (!invoker.CanOwnerMove())
					return ResolveState("Hold");
				else if (player.cmd.buttons & BT_USER1)
					return ResolveState("User1");
				else if (invoker.CheckSpinAttack())
					return ResolveState("SpinAttack");
				else if (player.cmd.buttons & BT_ALTATTACK)
					return ResolveState("Select");
				else if (player.cmd.buttons & BT_ATTACK)
					return state(null);
				else
					return ResolveState("Swing");
			}
			wait;
		
		Swing:
			TNT1 A 0
			{
				if (!CallACS("UseStaminaAttack", invoker.SceptreSwingStaminaCost[invoker.SceptreLevel]))
					return ResolveState("Select");
				
				CallACS("AddSceptreEXP", 0, 1, 1);
				A_Kiai(63);
				A_PlaySound(invoker.SceptreSwingSounds[invoker.SceptreLevel], CHAN_WEAPON);
				invoker.SwingAngle = SwingAngleStart;
				
				// Strife mode makes the punch work like the Punch Dagger where it NEVER makes sound
				if (!(gameinfo.gametype & GAME_Strife) && (random() & 255) >= 252)
					// Sometimes a swing will be enough to wake up all monsters in the area.
					A_AlertMonsters();
				
				CallACS("StartTensionCountDown");
				
				A_WeaponOffset(46);
				
				return state(null);
			}
			
			SCEM CCCCCCCCCCCC 1
			{
				if (!player)
					return;
				let psp = player.FindPSprite(PSP_WEAPON);
				if (!psp)
					return;
				
				// During these 12 frames, the weapon psprite needs to move 459 offset units leftward.
				// 459 / 12 = 38.25
				A_WeaponOffset(psp.x - 38.25, psp.y, WOF_INTERPOLATE);
				
				A_SceptreAttack(
					range: invoker.SceptreRange[invoker.SceptreLevel],
					damageMin: invoker.SceptreDamageMin[invoker.SceptreLevel],
					damageMax: invoker.SceptreDamageMax[invoker.SceptreLevel],
					puffType: "SceptrePuff",
					swingAngle: invoker.SwingAngle,
					swingWidth: SceptreOfEmpyreaZSC.SwingAngleStep
				);
				invoker.SwingAngle += invoker.SwingAngleStep;
			}
			
			TNT1 A 0 A_WeaponOffset; // Reset the offset.
			goto Select;
		
		SpinAttack:
			// TODO
			/*
			TNT1 A 0
			{
				if (!CallACS("UseStaminaAttack", SceptreSpinAttackStaminaCost[SceptreLevel]))
					return ResolveState("Ready");
				
				// Strife mode makes the punch work like the Punch Dagger where it NEVER makes sound
				if (!(gameinfo.gametype & GAME_Strife) && (random() & 255) >= 248)
					// Sometimes a swing will be enough to wake up all monsters in the area.
					A_AlertMonsters();
				
				A_Kiai(31);
			}
			*/
			goto Hold;
			
		AerialAttack:
			goto Hold;
		
		AltFire:
			SCEM A 1 A_SceptreLower(andThen: 1, speed: 3);
			wait;
			
			FLHS B 0 A_WeaponOffset(0, WEAPONBOTTOM);
			#### # 1 A_AnimateOffset(1, (0, WEAPONTOP), speed: (10, 10));
			wait;
			
			#### # 0 {
				{
					let rc = GetReplacement("SceptreTwirling");
					if (!(rc is "SceptreTwirling"))
						ThrowAbortException("%s, the replacement for SceptreTwirling, is not a subtype of SceptreTwirling!", rc.GetClassName());
				}
				
				// Spawn the twirling sceptre.
				invoker.Twirling = SceptreTwirling(Spawn("SceptreTwirling", pos: Pos, replace: ALLOW_REPLACE));
				invoker.Twirling.master = self;
			}
			
		AltHold:
			FLHS A 1 A_SceptreDefend;
			#### # 0 A_ReFire;
			
			// Start the recall animation, then wait for it to finish.
			#### # 0 { invoker.Twirling.Recall(); }
			#### # 1 A_JumpIf(invoker.Twirling.ReadyToCatch, 1);
			wait;
			
			FLHS B 0 {
				invoker.Twirling.Destroy();
				invoker.Twirling = null;
			}
			
			// Lower Flora's hand.
			#### # 1 A_AnimateOffset(1, (0, WEAPONBOTTOM), speed: (10, 10));
			wait;
			SCEM A 0 A_SceptreBeginRaise;
			#### # 1 A_SceptreRaise(andThen: "Ready", speed: 3);
			wait;
	}
}

class SceptrePuff : AetheriusMeleePuff
{
	default
	{
		VSpeed 0;
		RenderStyle 'Translucent';
		DamageType 'Sceptre';
		SceptrePuff.EnabledEffects 0xFFFFFFFF; // Enable everything by default.
		+PUFFONACTORS;
		+FORCEPAIN;
		+SPECTRAL;
		-ALLOWPARTICLES;
	}
	
	// The following tables were generated by tools/generate-sceptre-constants.zc.
	static const Sound HitThingSounds[] =
	{
		"SceptreHitThing1", "SceptreHitThing1", "SceptreHitThing1", "SceptreHitThing1",
		"SceptreHitThing1", "SceptreHitThing1", "SceptreHitThing1", "SceptreHitThing1",
		"SceptreHitThing2", "SceptreHitThing2", "SceptreHitThing2", "SceptreHitThing2",
		"SceptreHitThing2", "SceptreHitThing2", "SceptreHitThing2", "SceptreHitThing2",
		"SceptreHitThing3"
	};
	
	static const Sound HitWallSounds[] =
	{
		"SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall",
		"SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall",
		"SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall1",
		"SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall1",
		"SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall1",
		"SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall2"
	};
	
	static const Sound HitProjectileSounds[] =
	{
		"SceptreBlocked", "SceptreBlocked", "SceptreBlocked", "SceptreBlocked",
		"SceptreBlocked", "SceptreBlocked", "SceptreBlocked", "SceptreBlocked",
		"SceptreBlocked", "SceptreBlocked", "SceptreBlocked", "SceptreBlocked",
		"SceptreBlocked", "SceptreBlocked", "SceptreBlocked", "SceptreBlocked",
		"SceptreBlocked"
	};
	
	static const int QuakeBaseIntensity[] =
	{
		1, 1, 1, 1, 1, 1,
		1, 1, 2, 2, 2, 2,
		2, 2, 2, 2, 3
	};
	
	static const int QuakeBaseDuration[] =
	{
		8, 8, 9, 9, 10, 10,
		11, 11, 12, 12, 13, 13,
		14, 14, 15, 15, 16
	};
	
	static const int QuakeBaseRadius[] =
	{
		512, 544, 576, 608, 640, 672,
		704, 736, 768, 800, 832, 864,
		896, 928, 960, 992, 1024
	};
	
	static const float Scales[] =
	{
		0.375, 0.40625, 0.4375, 0.46875, 0.5, 0.53125,
		0.5625, 0.59375, 0.625, 0.65625, 0.6875, 0.71875,
		0.75, 0.78125, 0.8125, 0.84375, 0.875
	};
	
	static const float Opacities[] =
	{
		0.5, 0.5208333, 0.5416666, 0.56249994, 0.58333325, 0.60416657,
		0.6249999, 0.6458332, 0.6666665, 0.6874998, 0.70833313, 0.72916645,
		0.74999976, 0.7708331, 0.7916664, 0.8124997, 0.833333
	};
	
	enum EEffectFlags
	{
		SPFX_QUAKE_HITWALL = 1 << 0,
		SPFX_QUAKE_HITPROJECTILE = 1 << 1,
		SPFX_QUAKE_HITACTOR = 1 << 2,
		SPFX_QUAKE_ALL = (SPFX_QUAKE_HITWALL | SPFX_QUAKE_HITPROJECTILE | SPFX_QUAKE_HITACTOR),
		SPFX_SOUND_HITWALL = 1 << 3,
		SPFX_SOUND_HITPROJECTILE = 1 << 4,
		SPFX_SOUND_HITACTOR = 1 << 5,
		SPFX_SOUND_ALL = (SPFX_SOUND_HITWALL | SPFX_SOUND_HITPROJECTILE | SPFX_SOUND_HITACTOR),
		SPFX_ALL_HITWALL = (SPFX_QUAKE_HITWALL | SPFX_SOUND_HITWALL),
		SPFX_ALL_HITPROJECTILE = (SPFX_QUAKE_HITPROJECTILE | SPFX_SOUND_HITPROJECTILE),
		SPFX_ALL_HITACTOR = (SPFX_QUAKE_HITACTOR | SPFX_SOUND_HITACTOR)
	};
	
	static EEffectFlags GetEffectFlagsFor(Actor a)
	{
		if (!a)
			return SPFX_ALL_HITWALL;
		else if (a.bMissile)
			return SPFX_ALL_HITPROJECTILE;
		else if (a.player || a.bShootable || a.bIsMonster || a.bTouchy || a.bVulnerable)
			return SPFX_ALL_HITACTOR;
		else
			return 0;
	}
	
	const FadeRate = 1. / 7.;
	
	EEffectFlags EnabledEffects;
	property EnabledEffects: EnabledEffects;
	
	State FadeState;
	
	/**
	 * Level of the Sceptre that generated this puff. This should be set externally (by the Sceptre class) when this puff is spawned.
	 */
	int SceptreLevel;
	
	override void BeginPlay()
	{
		Super.BeginPlay();
		FadeState = FindState("Fade", exact: true);
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		Refresh();
	}
	
	override void Tick()
	{
		Super.Tick();
		
		if (InStateSequence(CurState, FadeState))
			A_FadeOut(Alpha * FadeRate, FTF_REMOVE);
	}
	
	/**
	 * Does things that need to happen when the victim of this puff is hit. Specifically, this method does the following:
	 *
	 * • Makes a sound and quake, if configured to.
	 * • Sets the scale and alpha of this puff, as appropriate for the Sceptre level.
	 * • If this puff is in the Fade sequence, moves it back into the Spawn sequence.
	 *
	 * This method is automatically called whenever this puff is spawned. It should be called again if this puff is moved.
	 */
	virtual void Refresh()
	{
		Scale.X = Scale.Y = Scales[SceptreLevel];
		Alpha = Opacities[SceptreLevel];
		
		let effectFlags = GetEffectFlagsFor(tracer);
		
		if (SPFX_QUAKE_ALL & effectFlags & EnabledEffects)
			A_PuffQuake(
				QuakeBaseIntensity[SceptreLevel],
				QuakeBaseDuration[SceptreLevel],
				QuakeBaseRadius[SceptreLevel]
			);
		
		if (SPFX_SOUND_ALL & effectFlags & EnabledEffects)
			A_PlaySound(
				(effectFlags & SPFX_SOUND_HITACTOR)? HitThingSounds[SceptreLevel] :
				(effectFlags & SPFX_SOUND_HITPROJECTILE)? HitProjectileSounds[SceptreLevel] :
				HitWallSounds[SceptreLevel],
				slot: CHAN_WEAPON
			);
		
		if (InStateSequence(CurState, FadeState))
			SetState(SpawnState);
	}
	
	states
	{
		Spawn:
		Melee:
		Crash:
			SCSK A 3 bright;
		
		Fade:
			SCSK GHIJKJIH 3 bright;
			stop;
	}
}

class SceptrePuffTracker : Inventory
{
	override void Tick()
	{
		Super.Tick();
		
		if (Owner && (!target || target.bDestroyed))
			Owner.RemoveInventory(self);
		if (!Owner)
			Destroy();
	}
}

class SceptreShieldPower : PowerShielded
{
	default
	{
		Powerup.Duration 2;
		PowerShielded.ShieldActorClass "SceptreShield";
	}
}

class SceptreShield : PowerShielded_Shield
{
	default
	{
		+REFLECTIVE;
		+NOTARGET;
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		if (
			!master ||
			master == other ||
			(other.bMissile && master == other.target)
		)
			return false;
		
		let ang = master.AngleTo(other);
		let rang = absangle(master.AngleTo(other), master.Angle);
		let block = rang <= SceptreOfEmpyreaZSC.FullAttackAngle;
		
		if (dvdsdebug_sceptre_showshieldstatus)
		{
			if (block)
				Console.Printf(
					"%s blocked by %s!",
					other.GetClassName(),
					GetClassName()
				);
			else
				Console.Printf(
					"%s couldn't block a %s.",
					GetClassName(),
					other.GetClassName()
				);
		}
		
		return block;
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name damageType, int flags = 0, double angle = 0)
	{
		let rang = absangle(master.AngleTo(inflictor), master.Angle);
		let block = rang <= SceptreOfEmpyreaZSC.FullAttackAngle;
		
		if (dvdsdebug_sceptre_showshieldstatus)
			Console.Printf(
				"%s was hit from angle %f (abs %f) by a %s fired by %s!",
				GetClassName(),
				angle, rang,
				inflictor.GetClassName(),
				source.GetClassName()
			);
		
		if (block)
		{
			if (dvdsdebug_sceptre_showshieldstatus)
				Console.Printf(
					"%d %s damage blocked by %s!",
					damage, damageType,
					GetClassName()
				);
			
			return 0;
		}
		
		if (dvdsdebug_sceptre_showshieldstatus)
			Console.Printf(
				"%s couldn't block %d %s damage.",
				GetClassName(),
				damage, damageType
			);
		
		return master.DamageMobj(inflictor, source, damage, damageType, flags, angle);
	}
}

class SceptreTwirling : Actor
{
	default
	{
		+INTERPOLATEANGLES;
		+FLATSPRITE;
		+ROLLSPRITE;
		+ROLLCENTER;
		+NOINTERACTION;
		+BRIGHT;
		Speed 2;
		Height 40;
		Radius 40;
		Scale .08888888888888889; // (40 / 450) in double precision
		SceptreTwirling.SpinAccel 1;
		SceptreTwirling.SpinRate 3, 25, 1;
		SceptreTwirling.TouchPos 14, -6, 0;
		SceptreTwirling.TouchAngle 0;
		SceptreTwirling.TwirlPos 50, 0, 0;
	}
	
	float SpinAccel;
	property SpinAccel: SpinAccel;
	
	float MinSpinRate, FullSpinRate;
	uint16 SpinDownRevolutions;
	// How fast the Sceptre spins initially and at full speed (in degrees per tic), and how many extra revolutions it takes to spin down.
	property SpinRate: MinSpinRate, FullSpinRate, SpinDownRevolutions;
	
	double TouchPosX, TouchPosY, TouchPosZ;
	// When the Sceptre is touching Flora's hand, this is the offset from her position relative to her yaw and pitch.
	property TouchPos: TouchPosX, TouchPosY, TouchPosZ;
	
	double TouchAngle;
	// When the Sceptre is touching Flora's hand, this is what its roll should be.
	property TouchAngle: TouchAngle;
	
	double TwirlPosX, TwirlPosY, TwirlPosZ;
	// Like TouchPos, but for when the Sceptre is out and twirling.
	property TwirlPos: TwirlPosX, TwirlPosY, TwirlPosZ;
	
	protected float SpinRate, TargetSpinRate, SpinDownDeltaAngle;
	protected Vector3 PrevRelPos, CurrentRelPos, TargetRelPos;
	bool ReadyToCatch;
	
	override void PostBeginPlay()
	{
		if (!master)
		{
			Console.Printf("\cr%s spawned without a master!", GetClassName());
			Destroy();
			return;
		}
		
		PrevRelPos = CurrentRelPos = TargetRelPos = (TouchPosX, TouchPosY, TouchPosZ);
	}
	
	override void Tick()
	{
		if (!master || master.bDestroyed || (master.bShootable && master.Health <= 0))
		{
			Destroy();
			return;
		}
		
		Super.Tick();
		
		if (SpinDownDeltaAngle != 0.)
		{
			// Spin down the Sceptre.
			let psr = MinSpinRate + ((TargetSpinRate - MinSpinRate) * (SpinDownDeltaAngle / (SpinDownRevolutions * 360.)));
			
			if (psr > SpinDownDeltaAngle)
			{
				Roll += SpinDownDeltaAngle;
				SpinRate = SpinDownDeltaAngle = TargetSpinRate = 0.;
			}
			else
			{
				SpinRate = psr;
				SpinDownDeltaAngle -= psr;
			}
		}
		else if (TargetSpinRate != SpinRate)
		{
			// Approach the TargetSpinRate.
			if (TargetSpinRate > SpinRate)
				SpinRate = min(SpinRate + SpinAccel, TargetSpinRate);
			else
				SpinRate = max(SpinRate - SpinAccel, TargetSpinRate);
		}
		
		// Actually spin.
		if (SpinRate != 0.)
			Roll = Normalize180(Roll + SpinRate);
		
		if (CurrentRelPos != TargetRelPos)
		{
			// Move toward the destination.
			let delta = TargetRelPos - CurrentRelPos;
			let deltaLength = delta.Length();
			let nextPos = CurrentRelPos + (delta.Unit() * Speed);
			let nextDelta = TargetRelPos - nextPos;
			let nextDeltaLength = nextDelta.Length();
			
			// Make sure not to overshoot.
			if ((deltaLength < 0. && nextDeltaLength >= 0.) || (deltaLength > 0. && nextDeltaLength <= 0.))
				// Finished moving to the target relpos. Update PrevRelPos as well.
				PrevRelPos = CurrentRelPos = TargetRelPos;
			else
				// Not finished moving to the target relpos. Keep going.
				CurrentRelPos = nextPos;
		}
		
		{
			let realRelPos = CurrentRelPos;
			
			{
				/*
				// Correct for the user's pitch.
				let pitchCorrection = RotateVector((CurrentRelPos.X, CurrentRelPos.Z), -master.Pitch);
				realRelPos.X = pitchCorrection.X;
				realRelPos.Z = pitchCorrection.Y;
				*/
				// This is disabled because, if twirling the Sceptre while looking straight down, the Sceptre will disappear through the floor. And if it didn't, it'd be twirling through Flora's legs!
			}
			
			// If the wielder is a player character, align with its eyes. Otherwise, align with its height center.
			if (master.player)
				realRelPos.Z += master.player.viewheight;
			else
				realRelPos.Z += master.Height * .5;
			
			Warp(master, realRelPos.X, realRelPos.Y, realRelPos.Z, flags: WARPF_INTERPOLATE|WARPF_COPYPITCH|WARPF_COPYVELOCITY|WARPF_BOB|WARPF_NOCHECKPOSITION, pitch: 90.);
		}
	}
	
	protected action void A_MoveToTwirlPos()
	{
		invoker.PrevRelPos = invoker.CurrentRelPos;
		invoker.TargetRelPos = (invoker.TwirlPosX, invoker.TwirlPosY, invoker.TwirlPosZ);
	}
	
	protected action void A_MoveToTouchPos()
	{
		invoker.PrevRelPos = invoker.CurrentRelPos;
		invoker.TargetRelPos = (invoker.TouchPosX, invoker.TouchPosY, invoker.TouchPosZ);
	}
	
	protected action void A_SpinUp()
	{
		invoker.TargetSpinRate = invoker.FullSpinRate;
	}
	
	protected action void A_SpinDown()
	{
		invoker.SpinDownDeltaAngle = deltaangle(Roll, invoker.TouchAngle) + (invoker.SpinDownRevolutions * 360.);
	}
	
	protected double ProgressTowardTargetRelPos()
	{
		if (TargetRelPos == CurrentRelPos)
			return 1.;
		else
		{
			let totalLength = abs((TargetRelPos - PrevRelPos).Length());
			let remainingLength = abs((TargetRelPos - CurrentRelPos).Length());
			return (totalLength - remainingLength) / totalLength;
		}
	}
	
	void Recall()
	{
		SetStateLabel("Recall");
	}
	
	states
	{
		Spawn:
			SCEM Z 1;
			// Wait for the next tic before beginning to fly away and spin up.
			#### # -1 { A_MoveToTwirlPos(); A_SpinUp(); }
			stop;
		
		Recall:
			// Start spinning down.
			#### # 0 A_SpinDown;
			#### # 1 A_JumpIf(invoker.SpinDownDeltaAngle < 45., 1);
			wait;
			
			// Get into catch distance.
			#### # 0 A_MoveToTouchPos;
			#### # 1 A_JumpIf(invoker.ProgressTowardTargetRelPos() > .99, 1);
			wait;
			
			// Recall finished.
			#### # -1 { invoker.ReadyToCatch = true; }
			stop;
		
		/*
		Blocked:
			#### # 0 A_PlaySound(SceptrePuff.HitWallSounds[0]);
			goto Recall;
		*/
	}
}
