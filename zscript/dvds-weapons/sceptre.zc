class SceptreOfEmpyreaZSC : AetheriusBaseWeaponZSC //FloraWeapon //32221
{
	default
	{
		Tag "Sceptre of Empyrea";
		Scale 0.5;
		Weapon.SlotNumber 1;
		Weapon.SlotPriority 1;
		Weapon.KickBack 256;
		+SPECTRAL;
		+WEAPON.NOAUTOAIM;
		+WEAPON.NOALERT;
		+WEAPON.MELEEWEAPON;
		Inventory.PickupMessage "What a sight... Simplistic in It's Majesty...";
		Obituary "%o was smacked out of the ballpark by %k's \cjSceptre of Empyrea\c-.";
	}
	
	// Level tables //
	
	static const float SceptreAttackSpeeds[] =
	{
		 0,       -0.03125, -0.0625,  -0.09375, -0.125,
		-0.15625, -0.1875,  -0.21875, -0.25,    -0.28125,
		-0.3125,  -0.34375, -0.375,   -0.40625, -0.4375,
		-0.46875, -0.5
	};
	
	static const uint16 SceptreDamageMin[] =
	{
		275, 280, 290,  320,  340, 365,
		425, 425, 545,  590,  640, 750,
		810, 875, 1015, 1015, 1255
	};
	
	static const uint16 SceptreDamageMax[] =
	{
		325, 330,  340,  370,  390, 415,
		475, 475,  595,  640,  690, 800,
		860, 925, 1065, 1065, 1305
	};
	
	static const uint8 SceptreRange[] =
	{
		130, 133, 135, 138, 140, 145,
		148, 153, 160, 165, 168, 170,
		173, 178, 180, 185, 192
	};
	
	static const uint16 SceptreSwingStaminaCost[] =
	{
		575, 568, 561, 554, 546, 538,
		530, 521, 512, 503, 493, 483,
		473, 462, 451, 440, 428
	};
	
	static const Sound SceptreSwingSounds[] =
	{
		 "SceptreSwingLvl0",  "SceptreSwingLvl1",  "SceptreSwingLvl2",
		 "SceptreSwingLvl3",  "SceptreSwingLvl4",  "SceptreSwingLvl5",
		 "SceptreSwingLvl6",  "SceptreSwingLvl7",  "SceptreSwingLvl8",
		 "SceptreSwingLvl9", "SceptreSwingLvl10", "SceptreSwingLvl11",
		"SceptreSwingLvl12", "SceptreSwingLvl13", "SceptreSwingLvl14",
		"SceptreSwingLvl15", "SceptreSwingLvl16"
	};
	
	static const Sound SceptreSpinAttackSounds[] =
	{
		 "SceptreSwingLvl0",  "SceptreSwingLvl1",  "SceptreSwingLvl2",
		 "SceptreSwingLvl3",  "SceptreSwingLvl4",  "SceptreSwingLvl5",
		 "SceptreSwingLvl6",  "SceptreSwingLvl7",  "SceptreSwingLvl8",
		 "SceptreSwingLvl9", "SceptreSwingLvl10", "SceptreSwingLvl11",
		"SceptreSwingLvl12", "SceptreSwingLvl13", "SceptreSwingLvl14",
		"SceptreSwingLvl15", "SceptreSwingLvl16"
	};
	
	static const uint16 SceptreAerialAttackStaminaCost[] =
	{
		575, 568, 561, 554, 546, 538,
		530, 521, 512, 503, 493, 483,
		473, 462, 451, 440, 428
	};
	
	static const uint16 SceptreSpinAttackStaminaCost[] =
	{
		1005, 996, 987, 978, 969, 960,
		 951, 942, 933, 924, 915, 903,
		 891, 879, 867, 855, 840
	};
	
	static const uint16 SceptreTwirlStaminaCost[] =
	{
		// TODO
		1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1,
		1, 1, 1, 1
	};
	
	static const uint16 SceptreTwirlMPCost[] =
	{
		// TODO
		1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1,
		1, 1, 1, 1
	};
	
	const AerialAttackButtons = BT_JUMP;
	const AerialAttackMinCharLevel = 13;
	const AerialAttackMinSceptreLevel = 4;
	const SpinAttackButtons = BT_MOVELEFT | BT_MOVERIGHT;
	const SwingDefenseDuration = 12;
	const MaxHitAngle = 120.;
	
	// Code //
	
	protected int SceptreLevel, CharLevel;
	
	override void Tick()
	{
		if (Owner && Owner.player && Owner.player.ReadyWeapon == self)
		{
			SceptreLevel = CallACS("GetSceptreLevel");
			CharLevel = CallACS("GetPlayerLevel");
		}
		else
			SceptreLevel = CharLevel = 0;
		
		Super.Tick();
	}
	
	override float AnimSpeedFactor()
	{
		// If you try to just return SceptreAttackSpeeds[SceptreLevel], you'll cause an error. Odd.
		let f = SceptreAttackSpeeds[SceptreLevel];
		return f;
	}
	
	Array<Actor> ActorsHitThisSwing;
	
	action void A_SceptreAttack(
		int range = -1,
		int damageMin = -1,
		int damageMax = -1,
		Class<Actor> puffType = "SceptrePuff"
	) {
		if (range == -1)
			range = invoker.SceptreRange[invoker.SceptreLevel];
		if (damageMin == -1)
			damageMin = invoker.SceptreDamageMin[invoker.SceptreLevel];
		if (damageMax == -1)
			damageMax = invoker.SceptreDamageMax[invoker.SceptreLevel];
		
		class<Actor> replacedPuffType = GetReplacement(puffType);
		let puffDefaults = GetDefaultByType(replacedPuffType);
		
		let it = ThinkerIterator.Create("Actor");
		for (let mo = Actor(it.Next()); mo; mo = Actor(it.Next()))
		{
			if (
				mo == self || mo.bDormant || (
					puffDefaults.bAllowThruFlags &&
					(
						puffDefaults.bThruActors ||
						(puffDefaults.bMThruSpecies && puffDefaults.Species == mo.Species)
					)
				) ||
				(puffDefaults.bThruGhost && mo.bGhost) ||
				(mo.bSpectral && !puffDefaults.bSpectral) ||
				!mo.bShootable ||
				Distance2D(mo) > range ||
				(mo.CurSector.PortalGroup != CurSector.PortalGroup && !CheckSight(mo))
			)
				continue;
			
			let angle = AngleTo(mo);
			if (absangle(angle, self.Angle) > MaxHitAngle)
				continue;
			
			if (invoker.ActorsHitThisSwing.Find(mo) < invoker.ActorsHitThisSwing.Size())
				continue;
			else
				invoker.ActorsHitThisSwing.Push(mo);
			
			let shouldBleed = !(puffDefaults.bBloodlessImpact || mo.bNoBlood);
			let shouldPuff = !shouldBleed || puffDefaults.bPuffOnActors;
			
			Actor puff;
			{
				let puffAngle = Normalize180(angle - 180.);
				let puffPos = mo.Vec3Offset(
					(mo.radius + 1) * cos(puffAngle),
					(mo.radius + 1) * sin(puffAngle),
					(mo.Height / 2) - mo.Floorclip
				);
				puff = SpawnPuff(
					replacedPuffType,
					puffPos,
					puffAngle,
					puffAngle,
					PF_HITTHING | PF_MELEERANGE |
					(
						!(mo.bNoBlood || mo.bInvulnerable || mo.bDormant)?
						PF_HITTHINGBLEED : 0
					) |
					(shouldPuff? 0 : PF_TEMPORARY),
					victim: mo
				);
			}
			
			let actualDamage = mo.DamageMobj(
				puff,
				self,
				random(damageMin, damageMax),
				invoker.DamageType,
				flags: DMG_INFLICTOR_IS_PUFF | (invoker.bPierceArmor? DMG_NO_ARMOR : 0),
				angle: puff.Angle
			);
			
			if (puffDefaults.PoisonDamage > 0)
				mo.PoisonMobj(puff, self, puffDefaults.PoisonDamage, puffDefaults.PoisonDuration, puffDefaults.PoisonPeriod, puffDefaults.PoisonDamageType);
			
			if (shouldBleed)
			{
				if (invoker.bAxeBlood || invoker.bBloodSplatter)
					mo.BloodSplatter(puff.Pos, puff.Angle, invoker.bAxeBlood);
				else
					mo.SpawnBlood(puff.Pos, puff.Angle, actualDamage);
			}
			
			if (!shouldPuff)
				puff.Destroy();
		}
	}
	
	action void A_SceptreDefend()
	{
		// TODO
	}
	
	bool CheckSpinAttack()
	{
		return
			Owner && Owner.player &&
			(Owner.player.cmd.buttons & SpinAttackButtons) == SpinAttackButtons &&
			CallACS("GetMiscellaneousVar", 244);
	}
	
	bool CheckAerialAttack()
	{
		return
			CharLevel >= AerialAttackMinCharLevel &&
			SceptreLevel >= AerialAttackMinSceptreLevel &&
			Owner && Owner.player &&
			Owner.Vel.Z < 0. &&
			(Owner.player.cmd.buttons & AerialAttackButtons) == AerialAttackButtons;
	}
	
	// Starting offset (completely offscreen): 87, 112
	// Ending offset (completely onscreen): 0, 32
	// Number of frames: 10
	// Interpolation step: -8.7, -8
	static const double SceptreRaiseStartOffset[] = { 87, 80 + WEAPONTOP };
	static const double SceptreRaiseEndOffset[] = { 0, WEAPONTOP };
	static const double SceptreRaiseStep[] = { -8.7, -8 };
	
	/** This should be called on a TNT1 A 1 frame, before beginning the sceptre raise animation proper. */
	action void A_SceptreBeginRaise()
	{
		A_WeaponOffset(invoker.SceptreRaiseStartOffset[0], invoker.SceptreRaiseStartOffset[1]);
	}
	
	action state A_SceptreRaise(statelabel andThen = null, double speed = 1)
	{
		if (!player)
			return null;
		
		let ps = player.FindPSprite(PSP_WEAPON);
		if (!ps)
			return null;
		
		if (andThen && ps.x <= invoker.SceptreRaiseEndOffset[0] && ps.y <= invoker.SceptreRaiseEndOffset[1])
		{
			if (andThen == "Ready")
				A_Raise(0);
			return ResolveState(andThen);
		}
		else
		{
			let nx = max(ps.x + (invoker.SceptreRaiseStep[0] * speed), invoker.SceptreRaiseEndOffset[0]);
			let ny = max(ps.y + (invoker.SceptreRaiseStep[1] * speed), invoker.SceptreRaiseEndOffset[1]);
			A_WeaponOffset(nx, ny, WOF_INTERPOLATE);
			return null;
		}
	}
	
	action state A_SceptreLower(statelabel andThen = null, bool switchWeaponWhenDone = false, double speed = 1)
	{
		if (!player)
			return null;
		
		let ps = player.FindPSprite(PSP_WEAPON);
		if (!ps)
			return null;
		
		if (ps.x >= invoker.SceptreRaiseStartOffset[0] && ps.y >= invoker.SceptreRaiseStartOffset[1])
		{
			if (switchWeaponWhenDone)
			{
				A_WeaponOffset(0, WEAPONBOTTOM);
				A_Lower();
				return null;
			}
			else
				return ResolveState(andThen);
		}
		else
		{
			let nx = min(ps.x - (invoker.SceptreRaiseStep[0] * speed), invoker.SceptreRaiseStartOffset[0]);
			let ny = min(ps.y - (invoker.SceptreRaiseStep[1] * speed), invoker.SceptreRaiseStartOffset[1]);
			A_WeaponOffset(nx, ny, WOF_INTERPOLATE);
			return null;
		}
	}
	
	action void A_SceptreRaiseReset()
	{
		A_WeaponOffset(invoker.SceptreRaiseEndOffset[0], invoker.SceptreRaiseEndOffset[1]);
	}
	
	states
	{
		Spawn:
			SERP C -1 nodelay
			{
				if (
					!multiplayer &&
					playeringame[0] &&
					(
						!(players[0].mo is "FloraBriscoletti") ||
						players[0].mo.CountInv("SceptreOfEmpyrea")
					)
				)
					Destroy();
			}
			stop;
		
		Select:
			TNT1 A 1
			{
				A_SceptreBeginRaise();
				A_SetCrosshair(8);
				SetInventory("DrawingDiarisBow", 0);
				invoker.AnimSpeedsEnabled = true;
			}
			
			SCEM A 1 A_SceptreRaise("Ready");
			wait;
		
		Deselect:
			TNT1 A 0
			{
				A_SetCrosshair(0);
				CallACS("MiscVarSetDECORATE",397,0);
			}
			
			SCEM A 1 A_SceptreLower(switchWeaponWhenDone: true);
			wait;
		
		Ready:
			TNT1 A 0
			{
				invoker.ActorsHitThisSwing.Clear();
				A_SceptreRaiseReset();
			}
			
			SCEM A 1
			{
				invoker.bMeleeWeapon = random(1,100) <= 95;
				A_WeaponReady(WRF_ALLOWUSER1);
			}
			wait;
		
		Fire:
			SCEM A 1
			{
				if (!invoker.CanOwnerMove())
					return state(null);
				else if (invoker.CheckAerialAttack())
					return ResolveState("AerialAttack");
				else if (invoker.CheckSpinAttack())
					return ResolveState("SpinAttack");
				else
					return A_SceptreLower("Hold", speed: 1.5);
			}
			wait;
		
		Hold:
			TNT1 A 0 A_SceptreRaiseReset;
			
			TNT1 A 1
			{
				let inMenu = CallACS("GetMiscellaneousVar", 2500);
				let asleep = CallACS("GetBuffTimer", 20);
				
				if (!invoker.CanOwnerMove())
					return ResolveState("Hold");
				else if (player.cmd.buttons & BT_USER1)
					return ResolveState("User1");
				else if (invoker.CheckSpinAttack())
					return ResolveState("SpinAttack");
				else if (player.cmd.buttons & BT_ALTATTACK)
					return ResolveState("Select");
				else if (player.cmd.buttons & BT_ATTACK)
					return state(null);
				else
					return ResolveState("Swing");
			}
			wait;
		
		Swing:
			TNT1 A 0
			{
				if (!CallACS("UseStaminaAttack", invoker.SceptreSwingStaminaCost[invoker.SceptreLevel]))
					return ResolveState("Select");
				
				CallACS("AddSceptreEXP", 0, 1, 1);
				A_Kiai(63);
				A_PlaySound(invoker.SceptreSwingSounds[invoker.SceptreLevel], CHAN_WEAPON);
				
				return state(null);
			}
			SCEM DEFG 1 A_SceptreDefend;
			
			SCEM H 1 bright
			{
				A_SceptreDefend();
				A_SceptreAttack(
					invoker.SceptreRange[invoker.SceptreLevel],
					invoker.SceptreDamageMin[invoker.SceptreLevel],
					invoker.SceptreDamageMax[invoker.SceptreLevel],
					"SceptrePuff"
				);
				
				// Strife mode makes the punch work like the Punch Dagger where it NEVER makes sound
				if (!(gameinfo.gametype & GAME_Strife) && (random() & 255) >= 252)
					// Sometimes a swing will be enough to wake up all monsters in the area.
					A_AlertMonsters();
				
				CallACS("StartTensionCountDown");
			}
			
			SCEM IJKLMNO 1 A_SceptreDefend;
			goto Select;
		
		SpinAttack:
			// TODO
			/*
			TNT1 A 0
			{
				if (!CallACS("UseStaminaAttack", SceptreSpinAttackStaminaCost[SceptreLevel]))
					return ResolveState("Ready");
				
				// Strife mode makes the punch work like the Punch Dagger where it NEVER makes sound
				if (!(gameinfo.gametype & GAME_Strife) && (random() & 255) >= 248)
					// Sometimes a swing will be enough to wake up all monsters in the area.
					A_AlertMonsters();
				
				A_Kiai(31);
			}
			*/
			goto Hold;
			
		AerialAttack:
			goto Hold;
		
		AltFire:
			FLHS A 1;
			FLHS A 0 A_ReFire;
			goto Ready;
	}
}

class SceptrePuff : AetheriusMeleePuff
{
	default
	{
		VSpeed 0;
		RenderStyle 'Translucent';
		Species 'Players';
		DamageType 'Sceptre';
		+PUFFONACTORS;
		+ALWAYSPUFF;
		+FORCEPAIN;
		+THRUSPECIES;
		+MTHRUSPECIES;
		+SPECTRAL;
	}
	
	// The following tables were generated by tools/generate-sceptre-constants.zc.
	static const Sound HitThingSounds[] =
	{
		"SceptreHitThing0", "SceptreHitThing0", "SceptreHitThing0", "SceptreHitThing0",
		"SceptreHitThing0", "SceptreHitThing0", "SceptreHitThing0", "SceptreHitThing0",
		"SceptreHitThing1", "SceptreHitThing1", "SceptreHitThing1", "SceptreHitThing1",
		"SceptreHitThing1", "SceptreHitThing1", "SceptreHitThing1", "SceptreHitThing1",
		"SceptreHitThing2"
	};
	
	static const Sound HitWallSounds[] =
	{
		"SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall",
		"SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall",
		"SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall1",
		"SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall1",
		"SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall1",
		"SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall2"
	};
	
	static const int QuakeBaseIntensity[] =
	{
		1, 1, 1, 1, 1, 1,
		1, 1, 2, 2, 2, 2,
		2, 2, 2, 2, 3
	};
	
	static const int QuakeBaseDuration[] =
	{
		8, 8, 9, 9, 10, 10,
		11, 11, 12, 12, 13, 13,
		14, 14, 15, 15, 16
	};
	
	static const int QuakeBaseRadius[] =
	{
		512, 544, 576, 608, 640, 672,
		704, 736, 768, 800, 832, 864,
		896, 928, 960, 992, 1024
	};
	
	static const float Scales[] =
	{
		0.375, 0.40625, 0.4375, 0.46875, 0.5, 0.53125,
		0.5625, 0.59375, 0.625, 0.65625, 0.6875, 0.71875,
		0.75, 0.78125, 0.8125, 0.84375, 0.875
	};
	
	static const float Opacities[] =
	{
		0.5, 0.5208333, 0.5416666, 0.56249994, 0.58333325, 0.60416657,
		0.6249999, 0.6458332, 0.6666665, 0.6874998, 0.70833313, 0.72916645,
		0.74999976, 0.7708331, 0.7916664, 0.8124997, 0.833333
	};
	
	action void A_SceptrePuffSpecial(bool hitThing)
	{
		let sceptreLevel = CallACS("GetSceptreLevel");
		
		if (dvdsdebug_showmeleeinformation)
			Console.Printf("Sceptre puff spawned. Sceptre level is %d.", sceptreLevel);
		
		A_PuffQuake(
			invoker.QuakeBaseIntensity[sceptreLevel],
			invoker.QuakeBaseDuration[sceptreLevel],
			invoker.QuakeBaseRadius[sceptreLevel]
		);
		
		A_PlaySound(
			hitThing?
			invoker.HitThingSounds[sceptreLevel] :
			invoker.HitWallSounds[sceptreLevel]
		);
		
		invoker.Scale.X = invoker.Scales[sceptreLevel];
		invoker.Scale.Y = invoker.Scale.X;
		invoker.Alpha = invoker.Opacities[sceptreLevel];
	}
	
	states
	{
		Spawn:
		Melee:
			TNT1 A 1;
			TNT1 A 0 A_SceptrePuffSpecial(true);
			goto Anim;
		
		Crash:
			TNT1 A 1;
			TNT1 A 0 A_SceptrePuffSpecial(false);
			goto Anim;
		
		Anim:
			TNT1 A 0 A_SpawnItemEx("SceptreShockwave", flags: SXF_NOCHECKPOSITION | SXF_TRANSFERSCALE | SXF_TRANSFERALPHA | SXF_TRANSFERPOINTERS);
			SCPU CCDDDEEEFFFGGG 1 bright { Alpha -= Alpha / 5.; }
			stop;
	}
}

class SceptreShockwave : Actor
{
	default
	{
		+NOINTERACTION;
	}
	
	static const float Scales[] =
	{
		1.125, 1.21875, 1.3125, 1.40625, 1.5, 1.59375,
		1.6875, 1.78125, 1.875, 1.96875, 2.0625, 2.15625,
		2.25, 2.34375, 2.4375, 2.53125, 2.625
	};
	
	states
	{
		Spawn:
			TNT1 A 0 nodelay
			{
				invoker.Scale.X = invoker.Scales[CallACS("GetSceptreLevel")];
				invoker.Scale.Y = invoker.Scale.X;
			}
			
			SCSK GHIJK 1 bright { Alpha -= Alpha / 7.; }
			stop;
	}
}
