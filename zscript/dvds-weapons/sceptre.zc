/*
TODO:
• Make Sceptre hits on monsters and projectiles generate the correct sound effects.
• Animate alt fire.
• Don't generate hit sounds for monsters pushed back by the shield, but do generate puffs.
• Make it possible to cast spells through the shield.
• Nerf the push-back effect. It's ridiculously strong at level 16.
• Smooth out the attack animations.
• Implement the spin attack.
• Make alt fire cost stamina and MP.
• Don't generate multiple puffs/sounds on the same actor being continuously pushed away by alt fire. Instead, generate one, and make it keep looping its animation and sticking to the actor until it's no longer needed.
• Apply damage modifiers: berserk, debuffs, strength stat, etc.
• Port the FloraWeapon class to ZScript, then derive this class from it.
• Rename to SceptreOfEmpyrea when done.
*/

class SceptreOfEmpyreaZSC : AetheriusBaseWeaponZSC //FloraWeapon //32221
{
	default
	{
		Tag "Sceptre of Empyrea";
		Scale 0.5;
		Weapon.SlotNumber 1;
		Weapon.SlotPriority 1;
		Weapon.KickBack 256;
		+SPECTRAL;
		+WEAPON.NOAUTOAIM;
		+WEAPON.NOALERT;
		+WEAPON.MELEEWEAPON;
		Inventory.PickupMessage "What a sight... Simplistic in its majesty...";
		Obituary "%o was smacked out of the ballpark by %k's \cjSceptre of Empyrea\c-.";
	}
	
	// Level tables //
	
	static const float SceptreAttackSpeeds[] =
	{
		 0,       -0.03125, -0.0625,  -0.09375, -0.125,
		-0.15625, -0.1875,  -0.21875, -0.25,    -0.28125,
		-0.3125,  -0.34375, -0.375,   -0.40625, -0.4375,
		-0.46875, -0.5
	};
	
	static const uint16 SceptreDamageMin[] =
	{
		275, 280, 290,  320,  340, 365,
		425, 425, 545,  590,  640, 750,
		810, 875, 1015, 1015, 1255
	};
	
	static const uint16 SceptreDamageMax[] =
	{
		325, 330,  340,  370,  390, 415,
		475, 475,  595,  640,  690, 800,
		860, 925, 1065, 1065, 1305
	};
	
	static const uint8 SceptreRange[] =
	{
		130, 133, 135, 138, 140, 145,
		148, 153, 160, 165, 168, 170,
		173, 178, 180, 185, 192
	};
	
	static const uint16 SceptreSwingStaminaCost[] =
	{
		575, 568, 561, 554, 546, 538,
		530, 521, 512, 503, 493, 483,
		473, 462, 451, 440, 428
	};
	
	static const Sound SceptreSwingSounds[] =
	{
		 "SceptreSwingLvl0",  "SceptreSwingLvl1",  "SceptreSwingLvl2",
		 "SceptreSwingLvl3",  "SceptreSwingLvl4",  "SceptreSwingLvl5",
		 "SceptreSwingLvl6",  "SceptreSwingLvl7",  "SceptreSwingLvl8",
		 "SceptreSwingLvl9", "SceptreSwingLvl10", "SceptreSwingLvl11",
		"SceptreSwingLvl12", "SceptreSwingLvl13", "SceptreSwingLvl14",
		"SceptreSwingLvl15", "SceptreSwingLvl16"
	};
	
	static const Sound SceptreSpinAttackSounds[] =
	{
		 "SceptreSwingLvl0",  "SceptreSwingLvl1",  "SceptreSwingLvl2",
		 "SceptreSwingLvl3",  "SceptreSwingLvl4",  "SceptreSwingLvl5",
		 "SceptreSwingLvl6",  "SceptreSwingLvl7",  "SceptreSwingLvl8",
		 "SceptreSwingLvl9", "SceptreSwingLvl10", "SceptreSwingLvl11",
		"SceptreSwingLvl12", "SceptreSwingLvl13", "SceptreSwingLvl14",
		"SceptreSwingLvl15", "SceptreSwingLvl16"
	};
	
	static const uint16 SceptreAerialAttackStaminaCost[] =
	{
		575, 568, 561, 554, 546, 538,
		530, 521, 512, 503, 493, 483,
		473, 462, 451, 440, 428
	};
	
	static const uint16 SceptreSpinAttackStaminaCost[] =
	{
		1005, 996, 987, 978, 969, 960,
		 951, 942, 933, 924, 915, 903,
		 891, 879, 867, 855, 840
	};
	
	static const uint16 SceptreTwirlStaminaCost[] =
	{
		// TODO
		1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1,
		1, 1, 1, 1
	};
	
	static const uint16 SceptreTwirlMPCost[] =
	{
		// TODO
		1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1,
		1, 1, 1, 1
	};
	
	const AerialAttackButtons = BT_JUMP;
	const AerialAttackMinCharLevel = 13;
	const AerialAttackMinSceptreLevel = 4;
	const SpinAttackButtons = BT_MOVELEFT | BT_MOVERIGHT;
	const SwingDefenseDuration = 12;
	const MaxShieldAngle = 120.;
	
	// Code //
	
	protected int SceptreLevel, CharLevel;
	SceptreShieldPower Shield;
	
	override void Tick()
	{
		if (Owner && Owner.player && Owner.player.ReadyWeapon == self)
		{
			SceptreLevel = CallACS("GetSceptreLevel");
			CharLevel = CallACS("GetPlayerLevel");
		}
		else
			SceptreLevel = CharLevel = 0;
		
		Super.Tick();
	}
	
	override float AnimSpeedFactor()
	{
		// If you try to just return SceptreAttackSpeeds[SceptreLevel], you'll cause an error. Odd.
		let f = SceptreAttackSpeeds[SceptreLevel];
		return f;
	}
	
	Array<Actor> ActorsHitThisSwing;
	double SwingAngle;
	
	const SwingAngleStart = -120.;
	const SwingAngleStep = (120. * 2. / 12.); // 240° over 12 tics.
	
	action void A_SceptreAttack(
		int range = -1,
		int damageMin = -1,
		int damageMax = -1,
		Class<Actor> puffType = "SceptrePuff",
		double swingAngle = 0,
		double swingWidth = SceptreOfEmpyreaZSC.MaxShieldAngle,
		bool puffWalls = true,
		bool rememberAlreadyHitActors = true
	) {
		if (range == -1)
			range = invoker.SceptreRange[invoker.SceptreLevel];
		if (damageMin == -1)
			damageMin = invoker.SceptreDamageMin[invoker.SceptreLevel];
		if (damageMax == -1)
			damageMax = invoker.SceptreDamageMax[invoker.SceptreLevel];
		
		class<Actor> replacedPuffType = GetReplacement(puffType);
		let puffDefaults = GetDefaultByType(replacedPuffType);
		bool actorsHit = false;
		
		let it = ThinkerIterator.Create("Actor");
		for (let mo = Actor(it.Next()); mo; mo = Actor(it.Next()))
		{
			if (
				mo == self || mo.master == self ||
				(mo.bMissile && mo.target == self) ||
				mo.bDormant ||
				(
					puffDefaults.bAllowThruFlags &&
					(
						puffDefaults.bThruActors ||
						(puffDefaults.bMThruSpecies && puffDefaults.Species == mo.Species)
					)
				) ||
				(puffDefaults.bThruGhost && mo.bGhost) ||
				(mo.bSpectral && !puffDefaults.bSpectral) ||
				!(mo.bShootable || mo.bMissile) ||
				Distance3D(mo) > range ||
				(mo.CurSector.PortalGroup != CurSector.PortalGroup && !CheckSight(mo))
			)
				continue;
			
			let angle = AngleTo(mo);
			if (absangle(angle, self.Angle + swingAngle) > SwingAngleStep)
				continue;
			
			// TODO: Check vertical angle (pitch)? Not needed for the Sceptre because its max angle is wider than 180° anyway, but…
			
			if (rememberAlreadyHitActors)
			{
				if (invoker.ActorsHitThisSwing.Find(mo) < invoker.ActorsHitThisSwing.Size())
					continue;
				else
					invoker.ActorsHitThisSwing.Push(mo);
			}
			
			int damage;
			if (damageMin)
			{
				if (damageMax)
					damage = random(damageMin, damageMax);
				else
					damage = damageMin;
			}
			else if (damageMax)
				damage = damageMax;
			else
				damage = 0;
			
			let shouldBleed =
				damage > 0 &&
				!mo.bMissile &&
				!mo.bNoBlood &&
				!mo.bInvulnerable &&
				!mo.bDormant &&
				!puffDefaults.bBloodlessImpact;
			
			let shouldPuff =
				!shouldBleed ||
				puffDefaults.bPuffOnActors;
			
			Actor puff;
			{
				let puffAngle = Normalize180(angle - 180.);
				let puffPos = mo.Vec3Offset(
					(mo.radius + 1) * cos(puffAngle),
					(mo.radius + 1) * sin(puffAngle),
					(mo.Height / 2) - mo.Floorclip
				);
				puff = SpawnPuff(
					replacedPuffType,
					puffPos,
					puffAngle,
					puffAngle,
					0,
					flags: PF_HITTHING | PF_MELEERANGE |
					(shouldBleed? PF_HITTHINGBLEED : 0) |
					(shouldPuff? 0 : PF_TEMPORARY),
					victim: mo
				);
			}
			
			int actualDamage = 0;
			if (mo.bShootable && damage)
			{
				let modt = mo.bDontThrust;
				mo.bDontThrust = true;
				actualDamage = mo.DamageMobj(
					puff,
					self,
					random(damageMin, damageMax),
					invoker.DamageType,
					flags: DMG_INFLICTOR_IS_PUFF | (invoker.bPierceArmor? DMG_NO_ARMOR : 0),
					angle: puff.Angle
				);
				mo.bDontThrust = modt;
				
				if (puffDefaults.PoisonDamage > 0)
					mo.PoisonMobj(puff, self, puffDefaults.PoisonDamage, puffDefaults.PoisonDuration, puffDefaults.PoisonPeriod, puffDefaults.PoisonDamageType);
			}
			
			if (shouldBleed)
			{
				if (invoker.bAxeBlood || invoker.bBloodSplatter)
					mo.BloodSplatter(puff.Pos, puff.Angle, invoker.bAxeBlood);
				else
					mo.SpawnBlood(puff.Pos, puff.Angle, actualDamage);
			}
			
			if (!shouldPuff)
				puff.Destroy();
			else if (puff is "SceptrePuff")
			{
				SceptrePuff(puff).SceptreLevel = invoker.SceptreLevel;
				SceptrePuff(puff).WhatWasHit =
					mo.bMissile? SceptrePuff.HIT_PROJECTILE : SceptrePuff.HIT_MONSTER;
			}
			
			let deflectAngle = Normalize180(angle + frandom(-45., 45.));
			
			if (mo.bMissile)
			{
				mo.Vel.XY = AngleToVector(deflectAngle, mo.Speed * frandom(.6, 1.2));
				
				if (!mo.bFloorHugger && !mo.bCeilingHugger)
					mo.Vel.Z = frandom(-8., 8.);
			}
			else if (!mo.bDontThrust)
			{
				let deflectForce = (800. + (30. * invoker.SceptreLevel) ** 2.) * frandom(.9, 1.1) / mo.Mass;
				mo.Thrust(deflectForce, deflectAngle);
				mo.Vel.Z += frandom(-8., 8.) * min(deflectForce, 1.);
			}
			
			if (dvdsdebug_showmeleeinformation) Console.Printf(
				"%s's %s hit %s for %d %s damage, resulting in %s.",
				self.GetClassName(),
				invoker.GetClassName(),
				mo.GetClassName(),
				actualDamage, invoker.DamageType,
				(shouldPuff && shouldBleed)?
					String.Format("a %s and blood", puff.GetClassName()) :
					shouldPuff? String.Format("a %s", puff.GetClassName()) :
					shouldBleed? "blood" :
					"neither a puff nor blood"
			);
			
			actorsHit = true;
		}
		
		if (!actorsHit && puffWalls)
		{
			let wallHitAngle = Normalize180(self.Angle + swingAngle);
			
			let puff = LineAttack(
				Normalize180(self.Angle + swingAngle),
				range,
				AimLineAttack(swingAngle, range),
				random(damageMin, damageMax),
				puffDefaults.DamageType,
				puffType
			);
			
			if (puff is "SceptrePuff")
			{
				SceptrePuff(puff).SceptreLevel = invoker.SceptreLevel;
				SceptrePuff(puff).WhatWasHit = SceptrePuff.HIT_WALL;
			}
		}
	}
	
	// Note: Don't call this during an attack sequence, or Flora will be killed by her own weapon!
	// See relevant feature request: https://forum.zdoom.org/viewtopic.php?f=15&t=58468
	action void A_SceptreDefend()
	{
		if (invoker.Shield)
			invoker.Shield.EffectTics = 2;
		else
			invoker.Shield = SceptreShieldPower(self.GiveInventoryType("SceptreShieldPower"));
		
		A_SceptreAttack(damageMin: 0, damageMax: 0, puffWalls: false, rememberAlreadyHitActors: false);
	}
	
	bool CheckSpinAttack()
	{
		return
			Owner && Owner.player &&
			(Owner.player.cmd.buttons & SpinAttackButtons) == SpinAttackButtons &&
			CallACS("GetMiscellaneousVar", 244);
	}
	
	bool CheckAerialAttack()
	{
		return
			CharLevel >= AerialAttackMinCharLevel &&
			SceptreLevel >= AerialAttackMinSceptreLevel &&
			Owner && Owner.player &&
			Owner.Vel.Z < 0. &&
			(Owner.player.cmd.buttons & AerialAttackButtons) == AerialAttackButtons;
	}
	
	// Starting offset (completely offscreen): 87, 112
	// Ending offset (completely onscreen): 0, 32
	// Number of frames: 10
	// Interpolation step: -8.7, -8
	static const double SceptreRaiseStartOffset[] = { 87, 80 + WEAPONTOP };
	static const double SceptreRaiseEndOffset[] = { 0, WEAPONTOP };
	static const double SceptreRaiseStep[] = { -8.7, -8 };
	
	/** This should be called on a TNT1 A 1 frame, before beginning the sceptre raise animation proper. */
	action void A_SceptreBeginRaise()
	{
		A_WeaponOffset(invoker.SceptreRaiseStartOffset[0], invoker.SceptreRaiseStartOffset[1]);
	}
	
	action state A_SceptreRaise(statelabel andThen = null, double speed = 1)
	{
		if (!player)
			return null;
		
		let ps = player.FindPSprite(PSP_WEAPON);
		if (!ps)
			return null;
		
		if (andThen && ps.x <= invoker.SceptreRaiseEndOffset[0] && ps.y <= invoker.SceptreRaiseEndOffset[1])
		{
			if (andThen == "Ready")
				A_Raise(0);
			return ResolveState(andThen);
		}
		else
		{
			let nx = max(ps.x + (invoker.SceptreRaiseStep[0] * speed), invoker.SceptreRaiseEndOffset[0]);
			let ny = max(ps.y + (invoker.SceptreRaiseStep[1] * speed), invoker.SceptreRaiseEndOffset[1]);
			A_WeaponOffset(nx, ny, WOF_INTERPOLATE);
			return null;
		}
	}
	
	action state A_SceptreLower(statelabel andThen = null, bool switchWeaponWhenDone = false, double speed = 1)
	{
		if (!player)
			return null;
		
		let ps = player.FindPSprite(PSP_WEAPON);
		if (!ps)
			return null;
		
		if (ps.x >= invoker.SceptreRaiseStartOffset[0] && ps.y >= invoker.SceptreRaiseStartOffset[1])
		{
			if (switchWeaponWhenDone)
			{
				A_WeaponOffset(0, WEAPONBOTTOM);
				A_Lower();
				return null;
			}
			else
				return ResolveState(andThen);
		}
		else
		{
			let nx = min(ps.x - (invoker.SceptreRaiseStep[0] * speed), invoker.SceptreRaiseStartOffset[0]);
			let ny = min(ps.y - (invoker.SceptreRaiseStep[1] * speed), invoker.SceptreRaiseStartOffset[1]);
			A_WeaponOffset(nx, ny, WOF_INTERPOLATE);
			return null;
		}
	}
	
	action void A_SceptreRaiseReset()
	{
		A_WeaponOffset(invoker.SceptreRaiseEndOffset[0], invoker.SceptreRaiseEndOffset[1]);
	}
	
	states
	{
		Spawn:
			SERP C -1 nodelay
			{
				if (
					!multiplayer &&
					playeringame[0] &&
					(
						!(players[0].mo is "FloraBriscoletti") ||
						players[0].mo.CountInv("SceptreOfEmpyrea")
					)
				)
					Destroy();
			}
			stop;
		
		Select:
			TNT1 A 1
			{
				A_SceptreBeginRaise();
				A_SetCrosshair(8);
				SetInventory("DrawingDiarisBow", 0);
				invoker.AnimSpeedsEnabled = true;
			}
			
			SCEM A 1 A_SceptreRaise("Ready");
			wait;
		
		Deselect:
			TNT1 A 0
			{
				A_SetCrosshair(0);
				CallACS("MiscVarSetDECORATE",397,0);
			}
			
			SCEM A 1 A_SceptreLower(switchWeaponWhenDone: true);
			wait;
		
		Ready:
			TNT1 A 0
			{
				invoker.ActorsHitThisSwing.Clear();
				A_SceptreRaiseReset();
			}
			
			SCEM A 1
			{
				invoker.bMeleeWeapon = random(1,100) <= 95;
				A_WeaponReady(WRF_ALLOWUSER1);
			}
			wait;
		
		Fire:
			SCEM A 1
			{
				if (!invoker.CanOwnerMove())
					return state(null);
				else if (invoker.CheckAerialAttack())
					return ResolveState("AerialAttack");
				else if (invoker.CheckSpinAttack())
					return ResolveState("SpinAttack");
				else
					return A_SceptreLower("Hold", speed: 1.5);
			}
			wait;
		
		Hold:
			TNT1 A 0 A_SceptreRaiseReset;
			
			TNT1 A 1
			{
				let inMenu = CallACS("GetMiscellaneousVar", 2500);
				let asleep = CallACS("GetBuffTimer", 20);
				
				if (!invoker.CanOwnerMove())
					return ResolveState("Hold");
				else if (player.cmd.buttons & BT_USER1)
					return ResolveState("User1");
				else if (invoker.CheckSpinAttack())
					return ResolveState("SpinAttack");
				else if (player.cmd.buttons & BT_ALTATTACK)
					return ResolveState("Select");
				else if (player.cmd.buttons & BT_ATTACK)
					return state(null);
				else
					return ResolveState("Swing");
			}
			wait;
		
		Swing:
			TNT1 A 0
			{
				if (!CallACS("UseStaminaAttack", invoker.SceptreSwingStaminaCost[invoker.SceptreLevel]))
					return ResolveState("Select");
				
				CallACS("AddSceptreEXP", 0, 1, 1);
				A_Kiai(63);
				A_PlaySound(invoker.SceptreSwingSounds[invoker.SceptreLevel], CHAN_WEAPON);
				invoker.SwingAngle = SwingAngleStart;
				
				// Strife mode makes the punch work like the Punch Dagger where it NEVER makes sound
				if (!(gameinfo.gametype & GAME_Strife) && (random() & 255) >= 252)
					// Sometimes a swing will be enough to wake up all monsters in the area.
					A_AlertMonsters();
				
				CallACS("StartTensionCountDown");
				
				return state(null);
			}
			
			SCEM DEFGHIJKLMNO 1 {
				A_SceptreAttack(
					invoker.SceptreRange[invoker.SceptreLevel],
					invoker.SceptreDamageMin[invoker.SceptreLevel],
					invoker.SceptreDamageMax[invoker.SceptreLevel],
					"SceptrePuff",
					invoker.SwingAngle += invoker.SwingAngleStep,
					SceptreOfEmpyreaZSC.SwingAngleStep
				);
			}
			goto Select;
		
		SpinAttack:
			// TODO
			/*
			TNT1 A 0
			{
				if (!CallACS("UseStaminaAttack", SceptreSpinAttackStaminaCost[SceptreLevel]))
					return ResolveState("Ready");
				
				// Strife mode makes the punch work like the Punch Dagger where it NEVER makes sound
				if (!(gameinfo.gametype & GAME_Strife) && (random() & 255) >= 248)
					// Sometimes a swing will be enough to wake up all monsters in the area.
					A_AlertMonsters();
				
				A_Kiai(31);
			}
			*/
			goto Hold;
			
		AerialAttack:
			goto Hold;
		
		AltFire:
			FLHS A 1 A_SceptreDefend;
			#### # 0 A_ReFire;
			goto Ready;
	}
}

class SceptrePuff : AetheriusMeleePuff
{
	default
	{
		VSpeed 0;
		RenderStyle 'Translucent';
		DamageType 'Sceptre';
		+PUFFONACTORS;
		+FORCEPAIN;
		+SPECTRAL;
	}
	
	// The following tables were generated by tools/generate-sceptre-constants.zc.
	static const Sound HitThingSounds[] =
	{
		"SceptreHitThing1", "SceptreHitThing1", "SceptreHitThing1", "SceptreHitThing1",
		"SceptreHitThing1", "SceptreHitThing1", "SceptreHitThing1", "SceptreHitThing1",
		"SceptreHitThing2", "SceptreHitThing2", "SceptreHitThing2", "SceptreHitThing2",
		"SceptreHitThing2", "SceptreHitThing2", "SceptreHitThing2", "SceptreHitThing2",
		"SceptreHitThing3"
	};
	
	static const Sound HitWallSounds[] =
	{
		"SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall",
		"SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall",
		"SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall", "SceptreEmpyrea/HitWall1",
		"SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall1",
		"SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall1",
		"SceptreEmpyrea/HitWall1", "SceptreEmpyrea/HitWall2"
	};
	
	static const int QuakeBaseIntensity[] =
	{
		1, 1, 1, 1, 1, 1,
		1, 1, 2, 2, 2, 2,
		2, 2, 2, 2, 3
	};
	
	static const int QuakeBaseDuration[] =
	{
		8, 8, 9, 9, 10, 10,
		11, 11, 12, 12, 13, 13,
		14, 14, 15, 15, 16
	};
	
	static const int QuakeBaseRadius[] =
	{
		512, 544, 576, 608, 640, 672,
		704, 736, 768, 800, 832, 864,
		896, 928, 960, 992, 1024
	};
	
	static const float Scales[] =
	{
		0.375, 0.40625, 0.4375, 0.46875, 0.5, 0.53125,
		0.5625, 0.59375, 0.625, 0.65625, 0.6875, 0.71875,
		0.75, 0.78125, 0.8125, 0.84375, 0.875
	};
	
	static const float Opacities[] =
	{
		0.5, 0.5208333, 0.5416666, 0.56249994, 0.58333325, 0.60416657,
		0.6249999, 0.6458332, 0.6666665, 0.6874998, 0.70833313, 0.72916645,
		0.74999976, 0.7708331, 0.7916664, 0.8124997, 0.833333
	};
	
	enum EWhatWasHit
	{
		HIT_WALL = 0, HIT_MONSTER, HIT_PROJECTILE
	};
	
	EWhatWasHit WhatWasHit;
	int SceptreLevel;
	
	action void A_SceptrePuffSpecial()
	{
		if (dvdsdebug_showmeleeinformation)
			Console.Printf("Sceptre puff spawned. Sceptre level is %d.", invoker.SceptreLevel);
		
		A_PuffQuake(
			invoker.QuakeBaseIntensity[invoker.SceptreLevel],
			invoker.QuakeBaseDuration[invoker.SceptreLevel],
			invoker.QuakeBaseRadius[invoker.SceptreLevel]
		);
		
		Sound hitSound = "";
		switch (invoker.WhatWasHit)
		{
			case HIT_WALL:
				hitSound = SceptrePuff.HitWallSounds[invoker.SceptreLevel];
				break;
			
			case HIT_MONSTER:
				hitSound = SceptrePuff.HitThingSounds[invoker.SceptreLevel];
				break;
			
			case HIT_PROJECTILE:
				// TODO
		}
		A_PlaySound(hitSound);
		
		invoker.Scale.X = invoker.Scales[invoker.SceptreLevel];
		invoker.Scale.Y = invoker.Scale.X;
		invoker.Alpha = invoker.Opacities[invoker.SceptreLevel];
	}
	
	states
	{
		Spawn:
		Melee:
		Crash:
			TNT1 A 1;
			TNT1 A 0
			{
				A_SceptrePuffSpecial();
				A_SpawnItemEx("SceptreShockwave", flags: SXF_NOCHECKPOSITION | SXF_TRANSFERSCALE | SXF_TRANSFERALPHA | SXF_TRANSFERPOINTERS);
			}
			SCPU CCDDDEEEFFFGGG 1 bright { Alpha -= Alpha / 5.; }
			stop;
	}
}

class SceptreShockwave : Actor
{
	default
	{
		+NOINTERACTION;
	}
	
	static const float Scales[] =
	{
		1.125, 1.21875, 1.3125, 1.40625, 1.5, 1.59375,
		1.6875, 1.78125, 1.875, 1.96875, 2.0625, 2.15625,
		2.25, 2.34375, 2.4375, 2.53125, 2.625
	};
	
	states
	{
		Spawn:
			TNT1 A 0 nodelay
			{
				invoker.Scale.X = invoker.Scales[CallACS("GetSceptreLevel")];
				invoker.Scale.Y = invoker.Scale.X;
			}
			
			SCSK GHIJK 1 bright { Alpha -= Alpha / 7.; }
			stop;
	}
}

class SceptreShieldPower : PowerShielded
{
	default
	{
		Powerup.Duration 2;
		PowerShielded.ShieldActorClass "SceptreShield";
	}
}

class SceptreShield : PowerShielded_Shield
{
	default
	{
		+REFLECTIVE;
		+NOTARGET;
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		if (
			!master ||
			master == other ||
			(other.bMissile && master == other.target)
		)
			return false;
		
		let ang = master.AngleTo(other);
		let rang = absangle(master.AngleTo(other), master.Angle);
		let block = rang <= SceptreOfEmpyreaZSC.MaxShieldAngle;
		
		if (dvdsdebug_sceptre_showshieldstatus)
		{
			if (block)
				Console.Printf(
					"%s blocked by %s!",
					other.GetClassName(),
					GetClassName()
				);
			else
				Console.Printf(
					"%s couldn't block a %s.",
					GetClassName(),
					other.GetClassName()
				);
		}
		
		return block;
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name damageType, int flags = 0, double angle = 0)
	{
		let rang = absangle(master.AngleTo(inflictor), master.Angle);
		let block = rang <= SceptreOfEmpyreaZSC.MaxShieldAngle;
		
		if (dvdsdebug_sceptre_showshieldstatus)
			Console.Printf(
				"%s was hit from angle %f (abs %f) by a %s fired by %s!",
				GetClassName(),
				angle, rang,
				inflictor.GetClassName(),
				source.GetClassName()
			);
		
		if (block)
		{
			if (dvdsdebug_sceptre_showshieldstatus)
				Console.Printf(
					"%d %s damage blocked by %s!",
					damage, damageType,
					GetClassName()
				);
			
			return 0;
		}
		
		if (dvdsdebug_sceptre_showshieldstatus)
			Console.Printf(
				"%s couldn't block %d %s damage.",
				GetClassName(),
				damage, damageType
			);
		
		return master.DamageMobj(inflictor, source, damage, damageType, flags, angle);
	}
}
