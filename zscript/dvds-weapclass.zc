class AetheriusBaseWeaponZSC : Weapon 
{
	// Spreader Aura Level 1 Angles
	const spread1angle1 = -15.0;
	const spread1angle2 = 15.0;
	const spread1horz1 = 0.0;
	const spread1horz2 = 0.0;
	const spread1height1 = 0.0;
	const spread1height2 = 0.0;

	// Spreader Aura Level 2 Angles/Pitches
	const spread2angle1 = -7.5;
	const spread2angle2 = 7.5;
	const spread2horz1 = 0.0;
	const spread2horz2 = 0.0;
	const spread2pitch1 = -7.5;
	const spread2pitch2 = 7.5;
	const spread2height1 = 0.0;
	const spread2height2 = 0.0;

	PSpriteSpeedScalerSet AnimSpeeds;
	bool AnimSpeedsEnabled;
	
	/**
	 * Computes the animation speed for this tic. If negative, then for each tic of animation, that many tics will be skipped. If positive, then for each tic of animation, that many tics will be added. This can be a fraction; -0.5 makes the weapons fire at 1.5Ã— of its normal rate.
	 *
	 * This method is called on every tic that this weapon is active, so make it quick!
	 */
	virtual float AnimSpeedFactor()
	{
		return 0;
	}
	
	override void Tick()
	{
		Super.Tick();
		
		if (AnimSpeedsEnabled && Owner && Owner.player && Owner.player.ReadyWeapon == self)
			AnimSpeeds.Tick(self, AnimSpeedFactor());
		else if (AnimSpeeds.first)
			AnimSpeeds.Clear();
	}
	
	bool CanOwnerMove()
	{
		let inMenu = CallACS("GetMiscellaneousVar", 2500);
		let asleep = CallACS("GetBuffTimer", 20);
		
		return !(inMenu || asleep);
	}

	void A_SceptreDvAvSwing()
	{
		if(CallACS("GetBuffTimer",7) > 0) { A_SetTics(0); }
	}
	
	void A_SceptreSwingShield()
	{
		let baseRange = CallACS("GetSceptreRange", 0);
		let maxpieces = baseRange / 32;
		for (let piece = 0; piece < maxpieces; piece++)
		{
			A_SpawnItemEx(
					piece == 0? "ShieldSpawnerSpinattack2D" : "ShieldSpawnerSpinattack2",
					CallACS("SetShieldPieceDist", baseRange - (piece * 32)),
					0, 0, 0, 0, 0, 0,
					SXF_NOCHECKPOSITION
			);
		}
/*
		int baserange = CallACS("GetSceptreRange",0);

	 A_SpawnItemEx ("ShieldSpawnerSpinattack2D", CallACS("SetShieldPieceDist",baserange), 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
	 A_SpawnItemEx ("ShieldSpawnerSpinattack2", CallACS("SetShieldPieceDist",baserange-32), 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
	 A_SpawnItemEx ("ShieldSpawnerSpinattack2", CallACS("SetShieldPieceDist",baserange-64), 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
	 A_SpawnItemEx ("ShieldSpawnerSpinattack2", CallACS("SetShieldPieceDist",baserange-96), 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
	 A_SpawnItemEx ("ShieldSpawnerSpinattack2", CallACS("SetShieldPieceDist",baserange-128), 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
*/
	}
	
	void A_UppercutBonus()
	{
		if (random(1,6) == 1)
		{ 
			A_GiveInventory("UppercutCritBonus2",1,AAPTR_PLAYER1); 
		}
		else
		{
			A_GiveInventory("UppercutCritBonus1",1,AAPTR_PLAYER1); 
		}

		if (random(1,6) == 1)
		{ 
			if (random(1,6) == 1)
			{ 
				A_GiveInventory("UppercutATKBonus2",1,AAPTR_PLAYER1); 
				A_GiveInventory("UppercutDEFBonus2",1,AAPTR_PLAYER1); 
			}
			else
			{ 
				A_GiveInventory("UppercutATKBonus1",1,AAPTR_PLAYER1); 
				A_GiveInventory("UppercutDEFBonus1",1,AAPTR_PLAYER1); 
			} 
		}
	}
 
	// Hell Warrior Shield
	void A_PHellWarShieldOff()
	{
		if (ACS_NamedExecuteWithResult("MiscVarCheckDECORATE",10053) >= 5) { A_SetTics(1); }
		A_TakeInventory("EWShieldDefendMode",0x7FFFFFFF);
		A_TakeInventory("EWShieldDefendModeExtra",0x7FFFFFFF);
		bREFLECTIVE = 0;
		//bSHIELDREFLECT = 0;
	}
	void A_PHellWarShieldOn()
	{
		A_GiveInventory("EWShieldDefendMode",1);
		A_TakeInventory("EWShieldDefendModeExtra",0x7FFFFFFF);
		if (random(1,4) == 1) { A_GiveInventory("EWShieldDefendModeExtra",1); } 
		bREFLECTIVE = 1;
		//bSHIELDREFLECT = 1;
	}
	
 
	// Spread Aura Function [Projectiles]
	void A_SpreadAuraFireProjectile (Class<Actor> missiletype, double angle = 0.0, int ammouseamount = 0, string ammousetype = "", float spawnofs_horz = 0.0, int spawnheight = 0, int flags = 0, double pitch = 0.0) 
	{
		if (CountInv("SpreaderAura2") > 0)
		{
			A_FireProjectile(missiletype,angle+spread2angle2,0,spawnofs_horz+spread2horz2,spawnheight+spread2height2,flags,pitch+spread2pitch2);
			A_FireProjectile(missiletype,angle+spread2angle2,0,spawnofs_horz+spread2horz2,spawnheight+spread2height1,flags,pitch+spread2pitch1);
			A_FireProjectile(missiletype,angle+spread2angle1,0,spawnofs_horz+spread2horz1,spawnheight+spread2height1,flags,pitch+spread2pitch1);
			A_FireProjectile(missiletype,angle+spread2angle1,0,spawnofs_horz+spread2horz1,spawnheight+spread2height2,flags,pitch+spread2pitch2);
		}
		if (CountInv("SpreaderAura1") > 0 || CountInv("SpreaderAura2") > 0)
		{
			A_FireProjectile(missiletype,angle+spread1angle1,0,spawnofs_horz+spread1horz1,spawnheight+spread1height1,flags,pitch);
			A_FireProjectile(missiletype,angle+spread1angle2,0,spawnofs_horz+spread1horz2,spawnheight+spread1height1,flags,pitch);
		}
		A_FireProjectile(missiletype,angle,0,spawnofs_horz,spawnheight,flags,pitch);

		A_TakeInventory(ammousetype,ammouseamount,TIF_NOTAKEINFINITE,AAPTR_DEFAULT);
	}

	// Spread Aura Function [Projectiles w/ AOE]
	void A_SpreadAuraFireProjectileAoE (Class<Actor> missiletype, Class<Actor> missiletypeaoe, double angle = 0.0, int ammouseamount = 0, string ammousetype = "", float spawnofs_horz = 0.0, int spawnheight = 0, int flags = 0, double pitch = 0.0) 
	{
		if (CountInv("SpreaderAura2") > 0)
		{
			A_FireProjectile(missiletypeaoe,angle+spread2angle2,0,spawnofs_horz+spread2horz2,spawnheight+spread2height2,flags,pitch+spread2pitch2);
			A_FireProjectile(missiletypeaoe,angle+spread2angle2,0,spawnofs_horz+spread2horz2,spawnheight+spread2height1,flags,pitch+spread2pitch1);
			A_FireProjectile(missiletypeaoe,angle+spread2angle1,0,spawnofs_horz+spread2horz1,spawnheight+spread2height1,flags,pitch+spread2pitch1);
			A_FireProjectile(missiletypeaoe,angle+spread2angle1,0,spawnofs_horz+spread2horz1,spawnheight+spread2height2,flags,pitch+spread2pitch2);
		}
		if (CountInv("SpreaderAura1") > 0 || CountInv("SpreaderAura2") > 0)
		{
			A_FireProjectile(missiletypeaoe,angle+spread1angle1,0,spawnofs_horz+spread1horz1,spawnheight+spread1height1,flags,pitch);
			A_FireProjectile(missiletypeaoe,angle+spread1angle2,0,spawnofs_horz+spread1horz2,spawnheight+spread1height1,flags,pitch);
		}
		A_FireProjectile(missiletype,angle,0,spawnofs_horz,spawnheight,flags,pitch);

		A_TakeInventory(ammousetype,ammouseamount,TIF_NOTAKEINFINITE,AAPTR_DEFAULT);
	}

	// Spread Aura Function [Melee Punch]
	void A_SpreadAuraCustomPunch (int damage, bool norandom = 0, int flags = 0, string pufftype = "", float range = 0.0, float lifesteal = 0.0, int lifestealmax = 0, string armorbonustype = "", sound meleesound = "", sound misssound = "") 
	{
		if (CountInv("SpreaderAura2") > 0)
		{
			// Angle + 15, Pitch + 0
			A_SetAngle(angle+spread1angle2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			// Angle + 7.5, Pitch + 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch+spread2pitch2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			// Angle + 7.5, Pitch - 7.5
			A_SetPitch(pitch-spread1angle2); 
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			// Angle + 0, Pitch + 0
			A_SetPitch(pitch+spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			// Angle - 7.5, Pitch - 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch-spread2pitch2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			// Angle - 7.5, Pitch + 7.5
			A_SetPitch(pitch+spread1angle2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			// Angle - 15, Pitch + 0
			A_SetPitch(pitch-spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			// Reset
			A_SetAngle(angle+spread1angle2);
		}
		else
		if (CountInv("SpreaderAura1") > 0)
		{
			A_SetAngle(angle+spread1angle2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			A_SetAngle(angle-spread1angle2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			A_SetAngle(angle-spread1angle2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			A_SetAngle(angle+spread1angle2);
		}
		else
		{
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
		}
	}

	// Spread Aura Function [Melee Chainsaw]
	void A_SpreadAuraSaw (string fullsound, string hitsound = "", int damage = 0, string pufftype = "", int flags = 0, int flagscenter = 0, float range = 0.0, float spread_xy = 0.0, float spread_z = 0.0, float lifesteal = 0.0, int lifestealmax = 0, string armorbonustype = "")
	{
		if (CountInv("SpreaderAura2") > 0)
		{
			// Angle + 15, Pitch + 0
			A_SetAngle(angle+spread1angle2);
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			// Angle + 7.5, Pitch + 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch+spread2pitch2);
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			// Angle + 7.5, Pitch - 7.5
			A_SetPitch(pitch-spread1angle2); 
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			// Angle + 0, Pitch + 0
			A_SetPitch(pitch+spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_Saw(fullsound,hitsound,damage,pufftype,flagscenter,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			// Angle - 7.5, Pitch - 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch-spread2pitch2);
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			// Angle - 7.5, Pitch + 7.5
			A_SetPitch(pitch+spread1angle2);
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			// Angle - 15, Pitch + 0
			A_SetPitch(pitch-spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			// Reset
			A_SetAngle(angle+spread1angle2);
		}
		else
		if (CountInv("SpreaderAura1") > 0)
		{
			A_SetAngle(angle+spread1angle2);
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			A_SetAngle(angle-spread1angle2);
			A_Saw(fullsound,hitsound,damage,pufftype,flagscenter,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			A_SetAngle(angle-spread1angle2);
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			A_SetAngle(angle+spread1angle2);
		}
		else
		{
			A_Saw(fullsound,hitsound,damage,pufftype,flagscenter,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
		}
	}

	// Spread Aura Function [Hitscan]
	void A_SpreadAuraFireBullets (double spread_horz, double spread_vert, int numbullets, int damage, string pufftype = "", int flags = 0, int flagscenter = 0, float range = 8192, string missile = "", float spawnheight = 0.0, float spawnofs_xy = 0.0, int ammouseamount = 0, string ammousetype = "")
	{
		if (CountInv("SpreaderAura2") > 0)
		{
			// Angle + 15, Pitch + 0
			A_SetAngle(angle+spread1angle2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			// Angle + 7.5, Pitch + 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch+spread2pitch2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			// Angle + 7.5, Pitch - 7.5
			A_SetPitch(pitch-spread1angle2); 
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			// Angle + 0, Pitch + 0
			A_SetPitch(pitch+spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,flagscenter,range,missile,spawnheight,spawnofs_xy);
			// Angle - 7.5, Pitch - 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch-spread2pitch2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			// Angle - 7.5, Pitch + 7.5
			A_SetPitch(pitch+spread1angle2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			// Angle - 15, Pitch + 0
			A_SetPitch(pitch-spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			// Reset
			A_SetAngle(angle+spread1angle2);
		}
		else
		if (CountInv("SpreaderAura1") > 0)
		{
			A_SetAngle(angle+spread1angle2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			A_SetAngle(angle-spread1angle2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,flagscenter,range,missile,spawnheight,spawnofs_xy);
			A_SetAngle(angle-spread1angle2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			A_SetAngle(angle+spread1angle2);
		}
		else
		{
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,flagscenter,range,missile,spawnheight,spawnofs_xy);
		}
		A_TakeInventory(ammousetype,ammouseamount,TIF_NOTAKEINFINITE,AAPTR_DEFAULT);
	}

	// Spread Aura Function [Railgun]
	void A_SpreadAuraRailAttack (int damage, int spawnofs_xy = 0, int ammouseamount = 0, string ammousetype = "", color ringcolor = 0, color corecolor = 0, int flags = 0, int maxdiff = 0, string pufftype = "", float spread_xy = 0.0, float spread_z = 0.0, int range = 8192, int duration = 35, float sparsity = 1.0, float driftspeed = 1.0, string spawnclass = "", float spawnofs_z = 0.0, int spiraloffset = 270, int limit = 0) 
	{
		if (CountInv("SpreaderAura2") > 0)
		{
			// Angle + 15, Pitch + 0
			A_SetAngle(angle+spread1angle2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			// Angle + 7.5, Pitch + 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch+spread2pitch2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			// Angle + 7.5, Pitch - 7.5
			A_SetPitch(pitch-spread1angle2); 
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			// Angle + 0, Pitch + 0
			A_SetPitch(pitch+spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			// Angle - 7.5, Pitch - 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch-spread2pitch2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			// Angle - 7.5, Pitch + 7.5
			A_SetPitch(pitch+spread1angle2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			// Angle - 15, Pitch + 0
			A_SetPitch(pitch-spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			// Reset
			A_SetAngle(angle+spread1angle2);
		}
		else
		if (CountInv("SpreaderAura1") > 0)
		{
			A_SetAngle(angle+spread1angle2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			A_SetAngle(angle-spread1angle2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			A_SetAngle(angle-spread1angle2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			A_SetAngle(angle+spread1angle2);
		}
		else
		{
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
		}
		A_TakeInventory(ammousetype,ammouseamount,TIF_NOTAKEINFINITE,AAPTR_DEFAULT);
	}

	// Used for Hellcore weapons to allow them to shoot Crisis attacks when the player's health is low. :V
	void A_HellCoreCrisisCheck (void)
	{
		A_TakeInventory("PlayerCanUseCrisisAttacks",9999,AAPTR_PLAYER1); 
		if (CountInv("CriticalHealth",AAPTR_PLAYER1) > 0) 
		{
			A_GiveInventory("PlayerCanUseCrisisAttacks",1,AAPTR_PLAYER1); 
		} 
		else 
		{ 
			if (CountInv("LowHealth",AAPTR_PLAYER1) > 0 && random(1,4) == 4) 
			{ 
				A_GiveInventory("PlayerCanUseCrisisAttacks",1,AAPTR_PLAYER1); 
			} 
		}	   
	}

	void A_PlayCrisisAtkSound ()
	{
		A_PlaySound("crisisattack",6);
		A_PlaySound("crisisattack2",7);
	}
	
	action void A_Kiai(int chance = 255)
	{
		if
		(
			chance &&
			self && self is "AetheriusPlayerPawn" &&
			AetheriusPlayerPawn(self).KiaiSound &&
			(
				chance >= 255 ||
				random2() >= chance
			)
		)
			A_PlaySound(AetheriusPlayerPawn(self).KiaiSound, CHAN_VOICE);
	}
}

class AetheriusBaseCustomInventoryZSC : CustomInventory 
{
	// Spreader Aura Level 1 Angles
	const spread1angle1 = -15.0;
	const spread1angle2 = 15.0;
	const spread1horz1 = 0.0;
	const spread1horz2 = 0.0;
	const spread1height1 = 0.0;
	const spread1height2 = 0.0;

	// Spreader Aura Level 2 Angles/Pitches
	const spread2angle1 = -7.5;
	const spread2angle2 = 7.5;
	const spread2horz1 = 0.0;
	const spread2horz2 = 0.0;
	const spread2pitch1 = -7.5;
	const spread2pitch2 = 7.5;
	const spread2height1 = 0.0;
	const spread2height2 = 0.0;

	// Spread Aura Function [Projectiles]
	void A_SpreadAuraFireProjectile (Class<Actor> missiletype, double angle = 0.0, int ammouseamount = 0, string ammousetype = "", float spawnofs_horz = 0.0, int spawnheight = 0, int flags = 0, double pitch = 0.0) 
	{
		if (CountInv("SpreaderAura2") > 0)
		{
			A_FireProjectile(missiletype,angle+spread2angle2,0,spawnofs_horz+spread2horz2,spawnheight+spread2height2,flags,pitch+spread2pitch2);
			A_FireProjectile(missiletype,angle+spread2angle2,0,spawnofs_horz+spread2horz2,spawnheight+spread2height1,flags,pitch+spread2pitch1);
			A_FireProjectile(missiletype,angle+spread2angle1,0,spawnofs_horz+spread2horz1,spawnheight+spread2height1,flags,pitch+spread2pitch1);
			A_FireProjectile(missiletype,angle+spread2angle1,0,spawnofs_horz+spread2horz1,spawnheight+spread2height2,flags,pitch+spread2pitch2);
		}
		if (CountInv("SpreaderAura1") > 0 || CountInv("SpreaderAura2") > 0)
		{
			A_FireProjectile(missiletype,angle+spread1angle1,0,spawnofs_horz+spread1horz1,spawnheight+spread1height1,flags,pitch);
			A_FireProjectile(missiletype,angle+spread1angle2,0,spawnofs_horz+spread1horz2,spawnheight+spread1height1,flags,pitch);
		}
		A_FireProjectile(missiletype,angle,0,spawnofs_horz,spawnheight,flags,pitch);

		A_TakeInventory(ammousetype,ammouseamount,TIF_NOTAKEINFINITE,AAPTR_DEFAULT);
	}

}

// Horn Rod FX 2 ------------------------------------------------------------
class HornRodFX2Base : Actor
{
	Default
	{
		Radius 12;
		Height 8;
		Speed 22;
		Damage 10;
		Health 140;
		Projectile;
		RenderStyle "Add";
		SeeSound "weapons/hornrodpowshoot";
		DeathSound "weapons/hornrodpowhit";
		Obituary "$OB_MPPSKULLROD";
	}

	States
	{
	Spawn:	
		FX00 C 3 BRIGHT;
		FX00 D 3 BRIGHT A_SeekerMissile(10, 30);
		FX00 E 3 BRIGHT;
		FX00 F 3 BRIGHT A_SeekerMissile(10, 30);
		Loop;
	Death:
		FX00 H 5 BRIGHT A_AddPlayerRain;
		FX00 I 5 BRIGHT;
		FX00 J 4 BRIGHT;
		FX00 KLM 3 BRIGHT;
		FX00 G 1 A_HideInCeiling;
		FX00 G 1 A_SkullRodStorm;
		Wait;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		Sorcerer2 s2 = Sorcerer2(target);
		if (s2 != null && random[HornRodFX2]() < 96)
		{ // D'Sparil teleports away
			s2.DSparilTeleport ();
			return -1;
		}
		return damage;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_AddPlayerRain
	//
	//----------------------------------------------------------------------------

	void A_AddPlayerRain()
	{
		RainTracker tracker;

		if (target == null || target.health <= 0)
		{ // Shooter is dead or nonexistant
			return;
		}

		tracker = RainTracker(target.FindInventory("RainTracker"));

		// They player is only allowed two rainstorms at a time. Shooting more
		// than that will cause the oldest one to terminate.
		if (tracker != null)
		{
			if (tracker.Rain1 && tracker.Rain2)
			{ // Terminate an active rain
				if (tracker.Rain1.health < tracker.Rain2.health)
				{
					if (tracker.Rain1.health > 16)
					{
						tracker.Rain1.health = 16;
					}
					tracker.Rain1 = null;
				}
				else
				{
					if (tracker.Rain2.health > 16)
					{
						tracker.Rain2.health = 16;
					}
					tracker.Rain2 = null;
				}
			}
		}
		else
		{
			tracker = RainTracker(target.GiveInventoryType("RainTracker"));
		}
		// Add rain mobj to list
		if (tracker.Rain1)
		{
			tracker.Rain2 = self;
		}
		else
		{
			tracker.Rain1 = self;
		}
		ActiveSound = "misc/rain";
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_HideInCeiling
	//
	//----------------------------------------------------------------------------

	void A_HideInCeiling()
	{
		// This no longer hides in the ceiling. It just makes the actor invisible and keeps it in place.
		// We need its actual position to determine the correct ceiling height in A_SkullRodStorm.
		bInvisible = true;
		bSolid = false;
		bMissile = false;
		Vel = (0,0,0);
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_SkullRodStorm [CUSTOMIZED for Aetherius Acid Rain stuff] :V
	//
	//----------------------------------------------------------------------------
	void A_AcidRainDrop(Class<Actor> missiletype, int xradius = 64, int yradius = 64)
	{
		static const Name translations[] =
		{
			"RainPillar1", "RainPillar2", "RainPillar3", "RainPillar4",
			"RainPillar5", "RainPillar6", "RainPillar7", "RainPillar8"
		};

		 double xo = random(-xradius,xradius); // ((Random[SkullRodStorm]() & 127) - 64);
		 double yo = random(-yradius,yradius); // ((Random[SkullRodStorm]() & 127) - 64);
		 Vector3 spawnpos = Vec2OffsetZ(xo, yo, pos.z);
		 Actor mo = Spawn(missiletype, spawnpos, ALLOW_REPLACE);
		 if (!mo) return;
		
		 // Find the ceiling above the spawn location. This may come from 3D floors but will not reach through portals.
		 // (should probably be fixed for portals, too.)
		 double newz = mo.CurSector.NextHighestCeilingAt(mo.pos.x, mo.pos.y, mo.pos.z, mo.pos.z, FFCF_NOPORTALS) - mo.height;
		 mo.SetZ(newz);

		 if (multiplayer && target.player)
		 {
			mo.A_SetTranslation(translations[target.PlayerNumber()]);
		 }
		 mo.target = target;
		 mo.Vel.X = MinVel; // Force collision detection
		 mo.Vel.Z = -mo.Speed;
	 	 mo.CheckMissileSpawn (radius);
	 	 if (ActiveSound > 0) A_PlaySound(ActiveSound, CHAN_BODY, 1, true);
	}

	void A_SkullRodStorm(Class<Actor> missiletype = "RainPillar", 
			int xradius =             64,	int yradius =             64, 
			int rainspawnchance1 =   231,	int rainspawnchance2 =    16,	int rainspawnchance3 =     0,	int rainspawnchance4 =     0, 
			int rainspawnchance5 =     0,	int rainspawnchance6 =     0,	int rainspawnchance7 =     0,	int rainspawnchance8 =     0, 
			int rainspawnchance9 =     0,	int rainspawnchance10 =    0,	int rainspawnchance11 =    0,	int rainspawnchance12 =    0, 
			int rainspawnchance13 =    0,	int rainspawnchance14 =    0,	int rainspawnchance15 =    0,	int rainspawnchance16 =    0)
	{
		if (health-- == 0)
		{
			A_StopSound (CHAN_BODY);
			if (target == null)
			{ // Player left the game
				Destroy ();
				return;
			}
			RainTracker tracker = RainTracker(target.FindInventory("RainTracker"));
			if (tracker != null)
			{
				if (tracker.Rain1 == self)
				{
					tracker.Rain1 = null;
				}
				else if (tracker.Rain2 == self)
				{
					tracker.Rain2 = null;
				}
			}
			Destroy ();
			return;
		}
		if (Random[SkullRodStorm](1,256) <= rainspawnchance1) A_AcidRainDrop(missiletype,xradius,yradius);
		if (Random[SkullRodStorm](1,256) <= rainspawnchance2) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance3) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance4) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance5) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance6) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance7) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance8) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance9) A_AcidRainDrop(missiletype,xradius,yradius);
		if (Random[SkullRodStorm](1,256) <= rainspawnchance10) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance11) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance12) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance13) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance14) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance15) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance16) A_AcidRainDrop(missiletype,xradius,yradius); 
	}

	
}
